{
  "free": false,
  "price": 50,
  "premiumPrice": 500,
  "id": "alosiqu45",
  "title": "Rust",
  "description": "Rust is a statically typed, multi paradigm programming language which excels at performance and safety.",
  "modules": [
    {
      "id": "alosiuqwk",
      "title": "Intro to Rust",
      "free": true,
      "challenges": [
        {
          "id": "1UMWYNFnEH",
          "type": "section",
          "title": "The Rust Language",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined.\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "[Rust](https://doc.rust-lang.org/rust-by-example/index.html) is a powerful programming language which offers the speed of a compiled language like C\\+\\+ but with many of the abstractions and safety guarantees present in higher level languages. It does this with the help of a sophisticated compiler system.\n\nFirst we will start with 3 intro challenges which are intended to highlight some of the basics of Rust and give you a quick onboarding to writing some Rust code.\n\nProceed to the next challenge to begin\\!"
        },
        {
          "id": "S@Ghw6X75",
          "type": "rust",
          "title": "Intro to Rust",
          "instructions": "Complete the function in the editor which adds two numbers together. [Rust](https://www.rust-lang.org) is a fairly new programming language which is growing rapidly in popularity. Rust famously tries to provide the speed of a low level compiled language with the productivity of a richly featured high level language.",
          "testCode": "test(\"The `add` function should exist and add two numbers together.\", async () => {\n  const RUST_CODE_STRING = __user_code_string__;\n\n  const RUST_TEST_STRING = `\n    fn test() -> bool {\n      let mut result = add(10, 5);\n      let mut expected = 15;\n      if result != expected {\n          return false;\n      }\n\n      result = add(100, 200);\n      expected = 300;\n      if result != expected {\n          return false;\n      }\n\n      result = add(10, 25);\n      expected = 35;\n      if result != expected {\n          return false;\n      }\n\n      result = add(-15, 15);\n      expected = 0;\n      if result != expected {\n          return false;\n      }\n\n      result = add(1000, -2000);\n      expected = -1000;\n      if result != expected {\n          return false;\n      }\n\n      true\n    }\n  `;\n\n  const result = await executeRustChallengeTests(\n    RUST_CODE_STRING,\n    RUST_TEST_STRING\n  );\n\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A function to add two numbers together\nfn add(a: i32, b: i32) -> i32 {\n  // Your code here\n}\n",
          "solutionCode": "// Write an add function using Rust\nfn add(a: i32, b: i32) -> i32 {\n  a + b\n}\n",
          "content": ""
        },
        {
          "id": "Qug@7dDI$",
          "type": "rust",
          "title": "Variable Mutability",
          "instructions": "In Rust values are immutable by default. You have to opt\\-in to mutability. You can do this in variable declarations using the `mut` keyword\\. The `cost` integer is defined in the editor below. Next, we try to change this value—but this code doesn't compile. Fix the problem by making the variable mutable.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let result = get_cost();\n      if result != 500 {\n        return false;\n      }\n\n      return true;\n    }\n  `;\n\ntest(\"The `cost` variable should be mutable and equal to `500`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  if (!CODE_STRING.includes(\"let mut cost\")) {\n    throw new Error(\"cost must be mutable.\");\n  }\n\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_cost() -> i32 {\n  let cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "solutionCode": "fn get_cost() -> i32{\n  let mut cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "EknAkk16W",
          "title": "Rust's Result Type",
          "instructions": "Some of the most commonly used and powerful types in Rust are the [Option](https://doc.rust-lang.org/rust-by-example/std/option.html) and [Result](https://doc.rust-lang.org/rust-by-example/error/result.html) type\\. These types allow you to represent values that may be in one of two potential states, i.e. \"some\" or \"none\" in the case of the `Option` type and \"valid/ok\" or \"error/failure\" in the case of the `Result` type\\.\n\nThe application of these types in Rust combined with the strictness of the Rust compiler are intended to create a programming experience where all of the \"null point exception\" and \"cannot read property of undefined\" classes of errors are simply not possible because of extensive type checking.\n\nIn the editor below, we have some simple code which explores usage of the Result type. You will see the `is_number_valid` which returns a `Result`. Your job is to add a conditional `if` clause to this function which returns the valid Result, an \"ok\" [unit type](https://doc.rust-lang.org/std/primitive.unit.html), if the provided `num` parameter is less than 25.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = true;\n\n      let mut fn_result = is_number_valid(5);\n      match fn_result {\n        Ok(()) => (),\n        Err(e) => {\n          result = false;\n        }\n      }\n\n      fn_result = is_number_valid(50);\n      match fn_result {\n        Ok(()) => {\n          result = false;\n        },\n        Err(e) => (),\n      }\n      \n      return result;\n    }\n  `;\n\ntest(\"The `is_number_valid` function should return a Result unit type `()` if the provided input is less than 25, or an `Err` type otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  // Your code here\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(50);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(5);\ncheck_result(invalid);",
          "solutionCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  if num < 25 {\n    return Ok(())\n  }\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(15);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(50);\ncheck_result(invalid);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "IIMmCDTle8",
          "title": "Comments",
          "instructions": "Comments in Rust are ignored by the compiler and convey helpful information and context to other future programmers. Their syntax is very similar to comment syntax in other languages.\n\nRead through the code in the editor to get a feel for the different comment styles in Rust. Don't worry if not all the code makes sense yet. When you are ready, click \"Run\" to complete the challenge. Don't forget to take a look at the console output before moving on.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code compiles. When you are ready run the code and take a look at the console output before moving on.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * This is a multi-line comment.\n *\n * The following code demonstrates various types of comment\n * usage. For regular comments you have /* ... */ multiline\n * comments like we are in now, and also single-line comments,\n * e.g. // This is my comment.\n *\n * Rust also supports standard documentation comments, which\n * are indicated using a triple slash: ///\n *\n * These documentation comments are displayed in the HTML\n * documentation generated when running 'cargo doc'. For\n * more on this take a look here:\n * https://doc.rust-lang.org/rust-by-example/meta/doc.html\n */\n\n/// Enum representing different possible weapon types\n#[derive(Debug)]\nenum WeaponTypes {\n  Sword,\n  Spear,\n  Dagger,\n  BowAndArrow,\n  Mace,\n  Axe,\n}\n\n/// A struct for a package item in a game\n#[derive(Debug)]\nstruct Weapon {\n  /// The weapon type\n  weapon_type: WeaponTypes,\n}\n\nimpl Weapon {\n  /// Create a new weapon, given a weapon type\n  pub fn new(weapon_type: WeaponTypes) -> Weapon {\n    Weapon {\n      weapon_type,\n    }\n  }\n}\n\n/**\n * This is a function to create some new weapons.\n */\nfn create_three_weapons() -> (Weapon, Weapon, Weapon) {\n  println!(\"\\nCreating 3 new weapons...\\n\");\n\n  // Create a sword\n  let sword = Weapon::new(WeaponTypes::Sword);\n  println!(\"Created a sword: {:?}\", sword);\n\n  // Create a mace\n  let mace = Weapon::new(WeaponTypes::Mace);\n  println!(\"Created a mace: {:?}\", mace);\n\n  // Create a sword\n  let dagger = Weapon::new(WeaponTypes::Dagger);\n  println!(\"Created a dagger: {:?}\", dagger);\n\n  println!(\"\\nFinished weapon creation!\");\n\n  // Return a tuple of the three created weapons\n  return (sword, mace, dagger);\n}\n\n// Create some weapons\ncreate_three_weapons();",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "vxOeSToH8",
          "title": "Logging Values with println!",
          "instructions": "Logging data while a program is running is important for development, debugging and various production use cases. Rust supports logging values primarily using the `println` macro which can be invoked with a `!`.\n\n```\n// Invoking the println macro:\nprintln!(\"Hello!\"); // Logs out \"Hello\"\n\n```\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = logging_demonstration();\n  \n  result\n}\n`;\n\ntest(\"The `logging_demonstration` function should return `true` once you are finished reading through the examples of `println`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * For most values you can use the println macro with {}\n * followed by the values you want to print out.\n *\n * For some values, you may need to use {:?}.\n *\n * The std::fmt library handles printing values and relies\n * on various traits, such as fmt::Debug and fmt::Display.\n * These traits must be derived or implemented for the values\n * you want to print out.\n *\n * If fmt::Display is implemented you can print a value using\n * using {}, if only Debug is implemented (which can usually\n * be derived) you will have to use {:?}.\n *\n * Don't worry about all these details much. For now, just\n * get a sense of how to use println to log values.\n */\nfn logging_demonstration() -> bool {\n  println!(\"\\n- Examples of using the println macro:\\n\");\n\n  let value = 52;\n  println!(\"Log a number: {}\", value);\n\n  let boolean = true;\n  println!(\"Log a boolean: {}\", boolean);\n\n  let name = \"Oren\";\n  println!(\"Log a string slice: {}\", name);\n\n  let a = 2;\n  let b = false;\n  let c = \"Hi!\";\n  // You can provide multiple arguments to println:\n  println!(\"Log out multiple values, a: {}, b: {}, c: {}\", a, b, c);\n\n  // We derive the fmt::Debug trait on our Person struct, to\n  // allow it to be printed using {:?} - otherwise, we would\n  // have to implement the fmt::Display trait.\n  #[derive(Debug)]\n  struct Person {\n    name: String,\n  }\n\n  let person = Person {\n    name: \"Sam\".to_string(),\n  };\n\n  // You must use {:?} to format values for which the Display\n  // trait has not been implemented, like the above Person.\n  println!(\"A Person: {:?}\", person);\n\n  let complete: bool = false;\n  println!(\"\\n- When you are ready, change the value of the complete variable from false to true to complete the challenge.\");\n\n  complete\n}\n\nlogging_demonstration();",
          "solutionCode": "/**\n * For most values you can use the println macro with {}\n * followed by the values you want to print out.\n *\n * For some values, you may need to use {:?}.\n *\n * The std::fmt library handles printing values and relies\n * on various traits, such as fmt::Debug and fmt::Display.\n * These traits must be derived or implemented for the values\n * you want to print out.\n *\n * If fmt::Display is implemented you can print a value using\n * using {}, if only Debug is implemented (which can usually\n * be derived) you will have to use {:?}.\n *\n * Don't worry about all these details much. For now, just\n * get a sense of how to use println to log values.\n */\nfn logging_demonstration() -> bool {\n  println!(\"\\n- Examples of using the println macro:\\n\");\n\n  let value = 52;\n  println!(\"Log a number: {}\", value);\n\n  let boolean = true;\n  println!(\"Log a boolean: {}\", boolean);\n\n  let name = \"Oren\";\n  println!(\"Log a string slice: {}\", name);\n\n  let a = 2;\n  let b = false;\n  let c = \"Hi!\";\n  // You can provide multiple arguments to println:\n  println!(\"Log out multiple values, a: {}, b: {}, c: {}\", a, b, c);\n\n  // We derive the fmt::Debug trait on our Person struct, to\n  // allow it to be printed using {:?} - otherwise, we would\n  // have to implement the fmt::Display trait.\n  #[derive(Debug)]\n  struct Person {\n    name: String,\n  }\n\n  let person = Person {\n    name: \"Sam\".to_string(),\n  };\n\n  // You must use {:?} to format values for which the Display\n  // trait has not been implemented, like the above Person.\n  println!(\"A Person: {:?}\", person);\n\n  let complete: bool = true;\n  println!(\"\\n- When you are ready, change the value of the complete variable from false to true to complete the challenge.\");\n\n  complete\n}\n\nlogging_demonstration();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "$Do6$e1dD",
          "title": "Naming: Snake Case",
          "instructions": "What is the convention for naming variables and functions in Rust? `snake_case`of course: all lowercase with words separated by underscores. As you learn more Rust, you will see that enforces strong conventions and rules in many cases which cannot be deviated from. Naming is no exception\\! Although it might feel frustrating at first, it means that any Rust code will have a basic level of familiarity to a seasoned Rust developer.\n\nUpdate the naming conventions in the editor to adhere to snake casing rules.\n\n> The code in the editor will compile. But if you were running `rustc` locally to see the full output you would see warnings on the variable names like this:\n> \n> ```\n> warning: function `myFunction` should have a snake case name\n> \n> ```\n> \n> Although you can name you functions and variables different, we would recommend sticking with the Rust convention of snake case.\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `myFunction` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_function\")).toBe(true);\n});\n\ntest(\"The `mySpecialValue` variable should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_special_value\")).toBe(true);\n});\n\ntest(\"The `functionResultValue` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"function_result_value\")).toBe(true);\n});\n",
          "videoUrl": "",
          "starterCode": "fn myFunction() -> u64 {\n  let mySpecialValue = 5000;\n\n  return mySpecialValue;\n}\n\nlet functionResultValue = myFunction();\nprintln!(\"functionResultValue: {:?}\", functionResultValue);",
          "solutionCode": "fn my_function() -> u64 {\n  let my_special_value = 5000;\n\n  return my_special_value;\n}\n\nlet function_result_value = my_function();\nprintln!(\"function_result_value: {:?}\", function_result_value);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "r2nYe0r8uk",
          "title": "Don't Panic",
          "instructions": "Rust is a type\\-safe language which tries meticulously to prevent runtime program errors. However, inevitably things still tend to go wrong from time to time. In Rust, a language facility exists for program states which are un\\-recoverable, or should not be possible. The \"panic\" macro can be invoked in such states:\n\n```\npanic!(\"This should not happen!\");\n\n```\n\nThis will halt and exit the program. We mention it here in the introduction, because you might encounter panicked code in the following challenges before we fully introduce topics such as macros, panicking, handling errors, the `Result` type, and so on. The purpose of this introduction is to inform you in advance in case you see a stacktrace like... well, try running the code in the editor to see what we mean.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and run without issues.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// What could go wrong here?\nlet x = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nlet y = x[80];\nprintln!(\"The value in x at index 80 is: {}\", y);",
          "solutionCode": "// What could go wrong here?\nlet x = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nlet y = x[8];\nprintln!(\"The value in x at index 80 is: {}\", y);",
          "content": ""
        },
        {
          "type": "media",
          "id": "3q8AK1mvF",
          "title": "How to Approach the Following Challenges",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "We've now seen some of the basics of the Rust language."
        }
      ]
    },
    {
      "id": "vjN$jfZeb",
      "title": "Data and Types",
      "challenges": [
        {
          "type": "section",
          "id": "6w$q0NkrZ",
          "title": "Primitive Data and Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust is a statically typed language which means the Rust compiler determines the type of all data in a program when it is compiled. The compiler enforces that only valid operations are allowed \\- for instance, you cannot arithmetically add a string to an integer type. This section will introduce the basic types and data primitives you have available to work with in the Rust language. In particular, there are two main categories of primitive types: scalar and compound.\n\n**Scalar** types represent a single value, and include the following:\n\n* Signed and unsigned integers.\n* Floating point numbers.\n* Arithmetic\\.\n* Booleans\\.\n* Characters\\.\n* The unit type.\n\n\n**Compound** types group several individual values into one type. In Rust compound type primitives include arrays and tuples.\n\nThroughout this module, you will also get a feeling for basic syntax in Rust, e.g. variable and function declarations, print statements, code comments, and other basics.\n\nIn the next module, we will cover basic Rust programming and higher level data structures."
        },
        {
          "type": "rust",
          "id": "hH8NF2FXav",
          "title": "Rust Syntax Primer",
          "instructions": "Before we dive in, let's start with a quick practice lesson to gain a foundation in basic Rust syntax, specifically how to define variables and functions in Rust.\n\nRead the code and comments in the editor, and then make a small change to solve the challenge.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = is_complete();\n\n  result\n}\n`;\n\ntest(\"The `is_complete` function should return the boolean `true`. Update this function to return `true` once you are satisifed you understand all the points here.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = false;\n}",
          "solutionCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = true;\n\n  i_read_and_understood_everything\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "d8WItf9JW",
          "title": "Integers",
          "instructions": "Initialize the `my_int` value in `get_integer` function in the editor to return a valid `i8` integer, an 8\\-bit signed integer. Rust supports multiple different integer data types, from 8 to 128 bit, each signed or unsigned. A \"signed\" integer is one that may be positive of negative, e.g. `-4` is a signed integer. Unsigned integers are assumed to be positive.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let n = get_integer();\n  let result = 5 + n;\n  let original = result - 5;\n\n  if n != original {\n    return false\n  }\n\n  return true\n}\n`;\n\ntest(\"The `my_int` variable in the `get_integer` should be correctly initialized.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "solutionCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8 = 15;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "z6DMvoh1T",
          "title": "Integer Type Sizes",
          "instructions": "The size of an integer data type refers to how much memory will be required to store the value, and hence, this imposes a limit on the size of the particular integer. An `i8` value, for instance, occupies 8 bits of space and can range from `-128` to `127`.\n\nThe editor below has a function `check_integer_i8_range` which uses the public `i8` constant `MIN` and `MAX` values and the `assert_eq!` macro \\(don't worry, more on all this later\\) to check that an input range falls within the bounds of an acceptable `i8` integer\\.\n\nUpdate the invocation of `check_integer_i8_range` so that the code compiles. Notice how the compiler is about to detect that the current code will fail, and even gives you a helpful hint\\!",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  check_integer_i8_range(-128, 127);\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `check_integer_i8_range` function should be invoked with the minimum and maximum bounds of an `i8` integer.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(\n    CODE_STRING.replace(/ /g, \"\").includes(\"check_integer_i8_range(-128,127)\")\n  ).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-500, 500);\n",
          "solutionCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-128, 127);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Y2SVKl8Xq",
          "title": "Practice With Integers",
          "instructions": "As we mentioned when introduced integer data types, Rust provides types from 8\\-bit up to 128\\-bit, signed and unsigned integers. Complete the function into the editor below by filling in all the integer types so the code compiles.\n\nDon't worry about the struct defined at the top of the editor—we will cover this later. Just deal with defining the variables correctly in the body of the `get_all_integer_data_types` function\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = get_all_integer_data_types();\n\n  let TestStruct = IntegerTypes {\n    eight_bit_signed: 50,\n    eight_bit_unsigned: 50,\n    sixteen_bit_signed: 50,\n    sixteen_bit_unsigned: 50,\n    thirty_two_bit_signed: 5000,\n    thirty_two_bit_unsigned: 5000,\n    sity_four_bit_signed: 5000,\n    sity_four_bit_unsigned: 5000,\n    one_hundred_twenty_eight_bit_signed: 5000,\n    one_hundred_twenty_eight_bit_unsigned: 5000,\n  };\n\n  let _a: i8 = result.eight_bit_signed + TestStruct.eight_bit_signed;\n  let _b: u8 = result.eight_bit_unsigned + TestStruct.eight_bit_unsigned;\n  let _c: i16 = result.sixteen_bit_signed + TestStruct.sixteen_bit_signed;\n  let _d: u16 = result.sixteen_bit_unsigned + TestStruct.sixteen_bit_unsigned;\n  let _e: i32 = result.thirty_two_bit_signed + TestStruct.thirty_two_bit_signed;\n  let _f: u32 = result.thirty_two_bit_unsigned + TestStruct.thirty_two_bit_unsigned;\n  let _g: i64 = result.sity_four_bit_signed + TestStruct.sity_four_bit_signed;\n  let _h: u64 = result.sity_four_bit_unsigned + TestStruct.sity_four_bit_unsigned;\n  let _i: i128 = result.one_hundred_twenty_eight_bit_signed + TestStruct.one_hundred_twenty_eight_bit_signed;\n  let _j: u128 = result.one_hundred_twenty_eight_bit_unsigned + TestStruct.one_hundred_twenty_eight_bit_unsigned;\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `get_all_integer_data_types` function should return a properly defined `IntegerTypes` struct, which includes all 10 different integer data types.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed;\n  let eight_bit_unsigned;\n\n  // 16-bit\n  let sixteen_bit_signed;\n  let sixteen_bit_unsigned;\n\n  // 32-bit\n  let thirty_two_bit_signed;\n  let thirty_two_bit_unsigned;\n\n  // 64-bit\n  let sity_four_bit_signed;\n  let sity_four_bit_unsigned;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed;\n  let one_hundred_twenty_eight_bit_unsigned;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "solutionCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed = -4;\n  let eight_bit_unsigned = 4;\n\n  // 16-bit\n  let sixteen_bit_signed = -500;\n  let sixteen_bit_unsigned = 500;\n\n  // 32-bit\n  let thirty_two_bit_signed = -10000;\n  let thirty_two_bit_unsigned = 10000;\n\n  // 64-bit\n  let sity_four_bit_signed = -10000000;\n  let sity_four_bit_unsigned = 10000000;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed = -10000000000;\n  let one_hundred_twenty_eight_bit_unsigned = 10000000000;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "6DWRvh7zW",
          "title": "Floating Point Numbers",
          "instructions": "Rust also provides basic data types to deal with floating point numbers. In Rust there are two floating point types: `f32` and `f64`, which use 32 and 64 bits, respectively.\n\nInitialize the two variables in the function body to floating point values so the code compiles correctly.\n\nIf you don't explicitly declare the type, Rust will assign `f64` as the default floating point data type, try doing this for the second variable in the function body.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = floating_point_types();\n  let _x: f32 = result.0;\n  let _y: f64 = result.1;\n\n  true\n}\n`;\n\ntest(\"The `floating_point_types` function should return a `(f32, f64)` type tuple, using the properly initialized values in the function body.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32;\n\n  // The type will default to f64\n  let floating_point_sixty_four;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32 = 213.12311;\n\n  // The type will default to f64\n  let floating_point_sixty_four = 32423.12313131;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "7ZmqyOC7T",
          "title": "Rust Arithmetic",
          "instructions": "Rust supports basic arithmetic similar to many other programming languages, using common operators such as `+`, `-`, `*`, `/`, and `%`. Complete the arithmetic helper functions in the editor with the appropriate operators.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _a = add(23.532, 42.592);\n  let _b: f64 = subtract(23.532, 42.592);\n  let _c: f64 = multiply(23.532, 42.592);\n  let _d: f64 = divide(23.532, 42.592);\n  let _e: f64 = modulus(23.532, 42.592);\n\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "solutionCode": "fn add(a: f64, b: f64) -> f64 {\n  a + b\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  a - b\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  a * b\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  a / b\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  a % b\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "U3$RxoovO",
          "title": "Boolean Values",
          "instructions": "In Rust boolean values can be `true` or `false` and as a type can be represented using the  `bool` keyword\\. Change the value of the variables in the `all_should_be_truthy` function in the editor according to the type annotations so the code compiles, and then return an appropriate value from the function.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = all_should_be_truthy();\n\n  result\n}\n`;\n\ntest(\"The `all_should_be_truthy` function should compile and return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 50 < 10;\n\n  // Change the variable value, not the if statement\n  if should_be_true  {\n    return false;\n  }\n\n  let should_be_false: bool = 250 > 50;\n\n  // Change the variable value, not the if statement\n  if should_be_false == true {\n    return false;\n  }\n\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "solutionCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 5 < 10;\n\n  if should_be_true == false {\n    return false;\n  }\n\n  let should_be_false: bool = 25 > 50;\n\n  if should_be_false == true {\n    return false;\n  }\n\n  return true;\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "content": ""
        },
        {
          "type": "rust",
          "id": "R@eJbCV7@",
          "title": "The Char Primitive",
          "instructions": "Next is the `char` data type, which represents a single character. This is the primitive type which is used to build up `str` and `String` types which are more commonly used to represent string values \\(more on these later\\). A `char` value is limited to a single character and represents a Unicode Scalar Value. Note that `char`s are declared using single quotes.\n\nAdjust the `return_a_char_value` function so the code compiles.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _result: char = return_a_char_value();\n\n  true\n}\n`;\n\ntest(\"The `return_a_char_value` function should compile and return a `char` value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn return_a_char_value() -> char {\n  let character: char = 'xyz';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "solutionCode": "fn return_a_char_value() -> char {\n  let character: char = 'x';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "FsJ$iEG44E",
          "title": "The Unit Type",
          "instructions": "In Rust, the [Unit](https://doc.rust-lang.org/std/primitive.unit.html) type exists to represent an empty/non\\-meaningful state. All expressions return the unit type unless they otherwise return another value explicitly.The unit type is useful when you need a placeholder to represent a specific state or value, but that particular state or value really has no other significant representation for it \\(such as the generic success or failure of some operation\\).\n\nInitialize the variable `four` in the editor below to the value of the unit type to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The variable `four` should be initialized as the unit type `()` so the code compiles correctly. \", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions, by deafult, return ()\nfn unit_one() {\n  println!(\"Functions return () by default.\");\n}\n\nfn unit_two() -> () {\n  println!(\"Adding a type signature doesn't change it.\");\n}\n\nfn unit_three() -> () {\n  println!(\"We can also return () directly at the end of the function.\");\n\n  ()\n}\n\nlet one = unit_one();\nlet two = unit_two();\nlet three = unit_three();\nlet four: ();\n\n// Assert the same return value\nif one == two && two == three && three == four {\n  println!(\"\\n- In Rust, all unit types are equivalent: () == ()\");\n}",
          "solutionCode": "// Functions, by deafult, return ()\nfn unit_one() {\n  println!(\"Functions return () by default.\");\n}\n\nfn unit_two() -> () {\n  println!(\"Adding a type signature doesn't change it.\");\n}\n\nfn unit_three() -> () {\n  println!(\"We can also return () directly at the end of the function.\");\n\n  ()\n}\n\nlet one = unit_one();\nlet two = unit_two();\nlet three = unit_three();\nlet four: () = ();\n\n// Assert the same return value\nif one == two && two == three && three == four {\n  println!(\"\\n- In Rust, all unit types are equivalent: () == ()\");\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "sLEaTrYvk",
          "title": "Array Primitives",
          "instructions": "Arrays in Rust have a fixed length and contain values of only a single type. Like arrays in other languages, they are zero indexed.\n\nTake a look at the code in the editor. It currently doesn't compile. Can you find the problem and fix it?",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = array_access();\n  assert_eq!(result.len(), 5);\n\n  true\n}\n`;\n\ntest(\"The code should compile and print out all 5 values in the `my_array` array.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn array_access() -> [i8; 5] {\n  // Arrays can be initialized as follows:\n  let my_array: [i8; 5] = [1,2,3,4,5];\n\n  // Array items can be accessed using the index:\n  let one = my_array[1];\n  println!(\"The 1st value in my_array is {}\", one);\n\n  let two = my_array[2];\n  println!(\"The 2nd value in my_array is {}\", two);\n\n  let three = my_array[3];\n  println!(\"The 3rd value in my_array is {}\", three);\n\n  let four = my_array[4];\n  println!(\"The 4th value in my_array is {}\", four);\n\n  let five = my_array[5];\n  println!(\"The 5th value in my_array is {}\", five);\n\n  my_array\n}\n\narray_access();",
          "solutionCode": "fn array_access() -> [i8; 5] {\n  // Arrays can be initialized as follows:\n  let my_array: [i8; 5] = [1,2,3,4,5];\n\n  // Array items can be accessed using the index:\n  let one = my_array[0];\n  println!(\"The 1st value in my_array is {}\", one);\n\n  let two = my_array[1];\n  println!(\"The 2nd value in my_array is {}\", two);\n\n  let three = my_array[2];\n  println!(\"The 3rd value in my_array is {}\", three);\n\n  let four = my_array[3];\n  println!(\"The 4th value in my_array is {}\", four);\n\n  let five = my_array[4];\n  println!(\"The 5th value in my_array is {}\", five);\n\n  my_array\n}\n\narray_access();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "sCOekMaC@",
          "title": "Array Indexing",
          "instructions": "The last challenge demonstrated something important: The Rust compiler checks for invalid array index access at compile time. If you have an array of length 3 and you try to access the item at index 10 this will fail at the compile step \\- assuming the compiler knows the value of the index you are trying to access at that step.\n\nIf it does not, i.e. if that value is only known at runtime, the program will _panic\\._ Take a look at the editor to see what we mean.\n\nThe code compiles, but fails at runtime. To fix this issue, update the while loop condition to stop at the length of the array. You can find the length of an array with the `.len` method\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and run without any runtime errors\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * When this code is run, it will compile but produce a runtime panic.\n */\nfn runtime_array_access() {\n  let array: [i8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  let mut index = 0;\n\n  while index < 11 {\n    let value = array[index];\n    println!(\"The value at index {} is: {}\", index, value);\n    index = index + 1;\n  }\n}\n\nruntime_array_access();",
          "solutionCode": "/**\n * When this code is run, it will compile but produce a runtime panic.\n */\nfn runtime_array_access() {\n  let array: [i8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  let mut index = 0;\n\n  while index < array.len() {\n    let value = array[index];\n    println!(\"The value at index {} is: {}\", index, value);\n    index = index + 1;\n  }\n}\n\nruntime_array_access();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "niJPS3cRO",
          "title": "Tuples",
          "instructions": "Tuples are the second primitive compound type available in Rust. They are similar to arrays in that they have a fixed length but different in that the items they contain may be of different types.\n\nIn the code below we define a new tuple type which contains several values, including an array. Update the function `tuple_demonstration` to return just this array from the provided tuple. Note that tuples are indexed just like arrays, but to access a tuple item by index you use a dot syntax, e.g. `my_tuple.2` would return the item at the 2nd index in `my_tuple`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let array = [7,3,5];\n  let example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\n  let result = tuple_demonstration(example_tuple);\n  assert_eq!(array, result);\n  true\n}\n`;\n\ntest(\"The `tuple_demonstration` function should return the array in the `CustomTuple` argument it is provided.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Tuple types can be declared like this:\ntype CustomTuple = (&'static str, bool, bool, u32, [i8; 3]);\n\nfn tuple_demonstration(custom_tuple: CustomTuple) -> [i8; 3] {  \n  println!(\"Tuple: {:?}\", custom_tuple);\n}\n\nlet array: [i8; 3] = [1, 2, 3];\n// A new tuple can be initialized directly like this:\nlet example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\ntuple_demonstration(example_tuple);",
          "solutionCode": "// Tuple types can be declared like this:\ntype CustomTuple = (&'static str, bool, bool, u32, [i8; 3]);\n\nfn tuple_demonstration(custom_tuple: CustomTuple) -> [i8; 3] {  \n  println!(\"Tuple: {:?}\", custom_tuple);\n\n  custom_tuple.4\n}\n\nlet array: [i8; 3] = [1, 2, 3];\n// A new tuple can be initialized directly like this:\nlet example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\ntuple_demonstration(example_tuple);",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "S3BmBYNCP",
      "title": "Rust Fundamentals",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "upbaggZVb",
          "title": "Variables and Functions",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will cover variables and functions in more detail. These challenges should be fairly quick since the previous module included many examples of variables and functions. Nevertheless, it should be helpful to explicitly mention a few points here."
        },
        {
          "type": "rust",
          "id": "C55Lmpb@L",
          "title": "Immutable by Default",
          "instructions": "In Rust, variables are immutable by default. This means you cannot change the value after declaration. Of course, sometimes you might want to change the value later on, so you can opt\\-in to mutability using the `mut` keyword\\.\n\nUpdate the code in the editor by making variables mutable. The `immutable_by_default` function should be invoked twice.\n\n> Use the `mut` keyword intentionally. When you see a mutable variable, it means the original programmer _intended_ for that variable to change later on. This conveys useful information, and it is important it is an opt\\-in behavior. \n> \n> Use `mut` only when you need it.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: u128 = immutable_by_default(807);\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `immutable_by_default` function should be invoked twice.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const matched = CODE_STRING.replace(/ /g, \"\").match(\n    /immutable_by_default\\(/g\n  ).length;\n  expect(matched).toBe(3);\n});\n\ntest(\"Two variables should be made mutable using the `mut` keyword.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const matched = CODE_STRING.replace(/ /g, \"\").match(/letmut/g).length;\n  expect(matched).toBe(2);\n});\n",
          "videoUrl": "",
          "starterCode": "fn immutable_by_default(input: u128) -> u128 {\n  let value = 52;\n\n  value = input;\n\n  value\n}\n\nlet result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "solutionCode": "fn immutable_by_default(input: u128) -> u128 {\n  let mut value = 52;\n\n  value = input;\n\n  value\n}\n\nlet mut result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "dMMvFPvNS",
          "title": "Variable Shadowing",
          "instructions": "While variables are immutable by default, it is in fact possible to change immutable variables values by redeclaring them with the same name. This is called variable shadowing. To shadow a variable, you simply declare it again using the `let` keyword\\.\n\nThe code in the editor tries to update the `name` variable\\. Allow this to work by using variable shadowing—do not use the `mut` keyword\\.\n\n> Shadowing, although perhaps a bit unusual, is useful when working with values which need to be updated or redeclared \\(even, changing to a different type\\) throughout a program. Specifically, shadowing helps the programmer avoid coming up with a new name for the variable.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `name` variable should be shadowing and printed out for a total of 5 times.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const count = CODE_STRING.replace(/ /g, \"\").match(/letname=/g).length;\n  expect(count).toBe(5);\n});\n",
          "videoUrl": "",
          "starterCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "solutionCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  let name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  let name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  let name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  let name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ohaohA5x9",
          "title": "Constants",
          "instructions": "You can also declare constants in Rust. Constants are like variables but their value is fixed at compile time and not subject to change throughout the life of the program. Constants are declared with the `const` keyword, are always immutable, and must have an explicit type annotation. Constants can be declared in any scope, including the global scope. They are ideal for global values which do not change throughout the life of a program.\n\nAdd type annotations to the constants in the editor so the code compiles.\n\n> For the string type, try to use the string slice reference type `&str`. We will cover strings more in detail later.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let x = DEBUG;\n  let y = MAX_HEIGHT;\n  let z = NAME;\n\n  true\n}\n`;\n\ntest(\"The three constants should be initialized correctly and the code should compile.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const DEBUG = false;\n\nconst MAX_HEIGHT = 52;\n\nconst NAME = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "solutionCode": "const DEBUG: bool = false;\n\nconst MAX_HEIGHT: i64 = 52;\n\nconst NAME: &str = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "o0UpOqzg3",
          "title": "Functions",
          "instructions": "So far we've seen several functions, so you should have the basics down by now. But there is one important function we have not seen yet: the `main` function\\. Since we are working within the Pairwise workspace, some of the details of how to setup, compile, and run Rust code are hidden away \\(for now...\\).\n\nIn Rust, the entry point to a program is a `main` function\\. This is where everything starts, and it must be defined.\n\nIn the editor below, define a `main` function which returns the boolean `true`.\n\n> In the Pairwise workspace, we are taking your code from the editor below and wrapping it in the other code required to run a Rust program, e.g. the `main` function, and the test code for each challenge. This is all being compiled and run with the output captured to determine if you passed or failed the tests.\n> \n> The purpose of this is to get you off the ground quickly writing Rust code without having to deal with setup tasks like downloading the Rust compiler and learning how to use it \\(although, this is not that hard\\).\n> \n> But don't worry\\! We will cover these topics later in this course and by the end you will be compiling your own Rust code like a pro.\n\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = main();\n\n  return result;\n}\n`;\n\ntest(\"The `main` function should be defined and should return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "// Write your code here\nfn  main() -> bool {\n  true\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "eTZNP3td8",
          "title": "Returning Values from Functions",
          "instructions": "There are two ways to return values from functions, using the explicit `return` keyword and also by just writing the final value as an expression with no semicolon. \"Early\" returns are often written using the `return` keyword while it is somewhat standard for a return at the end of the function to be written as a standalone expression.\n\nThe `different_ways_to_return` contains three expressions for different conditions. Modify the function to return these three expressions. Try to return the final expression without using the `return` keyword\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  assert_eq!(different_ways_to_return(-5), \"Value is less than zero\");\n  assert_eq!(different_ways_to_return(0), \"Value is zero\");\n  assert_eq!(different_ways_to_return(5), \"Value is greater than zero\");\n\n  true\n}\n`;\n\ntest(\"The `different_ways_to_return` function should compile and return different string slices based on the input value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Don't worry about this 'static on the return parameter yet.\n// This is a lifetime parameter, which instructs the Rust compiler\n// how long the return value can live.\nfn different_ways_to_return(val: i32) -> &'static str {\n  // We will see more on if/else statements soon\n  if val == 0 {\n    \"Value is zero\";\n  }\n\n  if val < 0 {\n    \"Value is less than zero\";\n  }\n\n  // Final expression is returned from the function,\n  // without the need for a return keyword\n  \"Value is greater than zero\";\n}\n\nprintln!(\"Checking -5: {:?}\", different_ways_to_return(-5));\nprintln!(\"Checking 0: {:?}\", different_ways_to_return(0));\nprintln!(\"Checking +5: {:?}\", different_ways_to_return(5));",
          "solutionCode": "// Don't worry about this 'static on the return parameter yet.\n// This is a lifetime parameter, which instructs the Rust compiler\n// how long the return value can live.\nfn different_ways_to_return(val: i32) -> &'static str {\n  // We will see more on if/else statements soon\n  if val == 0 {\n    return \"Value is zero\";\n  }\n\n  if val < 0 {\n    return \"Value is less than zero\";\n  }\n\n  // Final expression is returned from the function,\n  // without the need for a return keyword\n  \"Value is greater than zero\"\n}\n\nprintln!(\"Checking -5: {:?}\", different_ways_to_return(-5));\nprintln!(\"Checking 0: {:?}\", different_ways_to_return(0));\nprintln!(\"Checking +5: {:?}\", different_ways_to_return(5));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "jLTXZFPZt",
          "title": "Multiply Floats",
          "instructions": "Write a function from scratch to take two `f64` numbers and multiply them together and return the result.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  fn _mult(x: f64, y: f64) -> f64 {\n    x * y\n  }\n\n  let a = 5.231231;\n  let b = 7.912381;\n\n  let result = multiply(a, b);\n  let expected = _mult(a, b);\n  assert_eq!(result, expected);\n\n  true\n}\n`;\n\ntest(\"The `multiply` function should exist and return the result of multiplying its two arguments together.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Your code here",
          "solutionCode": "// Multiple function\nfn multiply(x: f64, y: f64) -> f64 {\n  x * y\n}",
          "content": ""
        },
        {
          "type": "section",
          "id": "owXHK17s4",
          "title": "Control Flow",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust contains many of the common control flow structures you will be familiar with from other programming languages. We will cover those in this section, along with a few other patterns which are unique and common to Rust, such as:\n\n* If/else statements\n* Iterators and loops\n* Match statements\n\n"
        },
        {
          "type": "rust",
          "id": "@i3sE3J3Q",
          "title": "Creating Conditional If Statements",
          "instructions": "Rust supports if/else statements which work in the expected way. Complete the `conditionals` function so all of the assertions are valid.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = conditionals(-5);\n  assert_eq!(result, String::from(\"The value is negative.\"));\n\n  let result = conditionals(0);\n  assert_eq!(result, String::from(\"The value is zero.\"));\n\n  let result = conditionals(52);\n  assert_eq!(result, String::from(\"The value is positive.\"));\n\n  true\n}\n`;\n\ntest(\"The `conditionals` function should return the `String` values specified in the `assert_eq!` assertions depending on whether the input is positive, negative, or zero.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Implement the body of this function using if/else expressions\nfn conditionals(value: i64) -> String {\n  // Write your code here\n}\n\nlet result = conditionals(-5);\nassert_eq!(result, String::from(\"The value is negative.\"));\n\nlet result = conditionals(0);\nassert_eq!(result, String::from(\"The value is zero.\"));\n\nlet result = conditionals(52);\nassert_eq!(result, String::from(\"The value is positive.\"));",
          "solutionCode": "// Implement the body of this function using if/else expressions\nfn conditionals(value: i64) -> String {\n  if value < 0 {\n    String::from(\"The value is negative.\")\n  } else if value == 0 {\n    String::from(\"The value is zero.\")\n  } else {\n    String::from(\"The value is positive.\")\n  }\n}\n\nlet result = conditionals(-5);\nassert_eq!(result, String::from(\"The value is negative.\"));\n\nlet result = conditionals(0);\nassert_eq!(result, String::from(\"The value is zero.\"));\n\nlet result = conditionals(52);\nassert_eq!(result, String::from(\"The value is positive.\"));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "lqTN5PoAV",
          "title": "Conditional Expressions Require Booleans",
          "instructions": "Unlike in some other languages, conditional expressions in Rust _must_ evaluate to a boolean value. There is no implicit coercion. Consider this point and then correct the code in the editor.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `conditions_require_booleans` function should compile.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn conditions_require_booleans() {\n  let value: u32 = 500;\n\n  if value {\n    println!(\"Value exists: {}\", value);\n  }\n\n  let name: &str = \"Joseph\";\n\n  if name {\n    println!(\"Name exists: {}\", name);\n  }\n}\n\nconditions_require_booleans();",
          "solutionCode": "fn conditions_require_booleans() {\n  let value: u32 = 500;\n\n  if value == 500 {\n    println!(\"Value exists: {}\", value);\n  }\n\n  let name: &str = \"Joseph\";\n\n  if name == \"Joseph\" {\n    println!(\"Name exists: {}\", name);\n  }\n}\n\nconditions_require_booleans();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "QHQPQktNv",
          "title": "Assigning Values with a Conditional Expression",
          "instructions": "Rust also supports using an `if` expression to define a variable directly. This is similar to a ternary expression in other languages \\(something that Rust does not support\\). The code in the editor is a little mixed up though. See if you can correct it.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = is_a_greater_than_b(5, 10);\n  assert_eq!(result, false);\n\n  let result = is_a_greater_than_b(50, 10);\n  assert_eq!(result, true);\n  true\n}\n`;\n\ntest(\"The `is_a_greater_than_b` function should return `true` if the provided argument `a` is greater than `b`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn is_a_greater_than_b(a: i128, b: i128) -> bool {\n  let greater_than = if a > b { false } else { true };\n\n  greater_than\n}\n\nlet result = is_a_greater_than_b(5, 10);\nassert_eq!(result, false);\n\nlet result = is_a_greater_than_b(50, 10);\nassert_eq!(result, true);",
          "solutionCode": "fn is_a_greater_than_b(a: i128, b: i128) -> bool {\n  let greater_than = if a > b { true } else { false };\n\n  greater_than\n}\n\nlet result = is_a_greater_than_b(5, 10);\nassert_eq!(result, false);\n\nlet result = is_a_greater_than_b(50, 10);\nassert_eq!(result, true);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "vB5grXNR8",
          "title": "Loop Expressions",
          "instructions": "The `loop` keyword always you to repeat an action indefinitely. Fix the code below to `break` out of the loop after `x` is reassigned to the `target_value`.\n\n> NOTE: The code execution will be aborted after about 10 seconds if it does not finishing running.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let value = 283;\n  let result = loops_are_dangerous(value);\n  assert_eq!(result, value);\n\n  true\n}\n`;\n\ntest(\"The `loops_are_dangerous` function should `break` out of the loop after assigning `target_value` to `x`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn loops_are_dangerous(target_value: u32) -> u32 {\n  let mut x: u32 = 5;\n\n  // There is really no point to this code, except to demonstrate\n  // the loop construct.\n  loop {\n    x = target_value;\n  }\n\n  x\n}\n\nlet value = 500;\nlet result = loops_are_dangerous(value);\nassert_eq!(result, value);\nprintln!(\"Result = {}\", result);",
          "solutionCode": "fn loops_are_dangerous(target_value: u32) -> u32 {\n  let mut x: u32 = 5;\n\n  // There is really no point to this code, except to demonstrate\n  // the loop construct.\n  loop {\n    x = target_value;\n    break;\n  }\n\n  x\n}\n\nlet value = 500;\nlet result = loops_are_dangerous(value);\nassert_eq!(result, value);\nprintln!(\"Result = {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "UIQ8YPdV7",
          "title": "Using Loop Expressions to Assign Values",
          "instructions": "Loops can also be used to assign values, similar to `if/else` blocks\\. This may be useful if you need to an attempt an operation which may fail and needs to be retried. Take a look at the code in the editor, and then return a `String` from the `get_result` function to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result: String = get_result();\n\n  true\n}\n`;\n\ntest(\"The `get_result` function should return a `String` which should be assigned to the `result` variable in the loop expression.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_result() -> String {\n  // Write your code here\n}\n\nfn retry_logic() {\n  // A counter to limit retries\n  let mut attempts_remaining = 5;\n\n  let result: String = loop {\n    // Decrement remaining retry amounts\n    attempts_remaining = attempts_remaining - 1;\n\n    // This contrived code artificially just returns the result\n    // when the retry reaches zero, you can imagine in reality\n    // the operation would either succeed or fail after the retry\n    // limit is reached.\n    if attempts_remaining == 0 {\n      break get_result();\n    }\n  };\n\n  println!(\"The result is: {}\", result);\n}\n\nretry_logic();",
          "solutionCode": "fn get_result() -> String {\n  String::from(\"Imagine this is the data from some request which may fail at first.\")\n}\n\nfn retry_logic() {\n  // A counter to limit retries\n  let mut attempts_remaining = 5;\n\n  let result: String = loop {\n    // Decrement remaining retry amounts\n    attempts_remaining = attempts_remaining - 1;\n\n    // This contrived code artificially just returns the result\n    // when the retry reaches zero, you can imagine in reality\n    // the operation would either succeed or fail after the retry\n    // limit is reached.\n    if attempts_remaining == 0 {\n      break get_result();\n    }\n  };\n\n  println!(\"The result is: {}\", result);\n}\n\nretry_logic();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "UwDUOEzL5",
          "title": "While Loops",
          "instructions": "Rust also provides standard `while` loops to execute some operations while a condition is true. Complete the body of the `add_all_up_to_limit` function to use a `while` loop to calculate the total sum of all numbers from zero up to and including the given `limit`. For instance, the total sum for `3` would be `0 + 1 + 2 + 3 = 6`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = add_all_up_to_limit(4);\n  assert_eq!(result, 10);\n\n  let result = add_all_up_to_limit(17);\n  assert_eq!(result, 153);\n\n  let result = add_all_up_to_limit(48);\n  assert_eq!(result, 1176);\n\n  true\n}\n`;\n\ntest(\"The `add_all_up_to_limit` function should return the sum of all numbers from zero up to the provided `limit`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add_all_up_to_limit(limit: u128) -> u128 {\n  // Write your code here\n}\n\nlet result = add_all_up_to_limit(3);\nassert_eq!(result, 6);\nprintln!(\"add_all_up_to_limit(3)  = {}\", result);\n\nlet result = add_all_up_to_limit(15);\nassert_eq!(result, 120);\nprintln!(\"add_all_up_to_limit(15) = {}\", result);\n\nlet result = add_all_up_to_limit(53);\nassert_eq!(result, 1431);\nprintln!(\"add_all_up_to_limit(53) = {}\", result);",
          "solutionCode": "fn add_all_up_to_limit(limit: u128) -> u128 {\n  let mut total: u128 = 0;\n  let mut current: u128 = 0;\n\n  while current <= limit {\n    total = total + current;\n    current = current + 1;\n  }\n\n  total\n}\n\nlet result = add_all_up_to_limit(3);\nassert_eq!(result, 6);\nprintln!(\"add_all_up_to_limit(3)  = {}\", result);\n\nlet result = add_all_up_to_limit(15);\nassert_eq!(result, 120);\nprintln!(\"add_all_up_to_limit(15) = {}\", result);\n\nlet result = add_all_up_to_limit(53);\nassert_eq!(result, 1431);\nprintln!(\"add_all_up_to_limit(53) = {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ONCKyRCRf7",
          "title": "Iteration With For Loops",
          "instructions": "Although the `loop` and `while` expressions are available to use, it is generally preferable to use other iteration patterns which reduce the need for manually tracking the looping logic. It's always pleasant to avoid potential infinite loops.\n\nWith arrays and other collections we will see later, we can easily iterate through their members using a `for .. in` syntax\\. Finish the `iterate_names_array` function to use the `for .. in` syntax to iterate through the given `names_array`. You can turn an array into an iterator to use in the `for .. in` expression using the `iter()` method\\.\n\nUse a for loop to iterate through the given `names_array` and create a new array containing the reversed order of the names. You can use some indexing math to create this new array as your iterate through the for loop. Try to avoid using any built\\-in reverse methods.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut names: [&str; 5] = [\n    \"Sara\",\n    \"Ryan\",\n    \"Ben\",\n    \"Sam\",\n    \"Eddie\",\n  ];\n\n  // Get code result\n  let result = iterate_and_reverse_names_array(names);\n\n  // Reverse original list\n  names.reverse();\n  let names_reversed = names;\n\n  // Assert result\n  assert_eq!(result, names_reversed);\n\n  true\n}\n`;\n\ntest(\"The `iterate_and_reverse_names_array` function should return an array of names in the reverse order of the given `names_array`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "let names: [&str; 5] = [\n  \"Sam\",\n  \"Ryan\",\n  \"Joe\",\n  \"Sara\",\n  \"Ben\",\n];\n\nfn iterate_and_reverse_names_array(names_array: [&str; 5]) -> [&str; 5] {\n  // Implement your solution here\n  //\n  // NOTE: Try to use a for..in loop, do not use any built-in\n  // reverse methods ;)\n}\n\nlet result = iterate_and_reverse_names_array(names);\nprintln!(\"Original list of names: {:?}\", names);\nprintln!(\"Reversed list of names: {:?}\", result);\n",
          "solutionCode": "let names: [&str; 5] = [\n  \"Sam\",\n  \"Ryan\",\n  \"Joe\",\n  \"Sara\",\n  \"Ben\",\n];\n\nfn iterate_and_reverse_names_array(names_array: [&str; 5]) -> [&str; 5] {\n  let mut reversed_list: [&str; 5] = [\"\", \"\", \"\", \"\", \"\"];\n  let mut index: usize = 5;\n\n  for name in names_array.iter() {\n      println!(\"The current name is: {}\", name);\n      index = index - 1;\n      reversed_list[index] = name;\n  }\n\n  return reversed_list;\n}\n\nlet result = iterate_and_reverse_names_array(names);\nprintln!(\"Original list of names: {:?}\", names);\nprintln!(\"Reversed list of names: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "@orxFOEdD",
          "title": "Structs and Enums",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust structures \"structs\" are a way to group several related values into a single meaningful group."
        },
        {
          "type": "rust",
          "id": "rONYoxCYV",
          "title": "Struct Definition",
          "instructions": "Struct are defined using the `struct` keyword\\. Like tuples, they can contain data of different types. Unlike tuples they have a much more defined structure which conveys more meaning and makes data access easier.\n\nWe've defined a struct in the editor below representing a rectangle. In the `create_rectangle` function, return a new instance of this struct whose fields match the parameters given to the function. You can create a new instance of a struct by writing its name followed by `{...}` brackets within which you defined the struct fields.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let x: u32 = 5;\n  let y: u32 = 10;\n  let width: u32 = 25;\n  let height: u32 = 50;\n  let rect = create_rectangle(x, y, width, height);\n  assert_eq!(rect.x, x);\n  assert_eq!(rect.y, y);\n  assert_eq!(rect.width, width);\n  assert_eq!(rect.height, height);\n\n  true\n}\n`;\n\ntest(\"The `create_rectangle` function should return a new `Rect` struct matching the parameters given to it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn create_rectangle(x: u32, y: u32, width: u32, height: u32) -> Rect {\n  // Write your code here\n}\n\nlet rect = create_rectangle(5, 10, 25, 50);\nprintln!(\"Rectangle Struct: {:?}\", rect);",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn create_rectangle(x: u32, y: u32, width: u32, height: u32) -> Rect {\n  // Write your code here\n  Rect {\n    x,\n    y,\n    width,\n    height\n  }\n}\n\nlet rect = create_rectangle(5, 10, 25, 50);\nprintln!(\"Rectangle Struct: {:?}\", rect);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "rONYaskiU",
          "title": "Create a New Struct",
          "instructions": "Let's get some more practice defining structs. This challenge is similar to the last but here we will start with an empty editor\\! Review the test cases to solve the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let radius: u32 = 51231;\n  let mass: u32 = 9701731;\n  let inhabitants: u32 = 712231;\n  let planet = create_planet(radius, mass, inhabitants);\n  assert_eq!(planet.radius, radius);\n  assert_eq!(planet.mass, mass);\n  assert_eq!(planet.inhabitants, inhabitants);\n\n  true\n}\n`;\n\ntest(\"A `create_planet` function should exist and return a new `Planet` struct, which has the following `u32` fields: `radius`, `mass`, `inhabitants`. The function signature should accept these three fields, in that order, as parameters to initalize the `Planet` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "#[derive(Debug)]\nstruct Planet {\n  radius: u32,\n  mass: u32,\n  inhabitants: u32,\n}\n\nfn create_planet(radius: u32, mass: u32, inhabitants: u32) -> Planet {\n  // Fields can be initialized directly like this if a variable of\n  // matching type exists in the same scope:\n  let planet = Planet {\n    radius,\n    mass,\n    inhabitants,\n  };\n\n  planet\n}\n\nlet planet = create_planet(791231, 13211231, 1231311);\nprintln!(\"Planet Struct: {:?}\", planet);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "PvQraNq37",
          "title": "Reading Struct Fields",
          "instructions": "Accessing a field on a struct can be done using the dot syntax, e.g.` user.first_name`. Complete the `get_rectangle_area` function to return the area of the given rectangle.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let rect = Rect {\n    x: 5,\n    y: 5,\n    width: 102,\n    height: 908,\n  };\n  let result = get_rectangle_area(rect);\n  assert_eq!(result, 102 * 908);\n\n  true\n}\n`;\n\ntest(\"The `get_rectangle_area` function should return the `u32` area of the rectangle given to it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn get_rectangle_area(rect: Rect) -> u32 { \n  // Write your code here:\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nlet area = get_rectangle_area(rect);\nprintln!(\"Rectangle Area: {:?}\", area);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn get_rectangle_area(rect: Rect) -> u32 { \n  rect.width * rect.height\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nlet area = get_rectangle_area(rect);\nprintln!(\"Rectangle Area: {:?}\", area);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "jQdiNPjQJK",
          "title": "Updating Struct Fields",
          "instructions": "How can we update the fields of a struct? Well, you can set them similar to how you would set a variable. Try to complete the function in the editor below.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n  // Returns a boolean representing challenge test status.\n  fn test() -> bool {\n    let rect = Rect {\n    x: 5,\n    y: 5,\n    width: 100,\n    height: 50,\n  };\n\n  let resized = resize_rectangle(rect, 500, 500);\n  assert_eq!(resized.width, 500);\n  assert_eq!(resized.height, 500);\n\n  true\n}\n`;\n\ntest(\"The `original_rect` function should return a struct matching the `original_rect` struct it receives as an argument but with update `width` and `height` properities.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn resize_rectangle(original_rect: Rect, new_width: u32, new_height: u32) -> Rect { \n  // Write your code here:\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nprintln!(\"[1] Original Rectangle: {:?}\", rect);\nlet resized = resize_rectangle(rect, 500, 500);\nprintln!(\"[2] Resized Rectangle: {:?}\", resized);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\n// First, we must make the original_rect argument mutable,\n// in order to change it. We could also, alternatively, create\n// a new rectangle in the function body and return that instead.\nfn resize_rectangle(mut original_rect: Rect, new_width: u32, new_height: u32) -> Rect { \n  // We can access and update the fields directly like this:\n  original_rect.width = new_width;\n  original_rect.height = new_height;\n  original_rect\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nprintln!(\"[1] Original Rectangle: {:?}\", rect);\nlet resized = resize_rectangle(rect, 500, 500);\nprintln!(\"[2] Resized Rectangle: {:?}\", resized);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "OsWEvgL6e",
          "title": "Struct Update Syntax",
          "instructions": "There is a special syntax for copying existing struct fields onto a new struct, which is useful when creating or updating structs. This syntax is the `..` struct update syntax and it will \"spread\" all the struct fields of one struct onto another. Consider this code:\n\n```\n// Create an item, using all the fields from an\n// existing 'other_item' and set a new id field.\nlet item = Item {\n    // Set the id field\n    id: get_random_id(),\n    // Include whatever other fields are in the\n    // other_item (imagine it is defined above)\n    // which are NOT already set above.\n    //\n    // Note that this syntax uses two dots and no\n    // comma at the end.\n    ..other_item\n}\n\n```\n\nIn the editor below, use the `..` struct update syntax to complete the `create_additional_tree_in_forest` function\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let forest = String::from(\"Pinegrove\");\n  let caretaker = String::from(\"Eddie\");\n  let tree_type = TreeTypes::Cedar;\n  let tree = Tree {\n    tree_type,\n    forest: String::from(&forest),\n    caretaker: String::from(&caretaker),\n    height: 52,\n    number_of_branches: 217,\n    number_of_bird_nests: 8,\n  };\n\n  let result = create_additional_tree_in_forest(tree, 88, 312, 14);\n  assert_eq!(result.forest, forest);\n  assert_eq!(result.caretaker, caretaker);\n  assert_eq!(result.height, 88);\n  assert_eq!(result.number_of_branches, 312);\n  assert_eq!(result.number_of_bird_nests, 14);\n\n  true\n}\n`;\n\ntest(\"The `create_additional_tree_in_forest` function should return a `Tree` struct matching the struct given to it with the additional fields provided as parameters.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum TreeTypes {\n  Sycamore,\n  Cedar,\n  Oak,\n  Redwood,\n  Pine,\n}\n\n#[derive(Debug)]\nstruct Tree {\n  tree_type: TreeTypes,\n  forest: String,\n  caretaker: String,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n}\n\nfn create_additional_tree_in_forest(\n  tree: Tree,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n  ) -> Tree {\n    // Write your code here\n};\n\nlet tree = Tree {\n  tree_type: TreeTypes::Cedar,\n  forest: String::from(\"Pinegrove\"),\n  caretaker: String::from(\"Eddie\"),\n  height: 52,\n  number_of_branches: 217,\n  number_of_bird_nests: 6,\n};\n\nprintln!(\"Original Tree: {:?}\", tree);\nlet result = create_additional_tree_in_forest(tree, 88, 312, 14);\nprintln!(\"New Tree: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nenum TreeTypes {\n  Sycamore,\n  Cedar,\n  Oak,\n  Redwood,\n  Pine,\n}\n\n#[derive(Debug)]\nstruct Tree {\n  tree_type: TreeTypes,\n  forest: String,\n  caretaker: String,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n}\n\nfn create_additional_tree_in_forest(\n  tree: Tree,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n  ) -> Tree {\n    Tree {\n      height,\n      number_of_branches,\n      number_of_bird_nests,\n      ..tree\n    }\n}\n\nlet tree = Tree {\n  tree_type: TreeTypes::Cedar,\n  forest: String::from(\"Pinegrove\"),\n  caretaker: String::from(\"Eddie\"),\n  height: 52,\n  number_of_branches: 217,\n  number_of_bird_nests: 6,\n};\n\nprintln!(\"Original Tree: {:?}\", tree);\nlet result = create_additional_tree_in_forest(tree, 88, 312, 14);\nprintln!(\"New Tree: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "l0YwrWngu",
          "title": "Tuple Structs",
          "instructions": "Structs can also be defined as tuples. Tuple structs are regular tuples, but have a distinct type and name and also lack the additional field names of a regular struct. They are appropriate for certain use cases. Take a look at the code in the editor and complete the `are_players_on_same_space` to solve the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut a = Coordinate(5, 2);\n  let mut b = Coordinate(5, 2);\n  let mut same_space = are_players_on_same_space(a, b);\n  assert_eq!(same_space, true);\n\n  a = Coordinate(5, 2);\n  b = Coordinate(5, 1);\n  same_space = are_players_on_same_space(a, b);\n  assert_eq!(same_space, false);\n\n  true\n}\n`;\n\ntest(\"The `are_players_on_same_space` function should return `true` if the two given coordiantes represent the same space.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// (x, y) coordinate representing position on a board\nstruct Coordinate(i32, i32);\n\nfn are_players_on_same_space(a_coordinate: Coordinate, b_coordinate: Coordinate) -> bool {\n  // Your code here\n}\n\nlet mut a = Coordinate(5, 2);\nlet mut b = Coordinate(5, 2);\n\nlet mut same_space = are_players_on_same_space(a, b);\nprintln!(\"[1] Same Space: {}\", same_space);\n\na = Coordinate(5, 2);\nb = Coordinate(5, 1);\n\nsame_space = are_players_on_same_space(a, b);\nprintln!(\"[2] Same Space: {}\", same_space);",
          "solutionCode": "// (x, y) coordinate representing position on a board\nstruct Coordinate(i32, i32);\n\nfn are_players_on_same_space(a_coordinate: Coordinate, b_coordinate: Coordinate) -> bool {\n  let same_x = a_coordinate.0 == b_coordinate.0;\n  let same_y = a_coordinate.1 == b_coordinate.1;\n\n  same_x && same_y\n}\n\nlet mut a = Coordinate(5, 2);\nlet mut b = Coordinate(5, 2);\n\nlet mut same_space = are_players_on_same_space(a, b);\nprintln!(\"[1] Same Space: {}\", same_space);\n\na = Coordinate(5, 2);\nb = Coordinate(5, 1);\n\nsame_space = are_players_on_same_space(a, b);\nprintln!(\"[2] Same Space: {}\", same_space);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Unlagm$ty",
          "title": "Implementing Struct Methods I",
          "instructions": "We have seen how to define struct fields which contain data. Now we will look at how we can implement methods on structs to associate specific behavior or functionality with a struct. Struct methods are defined in implementation blocks signified by the `impl` keyword and in their series of arguments always receive the current instance of the struct as a `self` argument\\.\n\nThe `Person` struct in the editor below has an empty `say_hello` implementation started. Complete this to return a `String` of the given person saying hello.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let name = String::from(\"Frank\");\n  let age = 25;\n\n  let sam = Person {\n    name,\n    age,\n  };\n\n  let result = sam.say_hello();\n  let expected = String::from(\"Hello, my name is Frank!\");\n  assert_eq!(result, expected);\n\n  let name = String::from(\"Vivian\");\n  let age = 25;\n\n  let vivian = Person {\n    name,\n    age,\n  };\n\n  let result = vivian.say_hello();\n  let expected = String::from(\"Hello, my name is Vivian!\");\n  assert_eq!(result, expected);\n\n  true\n}\n`;\n\ntest(\"The `Person` struct `say_hello` implementation should return a `String` saying hello for the given person, like this: `Hello, my name is Eddie!`\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  // Return a string hello message of the pattern: Hello, my name is <name>!\n  // This method implementation takes as an argument a reference to\n  // the current instance of the struct, denoted by &self.\n  // We will see more on references in future challenges.\n  fn say_hello(&self) -> String {\n    // Implement this method, note you can use the format!\n    // macro just like println! to interpolate a variable into\n    // a string. The format! macro returns a String, just what\n    // we need to return here.\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nsam.say_hello();\n",
          "solutionCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn say_hello(&self) -> String {\n    format!(\"Hello, my name is {}!\", self.name)\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nlet x = sam.say_hello();\nprintln!(\"{}\", x);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Unlaaiu1P",
          "title": "Implementing Struct Methods II",
          "instructions": "We have our same `Person` from the last challenge in the editor below. This time, create a new `impl` block which implements a function `can_vote` which returns whether the given person is 18 or older.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let name = String::from(\"Frank\");\n  let age = 25;\n\n  let sam = Person {\n    name,\n    age,\n  };\n\n  let result = sam.can_vote();\n  assert_eq!(result, true);\n\n  let name = String::from(\"Vivian\");\n  let age = 12;\n\n  let vivian = Person {\n    name,\n    age,\n  };\n\n  let result = vivian.can_vote();\n  assert_eq!(result, false);\n\n  true\n}\n`;\n\ntest(\"The `Person` struct `say_hello` implementation should return a `String` saying hello for the given person, like this: `Hello, my name is Eddie!`\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\n// Your code here\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn can_vote(&self) -> bool {\n    self.age >= 18\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "fisyTm$ty",
          "title": "Struct Associated Functions",
          "instructions": "Struct `impl` blocks may also implement standalone functions which can be invoked with the `::` syntax\\. These are called associated functions are return an instance of the struct they are implement on. They _do not_ receive a reference to `self` as a parameter. A common example of this is the `String::from(\"...\")` method\\.\n\nA typical use of associated functions is to implement a `new` method for a struct. Take a look at the editor below. We've modified our code from the last two challenges to now set a field `can_vote` on our `Person` struct\\. We can now assign this field in a `new` associated function.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let name = String::from(\"Frank\");\n  let age = 25;\n  let sam = Person::new(name, age);\n  let can_vote = sam.can_vote();\n  assert_eq!(can_vote, true);\n\n  let name = String::from(\"Vivian\");\n  let age = 12;\n  let vivian = Person::new(name, age);\n  let can_vote = vivian.can_vote();\n  assert_eq!(can_vote, false);\n\n  true\n}\n`;\n\ntest(\"The `Person` struct `new` associated function should be implemented and return new `Person` instances with the `can_vote` property assigned correctly.`\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n  can_vote: bool,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n    // Define and return a new Person here, assigning\n    // the can_vote field based on if the given age\n    // is over 18 or not.\n  }\n\n  fn can_vote(&self) -> bool {\n    self.can_vote\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person::new(name, age);\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n  can_vote: bool,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n    let can_vote = age >= 18;\n    Person {\n      name,\n      age,\n      can_vote,\n    }\n  }\n\n  fn can_vote(&self) -> bool {\n    self.can_vote\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person::new(name, age);\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "efEpmQap5",
          "title": "Enums",
          "instructions": "Enums, or \"enumerations\",  are a way to represent a single type which may be one of many variants. Such a type can be useful in a variety of programming scenarios. Enums can be created using the `enum` keyword and specific variants can be referenced use the enum name followed by the `::` syntax\\. Take a look at the code below to see enums in action.\n\nIn the following section, we will see more on enums and Rust's powerful pattern matching techniques which can be used to perform operations on enums and other variants.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = get_default_user_registration_stage();\n  if let UserRegistrationStage::NotStarted = result {\n    return true;\n  } else {\n    panic!(\"Expected UserRegistrationStage to be NotStarted\");\n  }\n}\n`;\n\ntest(\"The `get_default_user_registration_stage` function should the `NotStarted` variant of the `UserRegistrationStage` enum.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// An enum to represent the current stage a user is in within\n// some registration process\n#[derive(Debug)]\nenum UserRegistrationStage {\n  NotStarted,\n  EnterNameAndEmail,\n  EnterPassword,\n  PendingConfirmation,\n  RegistrationSuccessful,\n}\n\nstruct User {\n  // Imagine various user struct fields here...\n  registration_stage: UserRegistrationStage,\n}\n\nfn get_default_user_registration_stage() -> UserRegistrationStage {\n  // Write your code here\n}\n\nlet result = get_default_user_registration_stage();\nprintln!(\"Current registration stage: {:?}\", result);",
          "solutionCode": "// An enum to represent the current stage a user is in within\n// some registration process\n#[derive(Debug)]\nenum UserRegistrationStage {\n  NotStarted,\n  EnterNameAndEmail,\n  EnterPassword,\n  PendingConfirmation,\n  RegistrationSuccessful,\n}\n\nstruct User {\n  // Imagine various user struct fields here...\n  registration_stage: UserRegistrationStage,\n}\n\nfn get_default_user_registration_stage() -> UserRegistrationStage {\n  UserRegistrationStage::NotStarted\n}\n\nlet result = get_default_user_registration_stage();\nprintln!(\"Current registration stage: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "HBWCQFb6b",
          "title": "Enums Can Contain Data",
          "instructions": "The variants of an enum may also contain data. In this way, enums can be a very flexible and powerful type to use in your programs.\n\nTake a look at the `Message` enum in the editor below, which might represent messages sent on a real\\-time chat application.\n\nNow, complete the `construct_message_for_reply_to_channel` function to return a new `Message` variant of the appropriate type. To create an enum variant which includes data, simply call the variant name like a function and pass the data in, like this: `FriendsGraph::FirstOrderConnections(list_of_friends)` \\(imagine what these types and structs might represent\\).",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let author_id = \"sa09df89aas98df7as\";\n  let channel_id = \"ads9f78sa0f7sa0\";\n  let result = construct_message_for_reply_to_channel(channel_id, author_id, \"Hello!\");\n\n  if let Message::ReplyToChannel(x) = result {\n    assert_eq!(String::from(author_id), x.author_id);\n    assert_eq!(String::from(channel_id), x.channel_id);\n    return true;\n  } else {\n    panic!(\"Expected construct_message_for_reply_to_channel to return a Message::ReplyToChannel variant\");\n  }\n}\n`;\n\ntest(\"The `construct_message_for_reply_to_channel` function should return the `Message::ReplyToChannel` correctly.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct ThreadMessage {\n  thread_id: String,\n  author_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nstruct ChannelMessage {\n  thread_id: String,\n  author_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nenum Message {\n  Connected,\n  Disconnected,\n  ReplyToThread(ThreadMessage),\n  ReplyToChannel(ChannelMessage),\n}\n\nfn construct_message_for_reply_to_channel(\n  thread_id: &str,\n  author_id: &str,\n  message_content: &str) -> Message {\n  // Create a new ChannelMessage struct here, given the arguments\n  // provided above and then return it in a Message ReplyToChannel\n  // variant.\n  //\n  // HINT: You can conver tthe &str arguments to String values using\n  // String::from().\n}\n\nlet result = construct_message_for_reply_to_channel(\"asd7f8as90\", \"a89s7fdsa\", \"Hello!\");\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nstruct ThreadMessage {\n  author_id: String,\n  thread_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nstruct ChannelMessage {\n  author_id: String,\n  channel_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nenum Message {\n  Connected,\n  Disconnected,\n  ReplyToThread(ThreadMessage),\n  ReplyToChannel(ChannelMessage),\n}\n\nfn construct_message_for_reply_to_channel(\n  channel_id: &str,\n  author_id: &str,\n  message_content: &str) -> Message {\n  let message = ChannelMessage {\n    author_id: String::from(author_id),\n    channel_id: String::from(channel_id),\n    message_content: String::from(message_content),\n  };\n\n  Message::ReplyToChannel(message)\n}\n\nlet result = construct_message_for_reply_to_channel(\"asd7f8as90\", \"a89s7fdsa\", \"Hello!\");\nprintln!(\"Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "514h0g6Hp",
          "title": "Enums Can Contain Any Data",
          "instructions": "Enum variants can contain any data, even other enums, or no data at all. Complete the code in the editor for an illustration. After this, we will start to see how we can match against different variants of enums and other types in Rust.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = create_enum();\n  let mut matched = false;\n  match result {\n    ManyDifferentVariants::BasicVariant => {\n      matched = true;\n    }\n    ManyDifferentVariants::AdvancedVariant => {\n      matched = true;\n    }\n    ManyDifferentVariants::Numbers(x, y, z) => {\n      matched = true;\n    }\n    ManyDifferentVariants::FlagEnabled(x) => {\n      matched = true;\n    }\n    ManyDifferentVariants::ID(x) => {\n      matched = true;\n    }\n    ManyDifferentVariants::Data(x) => {\n      matched = true;\n    }\n  }\n\n  return matched;\n}\n`;\n\ntest(\"The `create_enum` function should a properly defined `ManyDifferentVariants` enum.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This enum should include a variety of different\n// variants. Read the commented instructions and then\n// add the variants to proceed.\n#[derive(Debug)]\nenum ManyDifferentVariants {\n  // A 'BasicVariant' should exist like this:\n  BasicVariant,\n\n  // A 'AdvancedVariant' should exist:\n\n  // A 'Numbers' tuple should exist: (u32, u32, u32)\n\n  // A 'FlagEnabled' variant should exist and contain a boolean value:\n\n  // An 'ID' field should exist of a u128 type:\n\n  // A 'Data' field should exist and contain a Data struct\n  // (define the Data struct above however you like):\n}\n\nfn create_enum() -> ManyDifferentVariants {\n  // Instantiate a new ManyDifferentVariants enum here and return it\n}\n\nlet result = create_enum();\nprintln!(\"Result: {:?}\", result);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Data {\n  members: [u8; 5],\n}\n\n// This enum should include a variety of different\n// variants. Read the commented instructions and then\n// add the variants to proceed.\n#[derive(Debug)]\nenum ManyDifferentVariants {\n  // A 'BasicVariant' should exist like this:\n  BasicVariant,\n\n  // A 'AdvancedVariant' should exist:\n  AdvancedVariant,\n\n  // A 'Numbers' tuple should exist: (u32, u32, u32)\n  Numbers(u32, u32, u32),\n\n  // A 'FlagEnabled' variant should exist and contain a boolean value:\n  FlagEnabled(bool),\n\n  // An 'ID' field should exist of a u128 type:\n  ID(u128),\n\n  // A 'Data' field should exist and contain a Data struct\n  // (define the Data struct above however you like):\n  Data(Data)\n}\n\nfn create_enum() -> ManyDifferentVariants {\n  // Instantiate a new ManyDifferentVariants enum here and return it\n  let data = Data {\n    members: [1, 5, 8, 2, 7],\n  };\n\n  ManyDifferentVariants::Data(data)\n}\n\nlet result = create_enum();\nprintln!(\"Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "R4TolzmG5",
          "title": "Pattern Matching",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "One of Rust's most useful and common techniques is pattern matching, which allows you to match against different variants of a particular type and then perform different actions. We have just seen one built\\-in type which can exist as one of several variants, the `enum` type\\. Rust also provides the `Result` and `Option` types, which can represent values that may be in an error/failure state or a null/non\\-existent/value\\-less state, respectively.\n\nThe compiler's strictness ensures that when you have a type which can be one of multiple variants you must handle all the possible variants. Pattern matching is one powerful way for you to do this.\n\nThese types and pattern matching against them are an indispensable part of your toolbox as a Rust programmer and will be the focus of this section."
        },
        {
          "type": "rust",
          "id": "FmcnGuM3zu",
          "title": "Pattern Matching an Enum",
          "instructions": "How can we match against different enum variants? The `match` syntax allows us to do this. We've defined an enum called `FailureStates` in the editor below and a function `map_failure_state_to_message`. Ensure that this function returns a new `String` for each failure variant.\n\nAlso notice how the Rust compiler is very helpful in explaining that the current code does not exhaustively check for different variants in the match expression. The compiler guarantees you must handle each case\\!",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut result: String = map_failure_state_to_message(FailureState::Unauthorized);\n  result = map_failure_state_to_message(FailureState::ResourceNotFound);\n  result = map_failure_state_to_message(FailureState::ResourceDeleted);\n  result = map_failure_state_to_message(FailureState::InternalError);\n\n  true\n}\n`;\n\ntest(\"The `map_failure_state_to_message` function should handle all `FailureState` variants and return a `String` message for each.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\nfn map_failure_state_to_message(failure_state: FailureState) -> String {\n  // The match expression allows us to match against several\n  // possible variants of a particular value\n  match failure_state {\n    FailureState::Unauthorized => {\n      // A 'return' express here will return the given value from the\n      // function that this match block is in\n      String::from(\"You are unauthorized to access this resource!\")\n    }\n    // Your code here\n  }\n}\n\nlet mut result = map_failure_state_to_message(FailureState::Unauthorized);\nprintln!(\"[1] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceNotFound);\nprintln!(\"[2] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceDeleted);\nprintln!(\"[3] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::InternalError);\nprintln!(\"[4] Result: {:?}\", result);\n",
          "solutionCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\nfn map_failure_state_to_message(failure_state: FailureState) -> String {\n  match failure_state {\n    FailureState::Unauthorized => {\n      String::from(\"You are unauthorized to access this resource!\")\n    }\n    FailureState::ResourceNotFound => {\n      String::from(\"Resource could not be found.\")\n    }\n    FailureState::ResourceDeleted => {\n      String::from(\"Resource was deleted.\")\n    }\n    FailureState::InternalError => {\n      String::from(\"Sorry, an internal error occurred.\")\n    }\n  }\n}\n\nlet mut result = map_failure_state_to_message(FailureState::Unauthorized);\nprintln!(\"[1] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceNotFound);\nprintln!(\"[2] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceDeleted);\nprintln!(\"[3] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::InternalError);\nprintln!(\"[4] Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "pn@ANcAKj",
          "title": "Matching Using the if let Syntax",
          "instructions": "There is another syntax which is useful for matching a single variant in isolation, the `if let` syntax\\. This is useful for performing equality checks against an enum value, for instance. Consider the following code:\n\n```\nenum Letters {\n    X,\n    Y,\n    Z,\n}\n\nlet value = Letters::X;\n\nif Letters::X = value {\n    // This code block will run\n}\n\n```\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = is_unauthorized_error(FailureState::Unauthorized);\n  assert_eq!(result, true);\n\n  let result = is_unauthorized_error(FailureState::ResourceNotFound);\n  assert_eq!(result, false);\n\n  let result = is_unauthorized_error(FailureState::ResourceDeleted);\n  assert_eq!(result, false);\n\n  let result = is_unauthorized_error(FailureState::InternalError);\n  assert_eq!(result, false);\n\n  true\n}\n`;\n\ntest(\"The `is_unauthorized_error` function should return `true` when given the `Unauthorized` variant of the `FailureState` enum, and `false` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\n// In this function, we only care about one of the enum\n// variants. For this use case, it makes sense to use an\n// 'if let' expression.\nfn is_unauthorized_error(failure_state: FailureState) -> bool {\n  // Write your code here\n}\n\nlet is_unauthorized = is_unauthorized_error(FailureState::Unauthorized);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n\nlet is_unauthorized = is_unauthorized_error(FailureState::ResourceNotFound);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n",
          "solutionCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\n// In this function, we only care about one of the enum\n// variants. For this use case, it makes sense to use an\n// 'if let' expression.\nfn is_unauthorized_error(failure_state: FailureState) -> bool {\n  if let FailureState::Unauthorized = failure_state {\n    return true;\n  }\n\n  return false;\n}\n\nlet is_unauthorized = is_unauthorized_error(FailureState::Unauthorized);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n\nlet is_unauthorized = is_unauthorized_error(FailureState::ResourceNotFound);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "SlRfSz95Mt",
          "title": "Matching Enum Variants",
          "instructions": "Let's get some more practice matching enum variants. This is a very common pattern when writing Rust so it will be good to practice it thoroughly. In the editor below is an enum `Planet`. Write a new function `distance_from_sun` which takes a `Planet` as an argument and returns a `u128` value for the distance of each planet from the sun. Use a match statement to handle each `Planet` variant\\.\n\nOf course, the distances do not have to be accurate\\! The point here is to practice matching enums—feel free to make up any distances you like.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result: u128 = distance_from_sun(Planet::Mercury);\n  let result: u128 = distance_from_sun(Planet::Venus);\n  let result: u128 = distance_from_sun(Planet::Earth);\n  let result: u128 = distance_from_sun(Planet::Mars);\n  let result: u128 = distance_from_sun(Planet::Jupiter);\n  let result: u128 = distance_from_sun(Planet::Saturn);\n  let result: u128 = distance_from_sun(Planet::Uranus);\n  let result: u128 = distance_from_sun(Planet::Neptune);\n  let result: u128 = distance_from_sun(Planet::Pluto);\n\n  true\n}\n`;\n\ntest(\"The `distance_from_sun` function should return a `u128` representing the distance of each planet from the sun.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "enum Planet {\n  Mercury,\n  Venus,\n  Earth,\n  Mars,\n  Jupiter,\n  Saturn,\n  Uranus,\n  Neptune,\n  Pluto,\n}\n\n// Write your code here",
          "solutionCode": "enum Planet {\n  Mercury,\n  Venus,\n  Earth,\n  Mars,\n  Jupiter,\n  Saturn,\n  Uranus,\n  Neptune,\n  Pluto,\n}\n\nfn distance_from_sun(planet: Planet) -> u128 {\n  match planet {\n    Planet::Mercury => 52,\n    Planet::Venus => 123,\n    Planet::Earth => 321,\n    Planet::Mars => 521,\n    Planet::Jupiter => 3123,\n    Planet::Saturn => 7281,\n    Planet::Uranus => 98123,\n    Planet::Neptune => 321314,\n    Planet::Pluto => 1263891,\n  }\n}\n\nlet earth_distance = distance_from_sun(Planet::Earth);\nprintln!(\"Earth's Distance: {}\", earth_distance);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ZTWdmKRlHe",
          "title": "Default Matching with the _ Placeholder",
          "instructions": "Sometimes you may find yourself matching against some enum with many variants, and you are only concerned with a few specific cases. Rust allows you to match any fall through cases with the `_` placeholder\\. Consider the code below and try to use the `_` placeholder to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = is_vowel('a');\n  assert_eq!(result, true);\n\n  let result = is_vowel('e');\n  assert_eq!(result, true);\n\n  let result = is_vowel('m');\n  assert_eq!(result, false);\n\n  let result = is_vowel('x');\n  assert_eq!(result, false);\n\n  true\n}\n`;\n\ntest(\"The `is_vowel` function should `true` for vowel characters and `false` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn is_vowel(character: char) -> bool {\n  match character {\n    'a' => true,\n    'e' => true,\n    'i' => true,\n    'o' => true,\n    'u' => true,\n  }\n}\n\nlet result = is_vowel('a');\nassert_eq!(result, true);\n\nlet result = is_vowel('e');\nassert_eq!(result, true);\n\nlet result = is_vowel('m');\nassert_eq!(result, false);\n\nlet result = is_vowel('x');\nassert_eq!(result, false);",
          "solutionCode": "fn is_vowel(character: char) -> bool {\n  match character {\n    'a' => true,\n    'e' => true,\n    'i' => true,\n    'o' => true,\n    'u' => true,\n    _ => false,\n  }\n}\n\nlet result = is_vowel('a');\nprintln!(\"Is 'a' a vowel: {}\", result);\nassert_eq!(result, true);\n\nlet result = is_vowel('e');\nprintln!(\"Is 'e' a vowel: {}\", result);\nassert_eq!(result, true);\n\nlet result = is_vowel('m');\nprintln!(\"Is 'm' a vowel: {}\", result);\nassert_eq!(result, false);\n\nlet result = is_vowel('x');\nprintln!(\"Is 'x' a vowel: {}\", result);\nassert_eq!(result, false);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "@4dmTg5UA",
          "title": "The Option Type",
          "instructions": "One of the scourges of many programmers is the so\\-called \"null pointer exception\" or generally the type of error where at runtime your program tries to access some value which it expects to exist only to find that value is null, undefined, or in some way missing.\n\nThis would not be so common if it were not possible in a variety of scenarios for such values to indeed be \"not present\". However, the devastation caused by such errors in the runtime of programs doesn't need to be the case.\n\nWith Rust, values cannot be \"null\" or \"undefined\". However, Rust does provide a way capture this potentiality using the `Option` enum\\. Yes, it's just a regular enum like we have seen, albeit a generic one:\n\n```\n// Rust's Option:\nenum Option<T> {\n    None,\n    Some(T),\n}\n\n```\n\nAn `Option` can either by \"Some\" \\(a value is present\\) or \"None\" \\(a nothing/empty/value\\-less state\\). This is the closest thing you will find in Rust to represent what is familiar as \"null\" in many other programming languages.\n\nBecause this is fundamentally an enum, we can work with it just like the other enums we have seen in the last few challenges.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = maybe_find_user_by_id(\"sa0df87sas\");\n  if let Some(x) = result {\n    panic!(\"No Some should be returned here!\");\n  }\n\n  let result = maybe_find_user_by_id(USER_ID);\n  if let Some(x) = result {\n    assert_eq!(x.id, USER_ID);\n  } else {\n    panic!(\"No None should be returned here!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `maybe_find_user_by_id` function should return a new `User` if the given `id` matches the `USER_ID`, and `None` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const USER_ID: &str = \"as897df0sa7f0dsa7df0as987df90sa\";\n\n#[derive(Debug)]\nstruct User {\n  id: &'static str,\n  name: &'static str,\n}\n\n// Imagine this is some API or database call where we may\n// find a user or not... the 'not' possibility can be represented\n// with the None variant of Rust's Option. In this case, just\n// return a new User struct when given an id matching the\n// hard-coded USER_ID above.\nfn maybe_find_user_by_id(id: &'static str) -> Option<User> {\n  // Write your code here\n}\n\n// Lookup user by random ID\nlet result = maybe_find_user_by_id(\"sa0df87sas\");\nprintln!(\"Did we find anything? -> {:?}\", result);\n\n// Lookup user by static ID\nlet result = maybe_find_user_by_id(USER_ID);\nprintln!(\"Did we find anything? -> {:?}\", result);\n\nif let Some(user) = result {\n  // Assert ids match\n  assert_eq!(user.id, USER_ID);\n}",
          "solutionCode": "const USER_ID: &str = \"as897df0sa7f0dsa7df0as987df90sa\";\n\n#[derive(Debug)]\nstruct User {\n  id: &'static str,\n  name: &'static str,\n}\n\n// Imagine this is some API or database call where we may\n// find a user or not... the 'not' possibility can be represented\n// with the None variant of Rust's Option. In this case, just\n// return a new User struct when given an id matching the\n// hard-coded USER_ID above.\nfn maybe_find_user_by_id(id: &'static str) -> Option<User> {\n  if id == USER_ID {\n    return Some(User {\n      id,\n      name: \"Samantha\",\n    })\n  }\n\n  None\n}\n\n// Lookup user by random ID\nlet result = maybe_find_user_by_id(\"sa0df87sas\");\nprintln!(\"Did we find anything? -> {:?}\", result);\n\n// Lookup user by static ID\nlet result = maybe_find_user_by_id(USER_ID);\nprintln!(\"Did we find anything? -> {:?}\", result);\n\nif let Some(user) = result {\n  // Assert ids match\n  assert_eq!(user.id, USER_ID);\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "A69i0d3FY",
          "title": "Working with Options",
          "instructions": "Let's get some more practice with the `Option` type\\. This type is pervasive in Rust code. Once you have a good feel for working with it, you will be quite happy to find that those insidious null pointer exceptions plague your code no more\\!\n\nIn the editor below is a `sum` function\\. Finish it to return the sum of all of the optional values provided to it.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = sum((\n    Some(321),\n    Some(192),\n    None,\n  ));\n  assert_eq!(result, 513);\n\n  let result = sum((\n    None,\n    None,\n    None,\n  ));\n  assert_eq!(result, 0);\n\n  let result = sum((\n    Some(2),\n    Some(2),\n    Some(2),\n  ));\n  assert_eq!(result, 6);\n\n  true\n}\n`;\n\ntest(\"The `sum` function should add up all of the values present in the `SomeValues` tuple. If any value is `None`, add zero.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A tuple of three options\ntype SomeValues = (\n  Option<u32>,\n  Option<u32>,\n  Option<u32>,\n);\n\nfn sum(values: SomeValues) -> u32 {\n  // Add up the values in the tuple\n  // If an option is None, add 0\n}\n\nlet values: SomeValues = (\n  Some(5),\n  Some(72),\n  None,\n);\n\nlet result = sum(values);\nprintln!(\"Result: {}\", result);",
          "solutionCode": "// A tuple of three options\ntype SomeValues = (\n  Option<u32>,\n  Option<u32>,\n  Option<u32>,\n);\n\nfn sum(values: SomeValues) -> u32 {\n  let mut result = 0;\n\n  if let Some(x) = values.0 {\n    result = result + x;\n  }\n\n  if let Some(x) = values.1 {\n    result = result + x;\n  }\n\n  if let Some(x) = values.2 {\n    result = result + x;\n  }\n\n  result\n}\n\nlet values: SomeValues = (\n  Some(5),\n  Some(72),\n  None,\n);\n\nlet result = sum(values);\nprintln!(\"Result: {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "W6slZ2r0Y",
          "title": "Matching Options",
          "instructions": "In addition to use an \"if let\" expression we can also match against option enums using a `match` expression\\.  This can be appealing because it ensures both variants of the option are handled. Take a look at the code in the editor. Looks good right? Try to run it and see what the compiler has to say about it. Fix the errors to continue.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = add_one_if_value_exists(Some(10));\n  if let Some(x) = result {\n    assert_eq!(x, 11);\n  } else {\n    panic!(\"Given Some, add_one_if_value_exists should not return None\");\n  }\n\n  let result = add_one_if_value_exists(None);\n  if let Some(_x) = result {\n    panic!(\"Given None, add_one_if_value_exists should return None\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `add_one_if_value_exists` function should return an `Option` with an incremented value, if the given Option is not `None`. Given `None`, it should return `None`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add_one_if_value_exists(opt: Option<u32>) -> Option<u32> {\n  match opt {\n    Some(x) => Some(x + 1)\n  }\n}\n\nlet result = add_one_if_value_exists(Some(10));\nprintln!(\"The result is: {:?}\", result);",
          "solutionCode": "fn add_one_if_value_exists(opt: Option<u32>) -> Option<u32> {\n  match opt {\n    Some(x) => Some(x + 1),\n    None => None\n  }\n}\n\nlet result = add_one_if_value_exists(Some(10));\nprintln!(\"The result is: {:?}\", result);",
          "content": ""
        },
        {
          "type": "section",
          "id": "@VZT4$txv",
          "title": "Strings",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In Rust strings are a more complex topic than in many other languages where you simply have the notion of a \"string\" type. In Rust there are multiple ways to represent strings which we need to spend some time explain."
        },
        {
          "type": "section",
          "id": "5B5@asRy6",
          "title": "Collections",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust provides a variety of primitive and advanced data structures to work with. We will explore the most common and useful of these in this module, such as:\n\n* Tuples\n* Arrays\n* Enums\n* Vectors\n* Structs\n* Hash Maps\n\n"
        },
        {
          "type": "rust",
          "id": "yh$liP$ml",
          "title": "Vectors",
          "instructions": "A vector is a collection of elements of dynamic size. It is stored on the heap and unlike arrays can grow or shrink during the life of a program. Vectors are ideal for storing lists of elements, especially ones whose size needs to change or whose size is not known at compile time.\n\nBecause vectors have an unknown length at compile time, you need to be a little more careful when working with them.\n\nConsider the code in the editor below which panics when run because of an \"index out of bounds\" error. Modify the code to check if the index `i` is in bounds of the vector and change the return type of the function to return an `Option<i32>`. Return `None` if the given index is out of bounds.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = maybe_get_item_at_index(vec![1,2,3,4,5], 2);\n  assert_eq!(result.unwrap(), 3);\n\n  let result = maybe_get_item_at_index(vec![1,2,3,4,5], 4);\n  assert_eq!(result.unwrap(), 5);\n\n  let result = maybe_get_item_at_index(vec![1,2,3,4,5], 20);\n  if let Some(_) = result {\n    panic!(\"maybe_get_item_at_index should return None when the index is out of bounds\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `maybe_get_item_at_index` function should return an `Option<i32>`, returning the element at index `i` or `None` if the index is out of bounds.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Change the return type and body of this function\n// to solve the challenge\nfn maybe_get_item_at_index(v: Vec<i32>, i: usize) -> i32 {\n  v[i]\n}\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 2);\nprintln!(\"Result: {:?}\", result);\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 20);\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// Change the return type and body of this function\n// to solve the challenge\nfn maybe_get_item_at_index(v: Vec<i32>, i: usize) -> Option<i32> {\n  if i < v.len() {\n    return Some(v[i]);\n  }\n\n  None\n}\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 2);\nprintln!(\"Result: {:?}\", result);\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 20);\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "AKUw7arOt",
          "title": "Initializing Vectors",
          "instructions": "Vectors can be initialized in a few different ways. Write a new function in the editor below called `create_new_vector`. This function should accept a `usize` parameter and an `i32` default value parameter. Return a new vector of that size with every position in the vector filled with the `default_value`.  Take a look a look at the [Vec documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html) if you need to.\n\n> Remember back to the challenges covering arrays, and recall that arrays have a fixed length. The vector is very useful because it has a dynamic size at runtime, as we see in this challenge.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let size: usize = 1000;\n  let vec = create_new_vector(size, 5);\n  assert_eq!(vec.len(), size);\n\n  let size: usize = 52;\n  let vec = create_new_vector(size, 51);\n  assert_eq!(vec.len(), size);\n\n  let size: usize = 999;\n  let vec = create_new_vector(size, 28);\n  assert_eq!(vec.len(), size);\n\n  true\n}\n`;\n\ntest(\"The `create_new_vector` function should exist and return a new vector of that size.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n\nlet vec = create_new_vector(500, 5);\nprintln!(\"Result: {:?}\", vec);\nassert_eq!(vec.len(), 500);\n",
          "solutionCode": "// Using the vec! macro\nfn create_new_vector(size: usize, default_value: i32) -> Vec<i32> {\n  vec![default_value; size]\n}\n\nlet vec = create_new_vector(250, 5);\nprintln!(\"[1] Result: {:?}\", vec);\nassert_eq!(vec.len(), 250);\n\n// Using logic to fill in the vector during runtime\nfn create_new_vector_alternate(size: usize, default_value: i32) -> Vec<i32> {\n  let mut v = Vec::new();\n  let mut current = 0;\n  while current < size {\n    v.push(default_value);\n    current = current + 1;\n  }\n  v\n}\n\nlet vec = create_new_vector_alternate(250, 7);\nprintln!(\"[2] Result: {:?}\", vec);\nassert_eq!(vec.len(), 250);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "SyJsNcFRxE",
          "title": "Swap Items in a Vector",
          "instructions": "Similar to \"list\" data structures in other programming languages, vectors support many operations you would expect. You can pop the last item, get the length of the vector, iterate through it, index into it, push new items on it, and so on.\n\nTo get more practice with vectors, implement a function `swap_at_indexes` which takes a `Vec<i32>` and two `usize`indexes\\. Then, return the vector with the values at those indexes swapped, or, if one of the indexes is out of bounds return the original vector without swapping anything.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 0, 32);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 19, 2);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 1, 2);\n  assert_eq!(list, vec![9, 7, 8, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 1, 1);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 6, 8);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 1, 2, 3]);\n\n  true\n}\n`;\n\ntest(\"The `swap_at_indexes` function should take a `Vec<i32>` and swap the values at the two indexes given to it, if the indexes are not out of bounds.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n\nlet list = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nprintln!(\"Original: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 50);\nassert_eq!(list, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\nprintln!(\"Result [1]: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 5);\nassert_eq!(list, vec![6, 2, 3, 4, 5, 1, 7, 8, 9, 10]);\nprintln!(\"Result [2]: {:?}\", list);\n",
          "solutionCode": "fn swap_at_indexes(mut v: Vec<i32>, a: usize, b: usize) -> Vec<i32> {\n  if a > v.len() || b > v.len() {\n    return v;\n  }\n\n  let a_value = v[a];\n  let b_value = v[b];\n\n  v[a] = b_value;\n  v[b] = a_value;\n\n  v\n}\n\nlet list = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nprintln!(\"Original: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 50);\nassert_eq!(list, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\nprintln!(\"Result [1]: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 5);\nassert_eq!(list, vec![6, 2, 3, 4, 5, 1, 7, 8, 9, 10]);\nprintln!(\"Result [2]: {:?}\", list);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "XNHkdURTA0",
          "title": "Iterating Vectors",
          "instructions": "Write a function `get_vector_sum` which takes a `Vec<i32>`, iterates through it and calculates the sum of all of items.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = get_vector_sum(vec![5, 5, 5, 5, 7]);\n  assert_eq!(result, 27);\n\n  let result = get_vector_sum(vec![5, 5, 5, 5, 7, 100]);\n  assert_eq!(result, 127);\n\n  let result = get_vector_sum(vec![5, 5, 5, 5, 7, 599]);\n  assert_eq!(result, 626);\n\n  true\n}\n`;\n\ntest(\"The `get_vector_sum` function should return the sum of all the items in the provided vector.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "fn get_vector_sum(v: Vec<i32>) -> i32 {\n  let mut sum = 0;\n\n  // The .iter() method is a common and handy way to iterate a collection\n  // like this.\n  for x in v.iter() {\n    sum = sum + x;\n  } \n\n  sum\n}\n\nlet result = get_vector_sum(vec![5, 5, 5, 5, 7]);\nassert_eq!(result, 27);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "4XpH9$RzGO",
          "title": "Get the Last Item in a Vector",
          "instructions": "Popping the final item from a vector is a common thing to do for list data structures. The Rust `Vec` implements a `pop` method just for this purpose. However, things may not be quite as straightforward as \"popping\" in other languages. Check out the code below and let the compiler guide you.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = get_last_item_in_vector(vec![5, 19, 20, 22]);\n  if let Some(x) = result {\n    assert_eq!(x, 22);\n  } else {\n    panic!(\"Expected to receive a value!\");\n  }\n\n  let result = get_last_item_in_vector(vec![5, 19, 20, 22, 99, 201, 822]);\n  if let Some(x) = result {\n    assert_eq!(x, 822);\n  } else {\n    panic!(\"Expected to receive a value!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `get_last_item_in_vector` function should return an appropriate value representing the final item in in a list.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// What's wrong here? Let the compiler help you.\nfn get_last_item_in_vector(v: Vec<i32>) -> i32 {\n  v.pop()\n}\n\nlet result = get_last_item_in_vector(vec![5, 19, 20, 22]);\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// What's wrong here? Let the compiler help you.\nfn get_last_item_in_vector(mut v: Vec<i32>) -> Option<i32> {\n  v.pop()\n}\n\nlet result = get_last_item_in_vector(vec![5, 19, 20, 22]);\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "section",
          "id": "PnCi8hB8E",
          "title": "Errors and Results",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "JAYJEcvrv",
          "title": "Testing",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "usDs33hMCZ",
          "title": "Modules, Packages and Crates",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "RZAimitGF",
          "title": "Cargo",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        }
      ]
    },
    {
      "id": "GDSzv2jA7",
      "title": "Basic Challenges",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "1@q9EgYpm",
          "title": "Basic Challenges",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "We have now covered many of the basics of the Rust language.\n\nNow, we will have a brief interlude of programming challenges and projects to practice what we've learned before diving into some more advanced topics.\n\nIt's important to get a lot of hands on practice when learning a new language—that's what this section is about.\n\nDon't worry if the challenges feel too easy or hard, just do you best and try to get as much practice writing and thinking in Rust as you can. See you on the other side\\!"
        },
        {
          "type": "rust",
          "id": "SfTt1nKS$",
          "title": "Array Sum",
          "instructions": "You are given an array of `f64` values\\. Write a function `array_sum` to return the sum of all the values in the array.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let input_array: InputArray = [\n    234.982,\n    432.772,\n    91.32,\n    42321231.2,\n    893.223,\n    576.243,\n    24.3,\n    2342.2,\n    422.1,\n    100.02,\n  ];\n\n  let result = array_sum(input_array);\n  assert_eq!(result, 42326348.36000001);\n\n  true\n}\n`;\n\ntest(\"The `array_sum` function should exist and return an `OutputSum` type given an `InputArray`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "type InputArray = [f64; 2];\ntype OutputSum = f64;\n\n// Write your code here:",
          "solutionCode": "type InputArray = [f64; 10];\ntype OutputSum = f64;\n\n// Write your code here:\nfn array_sum(input_array: InputArray) -> OutputSum {\n  let mut sum: f64 = 0 as f64;\n  for x in input_array.iter() {\n    sum = sum + x;\n  }\n  sum\n}\n\nlet input_array: InputArray = [\n  234.982,\n  432.772,\n  91.32,\n  4.2321231,\n  893.223,\n  576.243,\n  24.3,\n  2342.2,\n  422.1,\n  342.0,\n];\n\nlet result = array_sum(input_array);\nprintln!(\"Result: {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "aQ6M6ZmiF",
          "title": "Find in a Vector",
          "instructions": "You are given a vector of integers and a target value. Return an option indicating if the target exists in the vector, and if so, how many times it is present.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut vec = Vec::new();\n  for x in 0..1000 {\n    if x % 2 == 0 {\n      vec.push(50);\n    } else {\n      vec.push(x);\n    }\n  }\n\n  let result = find_in_vector(vec, 50);\n  assert_eq!(result.unwrap(), 500);\n\n  let result = find_in_vector(Vec::new(), 500);\n  if let Some(_x) = result {\n    panic!(\"Value should not be present in vector, expected None!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `find_in_vector` function should exist and return an `Option` representing the number of times the `target` value is found in the given vector, or `None` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write Your code here",
          "solutionCode": "fn find_in_vector(v: Vec<i64>, target: i64) -> Option<u32> {\n  let mut found_count: u32 = 0;\n\n  for x in v.iter() {\n    if *x == target {\n      found_count = found_count + 1;\n    }\n  }\n\n  if found_count == 0 {\n    None\n  } else {\n    Some(found_count)\n  }\n}\n\n// Create and populate a new vector\nlet mut vec = Vec::new();\nfor x in 0..1000 {\n  if x % 2 == 0 {\n    vec.push(50);\n  } else {\n    vec.push(x);\n  }\n}\n\nlet result = find_in_vector(vec, 50);\nprintln!(\"Result = {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "lb1erIfLNp",
          "title": "Rectangle Area",
          "instructions": "Create a struct `Rectangle` and implement `new` and `area` methods such that the following code is valid:\n\n```\nlet rect = Rectangle::new(5, 10);\nlet area = rect.area();\nassert_eq!(area, 50);\n\n```\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let rect = Rectangle::new(5, 10);\n  let area = rect.area();\n  assert_eq!(area, 50);\n\n  true\n}\n`;\n\ntest(\"The `Rectangle` struct should exist and implement `new` and `area` methods correctly.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "struct Rectangle {\n  width: u32,\n  height: u32,\n}\n\nimpl Rectangle {\n  fn new(width: u32, height: u32) -> Self {\n    Rectangle {\n      width,\n      height,\n    }\n  }\n\n  fn area(&self) -> u32 {\n    self.width * self.height\n  }\n}\n\nlet rect = Rectangle::new(42, 58);\nlet area = rect.area();\nassert_eq!(area, 2436);\nprintln!(\"The rectangle's area is: {}\", area);",
          "content": ""
        }
      ]
    },
    {
      "id": "ACiP6Y2O5e",
      "title": "Mini Projects",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "@n6b3RDWPm",
          "title": "Rust Mini Projects",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "We have now covered a lot of Rust fundamentals\\!\n\nCongratulations you are well on the way to becoming a proficient Rust programmer\\!\n\nIt's time to get our hands dirty writing some Rust code. We've learned enough to write a few more complex programs. This section introduces a few mini projects which will give you a chance to test out your newly acquired Rust chops."
        },
        {
          "type": "rust",
          "id": "j$ugekdN1",
          "title": "Simulate Tic Tac Toe",
          "instructions": "We've provided some code in the editor below. We want to simulate a Tic Tac Toe game and have created a function `simulate_tic_tac_toe` which takes a parameter of the number of games to simulate.\n\nYour job is to create additional code to handle this game simulation. The game simulation can just involve two players, the \"player\" and \"computer\", randomly playing against each other.\n\nOnce all the games are complete, return a `Result` containing a `GameResult` from the `simulate_tic_tac_toe` function\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = simulate_tic_tac_toe(10);\n  match result {\n    Ok(x) => {\n      let total = x.player_wins + x.computer_wins + x.stalemates;\n      assert_eq!(total, 10);\n      assert_eq!(x.games_played, 10);\n    }\n    Err(_e) => {\n      panic!(\"Function should return an Ok result not return an Err!\");\n    }\n  }\n\n  true\n}\n`;\n\ntest(\"The `simulate_tic_tac_toe` function should return a `GameResult` representing the number of games simulated and the results.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct GameResult {\n  games_played: u32,\n  player_wins: u32,\n  computer_wins: u32,\n  stalemates: u32,\n}\n\n// Change anything except this function signaure ;)\nfn simulate_tic_tac_toe(number_of_games_to_play: u32) -> Result<GameResult, String> {\n  println!(\"Ready to start playing {} games!\", number_of_games_to_play);\n  \n  // Write your code here, or anywhere else\n\n  Err(String::from(\"The game is not implemented yet!\"))\n}\n\nlet result = simulate_tic_tac_toe(3);\nprintln!(\"Game result: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nstruct GameResult {\n  games_played: u32,\n  player_wins: u32,\n  computer_wins: u32,\n  stalemates: u32,\n}\n\n// Change anything except this function signaure ;)\nfn simulate_tic_tac_toe(number_of_games_to_play: u32) -> Result<GameResult, String> {\n  println!(\"Ready to start playing {} games!\", number_of_games_to_play);\n  \n  // TODO: Implement solution\n  let result = GameResult {\n    games_played: number_of_games_to_play,\n    player_wins: number_of_games_to_play,\n    computer_wins: 0,\n    stalemates: 0,\n  };\n\n  Ok(result)\n}\n\nlet result = simulate_tic_tac_toe(3);\nprintln!(\"Game result: {:?}\", result);",
          "content": ""
        }
      ]
    },
    {
      "id": "AX04ZC5H8",
      "title": "Ownership and Borrowing",
      "free": false,
      "challenges": []
    },
    {
      "id": "5wbe@14QT",
      "title": "Generics, Traits and Lifetimes",
      "free": false,
      "challenges": []
    },
    {
      "id": "zfbfBa6nP",
      "title": "Macros",
      "free": false,
      "challenges": []
    },
    {
      "id": "LeikXungd",
      "title": "Smart Pointers",
      "free": false,
      "challenges": []
    },
    {
      "id": "HiDVdMr4I",
      "title": "Concurrency",
      "free": false,
      "challenges": []
    },
    {
      "id": "XT73AIuM5",
      "title": "Advanced Topics",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "axPeNlByhG",
          "title": "Advanced Topics",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "This section will cover additional Rust features, such as:\n\n* Functional programming techniques in Rust\n* Object\\-oriented programming techniques in Rust\n* Unsafe code\n* Some advanced features\n\n"
        },
        {
          "type": "rust",
          "id": "PMz$hmkFP",
          "title": "Unsafe Code",
          "instructions": "The Rust compiler, as we have seen in the previous challenges, is very strict when enforcing code correctness and preventing runtime errors. It is possible to opt out of the compiler's strict behavior, but it is of course _unsafe_ to do so.\n\nLet's take a look at the editor below. If you compile the code you will see an error: `use of mutable static is unsafe and requires unsafe function or block`.\n\nGlobal, mutable state can be dangerous in a variety of programming scenarios, but in Rust this is explicit. The compiler does not allow you to have global mutable state with explicitly declaring it is _unsafe_. Nice\\!\n\nTo write unsafe code you have wrap the code in question in an `unsafe {...}` code block. Do this to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and use an `unsafe` block to allow the mutation of global state (a dangerous thing to do!).\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"unsafe\")).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "static mut DANGEROUS_GLOBAL_MUTABLE_CONSTANT: u8 = 10;\n\nfn mutating_global_state_is_dangerous() {\n  println!(\"[1] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n  DANGEROUS_GLOBAL_MUTABLE_CONSTANT = 5;\n  println!(\"[2] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n}\n\nmutating_global_state_is_dangerous();",
          "solutionCode": "static mut DANGEROUS_GLOBAL_MUTABLE_CONSTANT: u8 = 10;\n\nfn mutating_global_state_is_dangerous() {\n  unsafe {\n    println!(\"[1] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n    DANGEROUS_GLOBAL_MUTABLE_CONSTANT = 5;\n    println!(\"[2] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n  }\n}\n\nmutating_global_state_is_dangerous();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "P9Ag0kmmB",
          "title": "Type Casting",
          "instructions": "It is possible to cast between primitive types in Rust. No implicit coercion is allowed but you can try to cast to a new type using the `as` keyword, e.g. `my_value as char` will attempt to cast `my_value` \\(whatever it is\\) to `char`. In the editor below, we show how to cast from a floating point type to an integer type. But this of course results in the loss of information. Complete the `cast_float_to_integer` function to cast the given floating point value to an integer and return it.\n\n> Casting is non standard and should be used with caution only if you know what you are doing.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut flt: f64 = 1.231;\n  let mut result = cast_float_to_integer(flt);\n  assert_eq!(result, 1);\n\n  flt = 1982.9123100;\n  result = cast_float_to_integer(flt);\n  assert_eq!(result, 1982);\n\n  flt = 0.218;\n  result = cast_float_to_integer(flt);\n  assert_eq!(result, 0);\n\n  true\n}\n`;\n\ntest(\"The `cast_float_to_integer` function should cast the given floating point number into an `i128` integer and return it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Type casting can result in the loss of information. Only\n// use it sparingly if you know what you are doing.\nfn cast_float_to_integer(flt: f64) -> i128 {\n  // Write your code here\n}\n\nlet mut flt: f64 = 1.231;\nlet mut result = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 1982.9123100;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 0.218;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);",
          "solutionCode": "// Type casting can result in the loss of information. Only\n// use it sparingly if you know what you are doing.\nfn cast_float_to_integer(flt: f64) -> i128 {\n  flt as i128\n}\n\nlet mut flt: f64 = 1.231;\nlet mut result = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 1982.9123100;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 0.218;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);",
          "content": ""
        }
      ]
    },
    {
      "id": "krVVmQd$S",
      "title": "Intermediate Challenges",
      "challenges": [
        {
          "type": "section",
          "id": "32C7HdQle",
          "title": "Practice Challenges",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this next section \\(and final section before the projects\\) we will cover various Rust programming challenges which are intended to give your more experience writing and working with Rust syntax, data structures, and functions."
        },
        {
          "id": "Flaxrbchq",
          "type": "rust",
          "title": "String Sub String",
          "instructions": "Write a function `string_sub_string` which accepts two string inputs and returns `true` if the second is a substring of the first. For instance, `\"plan\"` is a substring of `\"planned\"`, but not a substring of `\"globe\"`.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = string_sub_string(\"\", \"\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plannede\");\n      if result != false {\n        return false;\n      }\n\n      result = string_sub_string(\"planned\", \"planned\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plan\");\n      if result != true {\n        return false;\n      }\n\n      result = string_sub_string(\"as89df709asfuoiasudfisaodfusadFSAFASFASDf\", \"sfuoiasudfisaodfusadFSAF\");\n      if result != true {\n        return false;\n      }\n      \n      return true;\n    }\n  `;\n\ntest(\"`string_sub_string` should return `true` if the second input argument is a substring of the first.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n",
          "solutionCode": "// Determine if a string is a valid substring of another\nfn string_sub_string(a: &str, b: &str) -> bool {\n  // Immediately return true if strings are simply equal, including empty strings\n  if a == b {\n    return true;\n  }\n\n  // Convert both strings to vectors\n  let mut a_vec = Vec::new();\n  let mut b_vec = Vec::new();\n\n  for c in a.chars() {\n    a_vec.push(c);\n  }\n\n  for c in b.chars() {\n    b_vec.push(c);\n  }\n\n  // Ensure the first is longer than the second\n  if b_vec.len() > a_vec.len() {\n    return false;\n  }\n\n  // Iterate through the first string vector until the first character\n  // matches the first character of the second. If it does, try to\n  // iterate forward from there and match all adjacent characters.\n  let mut index = 0;\n  while index < a_vec.len() {\n    let a_value = a_vec[index];\n    let b_value = b_vec[0];\n\n    if a_value == b_value {\n      let mut a_index = index + 1;\n      let mut b_index = 1;\n      let mut valid = true;\n\n      while b_index < b_vec.len() {\n        if a_vec[a_index] == b_vec[b_index] {\n          a_index = a_index + 1;\n          b_index = b_index + 1;\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if valid {\n        return true;\n      }\n    }\n    index = index + 1;\n  }\n\n  // If you reached here and found no valid match, there is none.\n  return false;\n}\n",
          "content": ""
        },
        {
          "id": "y4tgWGLOS",
          "type": "rust",
          "title": "Fill a Vector",
          "instructions": "In Rust you can use a [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html) struct to represent a list of items. Write a function fillVector which takes a single integer input parameter and returns a vector with containing all of the integers up to and including the input parameter.\n\n```\nfill_vector(10) // -> Vec[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n```\n\n**Note: **You can assume the input will not be negative, but it may be zero.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      fn fill_vector_solution(max: i64) -> Vec<i64> {\n        let mut current = 0;\n        let mut v = Vec::new();\n        while current <= max {\n          v.push(current);\n          current = current + 1;\n        }\n        v\n      }\n\n      fn compare_vectors(v1: Vec<i64>, v2: Vec<i64>) -> bool {\n        let mut index = 0;\n        for x in &v1 {\n          let other = &v2[index];\n          if x != other {\n            return false;\n          }\n\n          index = index + 1;\n        }\n        true\n      }\n      \n      fn compare(value: i64) -> bool {\n        let mut result = fill_vector(value);\n        let mut expected = fill_vector_solution(value);\n        if compare_vectors(result.to_owned(), expected.to_owned()) == false {\n          return false;\n        }\n        true\n      }\n      \n      let mut value = 5;\n      let values = vec![0, 1, 6, 12, 15, 26, 88, 900];\n      for v in values {\n        if compare(v) == false {\n          return false;\n        }\n      }\n      true\n    }\n  `;\n\ntest(\"`fill_vector` should accept an integer argument and return a new vector of all of the integers up to and including that integer argument.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Fill up a vector",
          "solutionCode": "// Fill up a vector\nfn fill_vector(max: i64) -> Vec<i64> {\n  let mut current = 0;\n  let mut result = Vec::new();\n  while current <= max {\n    result.push(current);\n    current = current + 1;\n  }\n  return result;\n}\n",
          "content": ""
        },
        {
          "id": "sLQQLy12e",
          "type": "rust",
          "title": "Create a Struct",
          "instructions": "Rust [structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html) provide a way to represent more complex data structures. For this challenge, create a struct to represent a person. The struct should have the following fields: `name`, `age`, `height`, and `siblings`. These should be of type, string, integer, integer, and boolean, respectively.\n\nWrite a function `create_person` which accepts the above values as parameters and returns a new `Person` struct\\.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut person = create_person(String::from(\"Sean\"), 31, 82, true);\n      if person.name.eq(\"Sean\") != true {\n        return false\n      }\n      if person.age != 31 {\n        return false;\n      }\n      if person.height != 82 {\n        return false;\n      }\n      if person.siblings != true {\n        return false;\n      }\n\n       person = create_person(String::from(\"Zakaria\"), 717, 929, false);\n      if person.name.eq(\"Zakaria\") != true {\n        return false\n      }\n      if person.age != 717 {\n        return false;\n      }\n      if person.height != 929 {\n        return false;\n      }\n      if person.siblings != false {\n        return false;\n      }\n\n      true\n    }\n  `;\n\ntest(\"`create_person` should accept the arguments `name`, `age`, `height`, and `siblings` and return a new `Person` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here:",
          "solutionCode": "struct Person {\n  name: String,\n  age: u16,\n  height: u16,\n  siblings: bool,\n}\n\nfn create_person(name: String, age: u16, height: u16, siblings: bool) -> Person {\n  Person {\n    name,\n    age,\n    height,\n    siblings,\n  }\n}\n",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "uZZsKk7083",
      "title": "Final Projects",
      "challenges": [
        {
          "type": "section",
          "id": "tVYCXZbIl",
          "title": "Projects",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will build several projects in Rust to round off your Rust learning experience."
        },
        {
          "type": "project",
          "id": "NCoNBdnxF",
          "title": "Command Line Key Value Store",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "For this project we will build a simple key value store which can be used on the command line.\n\nWrite a Rust program to store key value pairs with the following command line API:\n\n* Set an item: `cargo run set foo bar`.\n* Get an item: `cargo run get foo`.\n* Get all items: `cargo run getAll`.\n* Remove an item: `cargo remove foo`.\n* Remove all items: `cargo removeAll`.\n\n\nYour program will store the cache in memory while it is running. For a bonus, consider adding input validation and testing for your project. For another bonus, consider having your program write the cache to disk to be able to persist cache state between sessions."
        },
        {
          "type": "project",
          "id": "NV9DixvF7",
          "title": "Key Value Web Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Here we will expand on our key value command line utility by writing a Rust server with an API for the same functionality.\n\nBuild a server in Rust which exposes a REST API to allow users to set, get, and remove items in a key value store. Unlike the command line utility, this should support set arbitrary JSON data in the `value` field for cache entries. The API should also support retrieving all existing entries, and remove all existing entries.\n\nBonus points:\n\n* Consider adding validation for requests.\n* Consider how you might add tests for your server.\n* Consider how you might add an authentication layer, or separate expose the functionality to multiple different users \\(e.g. N users consume your API, but they each access separate caches\\).\n* Consider how you might persist the cache data more permanently using a database.\n\n"
        },
        {
          "type": "project",
          "id": "UticrWdb1",
          "title": "Command Line Tic Tac Toe Game",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Let's create a Tic Tac Toe game in Rust. This will be similar to the Tic Tac Toe project in the FullStack TypeScript curriculum, if you completed that previously. Here, however, the game will be totally opened ended for you to design as you see fit. The main requirements are:\n\n* Players can play the computer in Tic Tac Toe.\n* The game will randomly choose who plays first.\n* The computer will choose a random move each round.\n* The game will obey the ordinary rules of Tic Tac Toe, and declare a winner or tie at the end.\n* Once a game completes, the player will have the option to play again.\n* For a given session, the game should get track of overall wins/losses.\n\n\nFor your program, consider edge cases, handling errors, and how you can add tests to verify the game behavior is correct. Good luck\\!\n"
        },
        {
          "type": "project",
          "id": "s2Ph4e5cp",
          "title": "Real Time Chat Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Build a web server using Rust which provides a real time chat functionality. For the basic implementation, consider a single chatroom which anyone can join and post messages to. The server forwards messages in real time to all connected clients.\n\nFor client implementations, you may disregard implementing a client \\(if you wish\\), or build a simple UI web client, or build a command line client in Rust which allows you to post a message to the chat server and can also subscribe to the server and print out any new messages as they arrive.\n\nFor more challenges, consider how you might change this to persist messages using a database and allow for more advanced chat features \\(e.g. direct messages between users, replies/threads, reactions, etc.\\). Finally, consider how you might test your project."
        }
      ],
      "free": false
    },
    {
      "id": "aUHE3cOCli",
      "title": "Rust in Production",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "663qF3qvRe",
          "title": "Rust Applications",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "What is Rust actually used for in the real world, and what can you do with your Rust skills?"
        }
      ]
    }
  ]
}