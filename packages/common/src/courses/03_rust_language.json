{
  "free": false,
  "price": 50,
  "premiumPrice": 500,
  "id": "alosiqu45",
  "title": "Rust",
  "description": "Rust is a statically typed, multi paradigm programming language which excels at performance and safety.",
  "modules": [
    {
      "id": "alosiuqwk",
      "title": "Intro to Rust",
      "free": true,
      "challenges": [
        {
          "id": "1UMWYNFnEH",
          "type": "section",
          "title": "The Rust Language",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined.\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "[Rust](https://doc.rust-lang.org/rust-by-example/index.html) is a powerful programming language which offers the speed of a compiled language like C\\+\\+ but with many of the abstractions and safety guarantees present in higher level languages. It does this with the help of a sophisticated compiler system.\n\nFirst we will start with 3 intro challenges which are intended to highlight some of the basics of Rust and give you a quick onboarding to writing some Rust code.\n\nProceed to the next challenge to begin\\!"
        },
        {
          "id": "S@Ghw6X75",
          "type": "rust",
          "title": "Intro to Rust",
          "instructions": "Complete the function in the editor which adds two numbers together. [Rust](https://www.rust-lang.org) is a fairly new programming language which is growing rapidly in popularity. Rust famously tries to provide the speed of a low level compiled language with the productivity of a richly featured high level language.",
          "testCode": "test(\"The `add` function should exist and add two numbers together.\", async () => {\n  const RUST_CODE_STRING = __user_code_string__;\n\n  const RUST_TEST_STRING = `\n    fn test() -> bool {\n      let mut result = add(10, 5);\n      let mut expected = 15;\n      if result != expected {\n          return false;\n      }\n\n      result = add(100, 200);\n      expected = 300;\n      if result != expected {\n          return false;\n      }\n\n      result = add(10, 25);\n      expected = 35;\n      if result != expected {\n          return false;\n      }\n\n      result = add(-15, 15);\n      expected = 0;\n      if result != expected {\n          return false;\n      }\n\n      result = add(1000, -2000);\n      expected = -1000;\n      if result != expected {\n          return false;\n      }\n\n      true\n    }\n  `;\n\n  const result = await executeRustChallengeTests(\n    RUST_CODE_STRING,\n    RUST_TEST_STRING\n  );\n\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A function to add two numbers together\nfn add(a: i32, b: i32) -> i32 {\n  // Your code here\n}\n",
          "solutionCode": "// Write an add function using Rust\nfn add(a: i32, b: i32) -> i32 {\n  a + b\n}\n",
          "content": ""
        },
        {
          "id": "Qug@7dDI$",
          "type": "rust",
          "title": "Variable Mutability",
          "instructions": "In Rust values are immutable by default. You have to opt\\-in to mutability. You can do this in variable declarations using the `mut` keyword\\. The `cost` integer is defined in the editor below. Next, we try to change this value—but this code doesn't compile. Fix the problem by making the variable mutable.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let result = get_cost();\n      if result != 500 {\n        return false;\n      }\n\n      return true;\n    }\n  `;\n\ntest(\"The `cost` variable should be mutable and equal to `500`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  if (!CODE_STRING.includes(\"let mut cost\")) {\n    throw new Error(\"cost must be mutable.\");\n  }\n\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_cost() -> i32 {\n  let cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "solutionCode": "fn get_cost() -> i32{\n  let mut cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "EknAkk16W",
          "title": "Rust's Result Type",
          "instructions": "Some of the most commonly used and powerful types in Rust are the [Option](https://doc.rust-lang.org/rust-by-example/std/option.html) and [Result](https://doc.rust-lang.org/rust-by-example/error/result.html) type\\. These types allow you to represent values that may be in one of two potential states, i.e. \"some\" or \"none\" in the case of the `Option` type and \"valid/ok\" or \"error/failure\" in the case of the `Result` type\\.\n\nThe application of these types in Rust combined with the strictness of the Rust compiler are intended to create a programming experience where all of the \"null point exception\" and \"cannot read property of undefined\" classes of errors are simply not possible because of extensive type checking.\n\nIn the editor below, we have some simple code which explores usage of the Result type. You will see the `is_number_valid` which returns a `Result`. Your job is to add a conditional `if` clause to this function which returns the valid Result, an \"ok\" [unit type](https://doc.rust-lang.org/std/primitive.unit.html), if the provided `num` parameter is less than 25.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = true;\n\n      let mut fn_result = is_number_valid(5);\n      match fn_result {\n        Ok(()) => (),\n        Err(e) => {\n          result = false;\n        }\n      }\n\n      fn_result = is_number_valid(50);\n      match fn_result {\n        Ok(()) => {\n          result = false;\n        },\n        Err(e) => (),\n      }\n      \n      return result;\n    }\n  `;\n\ntest(\"The `is_number_valid` function should return a Result unit type `()` if the provided input is less than 25, or an `Err` type otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  // Your code here\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(50);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(5);\ncheck_result(invalid);",
          "solutionCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  if num < 25 {\n    return Ok(())\n  }\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(15);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(50);\ncheck_result(invalid);",
          "content": ""
        }
      ]
    },
    {
      "id": "vjN$jfZeb",
      "title": "Data Primitives",
      "challenges": [
        {
          "type": "section",
          "id": "6w$q0NkrZ",
          "title": "Data Primitives and Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust is a fully typed language so our discussion should begin by defining the basic data primitives and types you have to work with. That will be the topic of this section, all the basic data types and primitives in Rust. Specifically, we will look at:\n\n* Signed and unsigned integers.\n* Floating point numbers.\n* Arithmetic\\.\n* Booleans\\.\n* Characters\\.\n\n\nAlong the way we will get a feeling for basic syntax in Rust, e.g. variable and function declarations, print statements, code comments, and other basics.\n\nIn the next module, we will cover basic Rust programming and data structures."
        },
        {
          "type": "rust",
          "id": "hH8NF2FXav",
          "title": "Syntax Primer",
          "instructions": "Before we dive in, let's start with a quick practice lesson to gain a foundation in basic Rust syntax, specifically how to define variables and functions in Rust.\n\nRead the code and comments in the editor, and then make a small change to solve the challenge.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = is_complete();\n\n  result\n}\n`;\n\ntest(\"The `is_complete` function should return the boolean `true`. Update this function to return `true` once you are satisifed you understand all the points here.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = false;\n}",
          "solutionCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = true;\n\n  i_read_and_understood_everything\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "d8WItf9JW",
          "title": "Rust Integer Types",
          "instructions": "Initialize the `my_int` value in `get_integer` function in the editor to return a valid `i8` integer, an 8\\-bit signed integer. Rust supports multiple different integer data types, from 8 to 128 bit, each signed or unsigned. A \"signed\" integer is one that may be positive of negative, e.g. `-4` is a signed integer. Unsigned integers are assumed to be positive.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let n = get_integer();\n  let result = 5 + n;\n  let original = result - 5;\n\n  if n != original {\n    return false\n  }\n\n  return true\n}\n`;\n\ntest(\"The `my_int` variable in the `get_integer` should be correctly initialized.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "solutionCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8 = 15;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "z6DMvoh1T",
          "title": "Integer Type Sizes",
          "instructions": "The size of an integer data type refers to how much memory will be required to store the value, and hence, this imposes a limit on the size of the particular integer. An `i8` value, for instance, occupies 8 bits of space and can range from `-128` to `127`.\n\nThe editor below has a function `check_integer_i8_range` which uses the public `i8` constant `MIN` and `MAX` values and the `assert_eq!` macro \\(don't worry, more on all this later\\) to check that an input range falls within the bounds of an acceptable `i8` integer\\.\n\nUpdate the invocation of `check_integer_i8_range` so that the code compiles. Notice how the compiler is about to detect that the current code will fail, and even gives you a helpful hint\\!",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  check_integer_i8_range(-128, 127);\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `check_integer_i8_range` function should be invoked with the minimum and maximum bounds of an `i8` integer.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(\n    CODE_STRING.replace(/ /g, \"\").includes(\"check_integer_i8_range(-128,127)\")\n  ).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-500, 500);\n",
          "solutionCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-128, 127);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Y2SVKl8Xq",
          "title": "Practice With Integers",
          "instructions": "As we mentioned when introduced integer data types, Rust provides types from 8\\-bit up to 128\\-bit, signed and unsigned integers. Complete the function into the editor below by filling in all the integer types so the code compiles.\n\nDon't worry about the struct defined at the top of the editor—we will cover this later. Just deal with defining the variables correctly in the body of the `get_all_integer_data_types` function\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = get_all_integer_data_types();\n\n  let TestStruct = IntegerTypes {\n    eight_bit_signed: 50,\n    eight_bit_unsigned: 50,\n    sixteen_bit_signed: 50,\n    sixteen_bit_unsigned: 50,\n    thirty_two_bit_signed: 5000,\n    thirty_two_bit_unsigned: 5000,\n    sity_four_bit_signed: 5000,\n    sity_four_bit_unsigned: 5000,\n    one_hundred_twenty_eight_bit_signed: 5000,\n    one_hundred_twenty_eight_bit_unsigned: 5000,\n  };\n\n  let _a: i8 = result.eight_bit_signed + TestStruct.eight_bit_signed;\n  let _b: u8 = result.eight_bit_unsigned + TestStruct.eight_bit_unsigned;\n  let _c: i16 = result.sixteen_bit_signed + TestStruct.sixteen_bit_signed;\n  let _d: u16 = result.sixteen_bit_unsigned + TestStruct.sixteen_bit_unsigned;\n  let _e: i32 = result.thirty_two_bit_signed + TestStruct.thirty_two_bit_signed;\n  let _f: u32 = result.thirty_two_bit_unsigned + TestStruct.thirty_two_bit_unsigned;\n  let _g: i64 = result.sity_four_bit_signed + TestStruct.sity_four_bit_signed;\n  let _h: u64 = result.sity_four_bit_unsigned + TestStruct.sity_four_bit_unsigned;\n  let _i: i128 = result.one_hundred_twenty_eight_bit_signed + TestStruct.one_hundred_twenty_eight_bit_signed;\n  let _j: u128 = result.one_hundred_twenty_eight_bit_unsigned + TestStruct.one_hundred_twenty_eight_bit_unsigned;\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `get_all_integer_data_types` function should return a properly defined `IntegerTypes` struct, which includes all 10 different integer data types.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed;\n  let eight_bit_unsigned;\n\n  // 16-bit\n  let sixteen_bit_signed;\n  let sixteen_bit_unsigned;\n\n  // 32-bit\n  let thirty_two_bit_signed;\n  let thirty_two_bit_unsigned;\n\n  // 64-bit\n  let sity_four_bit_signed;\n  let sity_four_bit_unsigned;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed;\n  let one_hundred_twenty_eight_bit_unsigned;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "solutionCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed = -4;\n  let eight_bit_unsigned = 4;\n\n  // 16-bit\n  let sixteen_bit_signed = -500;\n  let sixteen_bit_unsigned = 500;\n\n  // 32-bit\n  let thirty_two_bit_signed = -10000;\n  let thirty_two_bit_unsigned = 10000;\n\n  // 64-bit\n  let sity_four_bit_signed = -10000000;\n  let sity_four_bit_unsigned = 10000000;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed = -10000000000;\n  let one_hundred_twenty_eight_bit_unsigned = 10000000000;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "6DWRvh7zW",
          "title": "Floating Point Numbers",
          "instructions": "Rust also provides basic data types to deal with floating point numbers. In Rust there are two floating point types: `f32` and `f64`, which use 32 and 64 bits, respectively.\n\nInitialize the two variables in the function body to floating point values so the code compiles correctly.\n\nIf you don't explicitly declare the type, Rust will assign `f64` as the default floating point data type, try doing this for the second variable in the function body.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = floating_point_types();\n  let _x: f32 = result.0;\n  let _y: f64 = result.1;\n\n  true\n}\n`;\n\ntest(\"The `floating_point_types` function should return a `(f32, f64)` type tuple, using the properly initialized values in the function body.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32;\n\n  // The type will default to f64\n  let floating_point_sixty_four;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32 = 213.12311;\n\n  // The type will default to f64\n  let floating_point_sixty_four = 32423.12313131;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "7ZmqyOC7T",
          "title": "Rust Arithmetic",
          "instructions": "Rust supports basic arithmetic similar to many other programming languages, using common operators such as `+`, `-`, `*`, `/`, and `%`. Complete the arithmetic helper functions in the editor with the appropriate operators.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _a = add(23.532, 42.592);\n  let _b: f64 = subtract(23.532, 42.592);\n  let _c: f64 = multiply(23.532, 42.592);\n  let _d: f64 = divide(23.532, 42.592);\n  let _e: f64 = modulus(23.532, 42.592);\n\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "solutionCode": "fn add(a: f64, b: f64) -> f64 {\n  a + b\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  a - b\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  a * b\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  a / b\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  a % b\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "U3$RxoovO",
          "title": "Boolean Values",
          "instructions": "In Rust boolean values can be `true` or `false` and as a type can be represented using the  `bool` keyword\\. Change the value of the variables in the `all_should_be_truthy` function in the editor according to the type annotations so the code compiles, and then return an appropriate value from the function.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = all_should_be_truthy();\n\n  return result;\n}\n`;\n\ntest(\"The `all_should_be_truthy` function should compile and return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 50 < 10;\n\n  // Change the variable value, not the if statement\n  if should_be_true == false {\n    return false;\n  }\n\n  let should_be_false: bool = 250 > 50;\n\n  // Change the variable value, not the if statement\n  if should_be_false == true {\n    return false;\n  }\n\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "solutionCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 5 < 10;\n\n  if should_be_true == false {\n    return false;\n  }\n\n  let should_be_false: bool = 25 > 50;\n\n  if should_be_false == true {\n    return false;\n  }\n\n  return true;\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "content": ""
        },
        {
          "type": "rust",
          "id": "R@eJbCV7@",
          "title": "The Char Type",
          "instructions": "Next is the `char` data type, which represents a single character. This is the primitive type which is used to build up `str` and `String` types which are more commonly used to represent string values \\(more on these later\\). A `char` value is limited to a single character and represents a Unicode Scalar Value. Note that `char`s are declared using single quotes.\n\nAdjust the `return_a_char_value` function so the code compiles.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _result: char = return_a_char_value();\n\n  true\n}\n`;\n\ntest(\"The `return_a_char_value` function should compile and return a `char` value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn return_a_char_value() -> char {\n  let character: char = 'xyz';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "solutionCode": "fn return_a_char_value() -> char {\n  let character: char = 'x';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "S3BmBYNCP",
      "title": "Rust Basics",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "upbaggZVb",
          "title": "Variables and Functions",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will cover variables and functions in more detail. These challenges should be fairly quick since the previous module included many examples of variables and functions. Nevertheless, it should be helpful to explicitly mention a few points here."
        },
        {
          "type": "rust",
          "id": "C55Lmpb@L",
          "title": "Immutable by Default",
          "instructions": "In Rust, variables are immutable by default. This means you cannot change the value after declaration. Of course, sometimes you might want to change the value later on, so you can opt\\-in to mutability using the `mut` keyword\\.\n\nUpdate the code in the editor by making variables mutable. The `immutable_by_default` function should be invoked twice.\n\n> Use the `mut` keyword intentionally. When you see a mutable variable, it means the original programmer _intended_ for that variable to change later on. This conveys useful information, and it is important it is an opt\\-in behavior. \n> \n> Use `mut` only when you need it.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: u128 = immutable_by_default(807);\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `immutable_by_default` function should by invoked twice.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  const matched = CODE_STRING.replaceAll(\" \", \"\").match(\n    /immutable_by_default\\(/g\n  ).length;\n\n  expect(matched).toBe(3);\n});\n\ntest(\"Two variables should be made mutable using the `mut` keyword.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  const matched = CODE_STRING.replaceAll(\" \", \"\").match(/letmut/g).length;\n\n  expect(matched).toBe(2);\n});\n",
          "videoUrl": "",
          "starterCode": "fn immutable_by_default(input: u128) -> u128{\n  let value = 52;\n\n  value = input;\n\n  value\n}\n\nlet result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "solutionCode": "fn immutable_by_default(input: u128) -> u128{\n  let mut value = 52;\n\n  value = input;\n\n  value\n}\n\nlet mut result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "dMMvFPvNS",
          "title": "Variable Shadowing",
          "instructions": "While variables are immutable by default, it is in fact possible to change immutable variables values by redeclaring them with the same name. This is called variable shadowing. To shadow a variable, you simply declare it again using the `let` keyword\\.\n\nThe code in the editor tries to update the `name` variable\\. Allow this to work by using variable shadowing—do not use the `mut` keyword\\.\n\n> Shadowing, although perhaps a bit unusual, is useful when working with values which need to be updated or redeclared \\(even, changing to a different type\\) throughout a program. Specifically, shadowing helps the programmer avoid coming up with a new name for the variable.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `name` variable should be shadowing and printed out for a total of 5 times.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const count = CODE_STRING.replace(/ /g, \"\").match(/letname=/g).length;\n  expect(count).toBe(5);\n});\n",
          "videoUrl": "",
          "starterCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "solutionCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  let name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  let name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  let name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  let name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ohaohA5x9",
          "title": "Constants",
          "instructions": "You can also declare constants in Rust. Constants are like variables but their value is fixed at compile time and not subject to change throughout the life of the program. Constants are declared with the `const` keyword, are always immutable, and must have an explicit type annotation. Constants can be declared in any scope, including the global scope. They are ideal for global values which do not change throughout the life of a program.\n\nAdd type annotations to the constants in the editor so the code compiles.\n\n> For the string type, try to use the string slice reference type `&str`. We will cover strings more in detail later.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let x = DEBUG;\n  let y = MAX_HEIGHT;\n  let z = NAME;\n\n  true\n}\n`;\n\ntest(\"The three constants should be initialized correctly and the code should compile.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const DEBUG = false;\n\nconst MAX_HEIGHT = 52;\n\nconst NAME = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "o0UpOqzg3",
          "title": "Functions",
          "instructions": "So far we've seen several functions, so you should have the basics down by now. But there is one important function we have not seen yet: the `main` function\\. Since we are working within the Pairwise workspace, some of the details of how to setup, compile, and run Rust code are hidden away \\(for now...\\).\n\nIn Rust, the entry point to a program is a `main` function\\. This is where everything starts, and it must be defined.\n\nIn the editor below, define a `main` function which returns the boolean `true`.\n\n> In the Pairwise workspace, we are taking your code from the editor below and wrapping it in the other code required to run a Rust program, e.g. the `main` function, and the test code for each challenge. This is all being compiled and run with the output captured to determine if you passed or failed the tests.\n> \n> The purpose of this is to get you off the ground quickly writing Rust code without having to deal with setup tasks like downloading the Rust compiler and learning how to use it \\(although, this is not that hard\\).\n> \n> But don't worry\\! We will cover these topics later in this course and by the end you will be compiling your own Rust code like a pro.\n\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = main();\n\n  return result;\n}\n`;\n\ntest(\"The `main` function should be defined and should return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "// Write your code here\nfn  main() -> bool {\n  true\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "eTZNP3td8",
          "title": "Function Return Values",
          "instructions": "There are two ways to return values from functions, using the explicit `return` keyword and also uniquely by just writing the final value as a statement with no semicolon.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "$Do6$e1dD",
          "title": "Snake Case",
          "instructions": "What is the convention for naming variables and functions in Rust? `snake_case`of course: all lowercase with words separated by underscores. As you learn more Rust, you will see that enforces strong conventions and rules in many cases which cannot be deviated from. Naming is no exception\\! Although it might feel frustrating at first, it means that any Rust code will have a basic level of familiarity to a seasoned Rust developer.\n\nUpdate the naming conventions in the editor to adhere to snake casing rules.\n\n> The code in the editor will compile. But if you were running `rustc` locally to see the full output you would see warnings on the variable names like this:\n> \n> ```\n> warning: function `myFunction` should have a snake case name\n> \n> ```\n> \n> Although you can name you functions and variables different, we would recommend sticking with the Rust convention of snake case.\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `myFunction` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_function\")).toBe(true);\n});\n\ntest(\"The `mySpecialValue` variable should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_special_value\")).toBe(true);\n});\n\ntest(\"The `functionResultValue` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"function_result_value\")).toBe(true);\n});\n",
          "videoUrl": "",
          "starterCode": "fn myFunction() -> u64 {\n  let mySpecialValue = 5000;\n\n  return mySpecialValue;\n}\n\nlet functionResultValue = myFunction();\nprintln!(\"functionResultValue: {:?}\", functionResultValue);",
          "solutionCode": "fn my_function() -> u64 {\n  let my_special_value = 5000;\n\n  return my_special_value;\n}\n\nlet function_result_value = my_function();\nprintln!(\"function_result_value: {:?}\", function_result_value);",
          "content": ""
        },
        {
          "type": "section",
          "id": "@VZT4$txv",
          "title": "Strings",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In Rust strings are a more complex topic than in many other languages where you simply have the notion of a \"string\" type. In Rust there are multiple ways to represent strings which we need to spend some time explain."
        },
        {
          "type": "section",
          "id": "5B5@asRy6",
          "title": "Data Structures",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust provides a variety of primitive and advanced data structures to work with. We will explore the most common and useful of these in this module, such as:\n\n* Tuples\n* Arrays\n* Enums\n* Vectors\n* Structs\n* Hash Maps\n\n"
        },
        {
          "type": "section",
          "id": "owXHK17s4",
          "title": "Control Flow",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust contains many of the common control flow structures you will be familiar with from other programming languages. We will cover those in this section, along with a few other patterns which are unique and common to Rust, such as:\n\n* If/else statements\n* Iterators and loops\n* Match statements\n\n"
        },
        {
          "type": "section",
          "id": "R4TolzmG5",
          "title": "Rust's Result and Option Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust contains two well known and powerful types the `Result` and `Option` types which are used to model values which optionally may be in an error/failure state \\(the `Result` type\\) or in an optional/not\\-present state \\(the `Option` type\\). These types are so prevalent and important that we have given them their own section of challenges here."
        },
        {
          "type": "section",
          "id": "ITJBLJQnl",
          "title": "Generics, Traits and Lifetimes",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "PnCi8hB8E",
          "title": "Error Handling",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "JAYJEcvrv",
          "title": "Testing",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "usDs33hMCZ",
          "title": "Modules, Packages and Crates",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "RZAimitGF",
          "title": "Cargo",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        }
      ]
    },
    {
      "id": "AX04ZC5H8",
      "title": "Ownership and Borrowing",
      "free": false,
      "challenges": []
    },
    {
      "id": "zfbfBa6nP",
      "title": "Macros",
      "free": false,
      "challenges": []
    },
    {
      "id": "LeikXungd",
      "title": "Smart Pointers",
      "free": false,
      "challenges": []
    },
    {
      "id": "HiDVdMr4I",
      "title": "Concurrency",
      "free": false,
      "challenges": []
    },
    {
      "id": "XT73AIuM5",
      "title": "Additional Features",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "axPeNlByhG",
          "title": "Additional Rust Features",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "This section will cover additional Rust features, such as:\n\n* Functional programming techniques in Rust\n* Object\\-oriented programming techniques in Rust\n* Unsafe code\n* Some advanced features\n\n"
        }
      ]
    },
    {
      "id": "krVVmQd$S",
      "title": "Practice Challenges",
      "challenges": [
        {
          "type": "section",
          "id": "32C7HdQle",
          "title": "Practice Challenges",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this next section \\(and final section before the projects\\) we will cover various Rust programming challenges which are intended to give your more experience writing and working with Rust syntax, data structures, and functions."
        },
        {
          "id": "Flaxrbchq",
          "type": "rust",
          "title": "String Sub String",
          "instructions": "Write a function `string_sub_string` which accepts two string inputs and returns `true` if the second is a substring of the first. For instance, `\"plan\"` is a substring of `\"planned\"`, but not a substring of `\"globe\"`.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = string_sub_string(\"\", \"\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plannede\");\n      if result != false {\n        return false;\n      }\n\n      result = string_sub_string(\"planned\", \"planned\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plan\");\n      if result != true {\n        return false;\n      }\n\n      result = string_sub_string(\"as89df709asfuoiasudfisaodfusadFSAFASFASDf\", \"sfuoiasudfisaodfusadFSAF\");\n      if result != true {\n        return false;\n      }\n      \n      return true;\n    }\n  `;\n\ntest(\"`string_sub_string` should return `true` if the second input argument is a substring of the first.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n",
          "solutionCode": "// Determine if a string is a valid substring of another\nfn string_sub_string(a: &str, b: &str) -> bool {\n  // Immediately return true if strings are simply equal, including empty strings\n  if a == b {\n    return true;\n  }\n\n  // Convert both strings to vectors\n  let mut a_vec = Vec::new();\n  let mut b_vec = Vec::new();\n\n  for c in a.chars() {\n    a_vec.push(c);\n  }\n\n  for c in b.chars() {\n    b_vec.push(c);\n  }\n\n  // Ensure the first is longer than the second\n  if b_vec.len() > a_vec.len() {\n    return false;\n  }\n\n  // Iterate through the first string vector until the first character\n  // matches the first character of the second. If it does, try to\n  // iterate forward from there and match all adjacent characters.\n  let mut index = 0;\n  while index < a_vec.len() {\n    let a_value = a_vec[index];\n    let b_value = b_vec[0];\n\n    if a_value == b_value {\n      let mut a_index = index + 1;\n      let mut b_index = 1;\n      let mut valid = true;\n\n      while b_index < b_vec.len() {\n        if a_vec[a_index] == b_vec[b_index] {\n          a_index = a_index + 1;\n          b_index = b_index + 1;\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if valid {\n        return true;\n      }\n    }\n    index = index + 1;\n  }\n\n  // If you reached here and found no valid match, there is none.\n  return false;\n}\n",
          "content": ""
        },
        {
          "id": "y4tgWGLOS",
          "type": "rust",
          "title": "Fill a Vector",
          "instructions": "In Rust you can use a [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html) struct to represent a list of items. Write a function fillVector which takes a single integer input parameter and returns a vector with containing all of the integers up to and including the input parameter.\n\n```\nfill_vector(10) // -> Vec[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n```\n\n**Note: **You can assume the input will not be negative, but it may be zero.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      fn fill_vector_solution(max: i64) -> Vec<i64> {\n        let mut current = 0;\n        let mut v = Vec::new();\n        while current <= max {\n          v.push(current);\n          current = current + 1;\n        }\n        v\n      }\n\n      fn compare_vectors(v1: Vec<i64>, v2: Vec<i64>) -> bool {\n        let mut index = 0;\n        for x in &v1 {\n          let other = &v2[index];\n          if x != other {\n            return false;\n          }\n\n          index = index + 1;\n        }\n        true\n      }\n      \n      fn compare(value: i64) -> bool {\n        let mut result = fill_vector(value);\n        let mut expected = fill_vector_solution(value);\n        if compare_vectors(result.to_owned(), expected.to_owned()) == false {\n          return false;\n        }\n        true\n      }\n      \n      let mut value = 5;\n      let values = vec![0, 1, 6, 12, 15, 26, 88, 900];\n      for v in values {\n        if compare(v) == false {\n          return false;\n        }\n      }\n      true\n    }\n  `;\n\ntest(\"`fill_vector` should accept an integer argument and return a new vector of all of the integers up to and including that integer argument.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Fill up a vector",
          "solutionCode": "// Fill up a vector\nfn fill_vector(max: i64) -> Vec<i64> {\n  let mut current = 0;\n  let mut result = Vec::new();\n  while current <= max {\n    result.push(current);\n    current = current + 1;\n  }\n  return result;\n}\n",
          "content": ""
        },
        {
          "id": "sLQQLy12e",
          "type": "rust",
          "title": "Create a Struct",
          "instructions": "Rust [structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html) provide a way to represent more complex data structures. For this challenge, create a struct to represent a person. The struct should have the following fields: `name`, `age`, `height`, and `siblings`. These should be of type, string, integer, integer, and boolean, respectively.\n\nWrite a function `create_person` which accepts the above values as parameters and returns a new `Person` struct\\.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut person = create_person(String::from(\"Sean\"), 31, 82, true);\n      if person.name.eq(\"Sean\") != true {\n        return false\n      }\n      if person.age != 31 {\n        return false;\n      }\n      if person.height != 82 {\n        return false;\n      }\n      if person.siblings != true {\n        return false;\n      }\n\n       person = create_person(String::from(\"Zakaria\"), 717, 929, false);\n      if person.name.eq(\"Zakaria\") != true {\n        return false\n      }\n      if person.age != 717 {\n        return false;\n      }\n      if person.height != 929 {\n        return false;\n      }\n      if person.siblings != false {\n        return false;\n      }\n\n      true\n    }\n  `;\n\ntest(\"`create_person` should accept the arguments `name`, `age`, `height`, and `siblings` and return a new `Person` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here:",
          "solutionCode": "struct Person {\n  name: String,\n  age: u16,\n  height: u16,\n  siblings: bool,\n}\n\nfn create_person(name: String, age: u16, height: u16, siblings: bool) -> Person {\n  Person {\n    name,\n    age,\n    height,\n    siblings,\n  }\n}\n",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "uZZsKk7083",
      "title": "Projects",
      "challenges": [
        {
          "type": "section",
          "id": "tVYCXZbIl",
          "title": "Projects",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will build several projects in Rust to round off your Rust learning experience."
        },
        {
          "type": "project",
          "id": "NCoNBdnxF",
          "title": "Command Line Key Value Store",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "For this project we will build a simple key value store which can be used on the command line.\n\nWrite a Rust program to store key value pairs with the following command line API:\n\n* Set an item: `cargo run set foo bar`.\n* Get an item: `cargo run get foo`.\n* Get all items: `cargo run getAll`.\n* Remove an item: `cargo remove foo`.\n* Remove all items: `cargo removeAll`.\n\n\nYour program will store the cache in memory while it is running. For a bonus, consider adding input validation and testing for your project. For another bonus, consider having your program write the cache to disk to be able to persist cache state between sessions."
        },
        {
          "type": "project",
          "id": "NV9DixvF7",
          "title": "Key Value Web Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Here we will expand on our key value command line utility by writing a Rust server with an API for the same functionality.\n\nBuild a server in Rust which exposes a REST API to allow users to set, get, and remove items in a key value store. Unlike the command line utility, this should support set arbitrary JSON data in the `value` field for cache entries. The API should also support retrieving all existing entries, and remove all existing entries.\n\nBonus points:\n\n* Consider adding validation for requests.\n* Consider how you might add tests for your server.\n* Consider how you might add an authentication layer, or separate expose the functionality to multiple different users \\(e.g. N users consume your API, but they each access separate caches\\).\n* Consider how you might persist the cache data more permanently using a database.\n\n"
        },
        {
          "type": "project",
          "id": "UticrWdb1",
          "title": "Command Line Tic Tac Toe Game",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Let's create a Tic Tac Toe game in Rust. This will be similar to the Tic Tac Toe project in the FullStack TypeScript curriculum, if you completed that previously. Here, however, the game will be totally opened ended for you to design as you see fit. The main requirements are:\n\n* Players can play the computer in Tic Tac Toe.\n* The game will randomly choose who plays first.\n* The computer will choose a random move each round.\n* The game will obey the ordinary rules of Tic Tac Toe, and declare a winner or tie at the end.\n* Once a game completes, the player will have the option to play again.\n* For a given session, the game should get track of overall wins/losses.\n\n\nFor your program, consider edge cases, handling errors, and how you can add tests to verify the game behavior is correct. Good luck\\!\n"
        },
        {
          "type": "project",
          "id": "s2Ph4e5cp",
          "title": "Real Time Chat Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Build a web server using Rust which provides a real time chat functionality. For the basic implementation, consider a single chatroom which anyone can join and post messages to. The server forwards messages in real time to all connected clients.\n\nFor client implementations, you may disregard implementing a client \\(if you wish\\), or build a simple UI web client, or build a command line client in Rust which allows you to post a message to the chat server and can also subscribe to the server and print out any new messages as they arrive.\n\nFor more challenges, consider how you might change this to persist messages using a database and allow for more advanced chat features \\(e.g. direct messages between users, replies/threads, reactions, etc.\\). Finally, consider how you might test your project."
        }
      ],
      "free": false
    },
    {
      "id": "aUHE3cOCli",
      "title": "Rust in Production",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "663qF3qvRe",
          "title": "Rust Applications",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "What is Rust actually used for in the real world, and what can you do with your Rust skills?"
        }
      ]
    }
  ]
}