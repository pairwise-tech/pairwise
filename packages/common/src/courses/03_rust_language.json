{
  "free": false,
  "price": 50,
  "premiumPrice": 500,
  "id": "alosiqu45",
  "title": "Rust",
  "description": "Rust is a statically typed, multi paradigm programming language which excels at performance and safety.",
  "modules": [
    {
      "id": "alosiuqwk",
      "title": "Intro to Rust",
      "free": true,
      "challenges": [
        {
          "id": "1UMWYNFnEH",
          "type": "section",
          "title": "The Rust Language",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined.\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "[Rust](https://doc.rust-lang.org/rust-by-example/index.html) is a powerful programming language which offers the speed of a compiled language like C\\+\\+ but with many of the abstractions and safety guarantees present in higher level languages. It does this with the help of a sophisticated compiler system.\n\nFirst we will start with 3 intro challenges which are intended to highlight some of the basics of Rust and give you a quick onboarding to writing some Rust code.\n\nProceed to the next challenge to begin\\!"
        },
        {
          "id": "S@Ghw6X75",
          "type": "rust",
          "title": "Intro to Rust",
          "instructions": "Complete the function in the editor which adds two numbers together. [Rust](https://www.rust-lang.org) is a fairly new programming language which is growing rapidly in popularity. Rust famously tries to provide the speed of a low level compiled language with the productivity of a richly featured high level language.",
          "testCode": "test(\"The `add` function should exist and add two numbers together.\", async () => {\n  const RUST_CODE_STRING = __user_code_string__;\n\n  const RUST_TEST_STRING = `\n    fn test() -> bool {\n      let mut result = add(10, 5);\n      let mut expected = 15;\n      if result != expected {\n          return false;\n      }\n\n      result = add(100, 200);\n      expected = 300;\n      if result != expected {\n          return false;\n      }\n\n      result = add(10, 25);\n      expected = 35;\n      if result != expected {\n          return false;\n      }\n\n      result = add(-15, 15);\n      expected = 0;\n      if result != expected {\n          return false;\n      }\n\n      result = add(1000, -2000);\n      expected = -1000;\n      if result != expected {\n          return false;\n      }\n\n      true\n    }\n  `;\n\n  const result = await executeRustChallengeTests(\n    RUST_CODE_STRING,\n    RUST_TEST_STRING\n  );\n\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A function to add two numbers together\nfn add(a: i32, b: i32) -> i32 {\n  // Your code here\n}\n",
          "solutionCode": "// Write an add function using Rust\nfn add(a: i32, b: i32) -> i32 {\n  a + b\n}\n",
          "content": ""
        },
        {
          "id": "Qug@7dDI$",
          "type": "rust",
          "title": "Variable Mutability",
          "instructions": "In Rust values are immutable by default. You have to opt\\-in to mutability. You can do this in variable declarations using the `mut` keyword\\. The `cost` integer is defined in the editor below. Next, we try to change this valueâ€”but this code doesn't compile. Fix the problem by making the variable mutable.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let result = get_cost();\n      if result != 500 {\n        return false;\n      }\n\n      return true;\n    }\n  `;\n\ntest(\"The `cost` variable should be mutable and equal to `500`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  if (!CODE_STRING.includes(\"let mut cost\")) {\n    throw new Error(\"cost must be mutable.\");\n  }\n\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_cost() -> i32 {\n  let cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "solutionCode": "fn get_cost() -> i32{\n  let mut cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "EknAkk16W",
          "title": "Rust's Result Type",
          "instructions": "Some of the most commonly used and powerful types in Rust are the [Option](https://doc.rust-lang.org/rust-by-example/std/option.html) and [Result](https://doc.rust-lang.org/rust-by-example/error/result.html) type\\. These types allow you to represent values that may be in one of two potential states, i.e. \"some\" or \"none\" in the case of the `Option` type and \"valid/ok\" or \"error/failure\" in the case of the `Result` type\\.\n\nThe application of these types in Rust combined with the strictness of the Rust compiler are intended to create a programming experience where all of the \"null point exception\" and \"cannot read property of undefined\" classes of errors are simply not possible because of extensive type checking.\n\nIn the editor below, we have some simple code which explores usage of the Result type. You will see the `is_number_valid` which returns a `Result`. Your job is to add a conditional `if` clause to this function which returns the valid Result, an \"ok\" [unit type](https://doc.rust-lang.org/std/primitive.unit.html), if the provided `num` parameter is less than 25.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = true;\n\n      let mut fn_result = is_number_valid(5);\n      match fn_result {\n        Ok(()) => (),\n        Err(e) => {\n          result = false;\n        }\n      }\n\n      fn_result = is_number_valid(50);\n      match fn_result {\n        Ok(()) => {\n          result = false;\n        },\n        Err(e) => (),\n      }\n      \n      return result;\n    }\n  `;\n\ntest(\"The `is_number_valid` function should return a Result unit type `()` if the provided input is less than 25, or an `Err` type otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  // Your code here\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(50);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(5);\ncheck_result(invalid);",
          "solutionCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  if num < 25 {\n    return Ok(())\n  }\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(15);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(50);\ncheck_result(invalid);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "IIMmCDTle8",
          "title": "Comments",
          "instructions": "Comments in Rust are ignored by the compiler and convey helpful information and context to other future programmers. Their syntax is very similar to comment syntax in other languages.\n\nRead through the code in the editor to get a feel for the different comment styles in Rust. Don't worry if not all the code makes sense yet. When you are ready, click \"Run\" to complete the challenge. Don't forget to take a look at the console output before moving on.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code compiles. When you are ready run the code and take a look at the console output before moving on.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * This is a multi-line comment.\n *\n * The following code demonstrates various types of comment\n * usage. For regular comments you have /* ... */ multiline\n * comments like we are in now, and also single-line comments,\n * e.g. // This is my comment.\n *\n * Rust also supports standard documentation comments, which\n * are indicated using a triple slash: ///\n *\n * These documentation comments are displayed in the HTML\n * documentation generated when running 'cargo doc'. For\n * more on this take a look here:\n * https://doc.rust-lang.org/rust-by-example/meta/doc.html\n */\n\n/// Enum representing different possible weapon types\n#[derive(Debug)]\nenum WeaponTypes {\n  Sword,\n  Spear,\n  Dagger,\n  BowAndArrow,\n  Mace,\n  Axe,\n}\n\n/// A struct for a package item in a game\n#[derive(Debug)]\nstruct Weapon {\n  /// The weapon type\n  weapon_type: WeaponTypes,\n}\n\nimpl Weapon {\n  /// Create a new weapon, given a weapon type\n  pub fn new(weapon_type: WeaponTypes) -> Weapon {\n    Weapon {\n      weapon_type,\n    }\n  }\n}\n\n/**\n * This is a function to create some new weapons.\n */\nfn create_three_weapons() -> (Weapon, Weapon, Weapon) {\n  println!(\"\\nCreating 3 new weapons...\\n\");\n\n  // Create a sword\n  let sword = Weapon::new(WeaponTypes::Sword);\n  println!(\"Created a sword: {:?}\", sword);\n\n  // Create a mace\n  let mace = Weapon::new(WeaponTypes::Mace);\n  println!(\"Created a mace: {:?}\", mace);\n\n  // Create a sword\n  let dagger = Weapon::new(WeaponTypes::Dagger);\n  println!(\"Created a dagger: {:?}\", dagger);\n\n  println!(\"\\nFinished weapon creation!\");\n\n  // Return a tuple of the three created weapons\n  return (sword, mace, dagger);\n}\n\n// Create some weapons\ncreate_three_weapons();",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "vxOeSToH8",
          "title": "Logging Values with println!",
          "instructions": "Logging data while a program is running is important for development, debugging and various production use cases. Rust supports logging values primarily using the `println` macro which can be invoked with a `!`.\n\n```\n// Invoking the println macro:\nprintln!(\"Hello!\"); // Logs out \"Hello\"\n\n```\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = logging_demonstration();\n  \n  result\n}\n`;\n\ntest(\"The `logging_demonstration` function should return `true` once you are finished reading through the examples of `println`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * For most values you can use the println macro with {}\n * followed by the values you want to print out.\n *\n * For some values, you may need to use {:?}.\n *\n * The std::fmt library handles printing values and relies\n * on various traits, such as fmt::Debug and fmt::Display.\n * These traits must be derived or implemented for the values\n * you want to print out.\n *\n * If fmt::Display is implemented you can print a value using\n * using {}, if only Debug is implemented (which can usually\n * be derived) you will have to use {:?}.\n *\n * Don't worry about all these details much. For now, just\n * get a sense of how to use println to log values.\n */\nfn logging_demonstration() -> bool {\n  println!(\"\\n- Examples of using the println macro:\\n\");\n\n  let value = 52;\n  println!(\"Log a number: {}\", value);\n\n  let boolean = true;\n  println!(\"Log a boolean: {}\", boolean);\n\n  let name = \"Oren\";\n  println!(\"Log a string slice: {}\", name);\n\n  let a = 2;\n  let b = false;\n  let c = \"Hi!\";\n  // You can provide multiple arguments to println:\n  println!(\"Log out multiple values, a: {}, b: {}, c: {}\", a, b, c);\n\n  // We derive the fmt::Debug trait on our Person struct, to\n  // allow it to be printed using {:?} - otherwise, we would\n  // have to implement the fmt::Display trait.\n  #[derive(Debug)]\n  struct Person {\n    name: String,\n  }\n\n  let person = Person {\n    name: \"Sam\".to_string(),\n  };\n\n  // You must use {:?} to format values for which the Display\n  // trait has not been implemented, like the above Person.\n  println!(\"A Person: {:?}\", person);\n\n  let complete: bool = false;\n  println!(\"\\n- When you are ready, change the value of the complete variable from false to true to complete the challenge.\");\n\n  complete\n}\n\nlogging_demonstration();",
          "solutionCode": "/**\n * For most values you can use the println macro with {}\n * followed by the values you want to print out.\n *\n * For some values, you may need to use {:?}.\n *\n * The std::fmt library handles printing values and relies\n * on various traits, such as fmt::Debug and fmt::Display.\n * These traits must be derived or implemented for the values\n * you want to print out.\n *\n * If fmt::Display is implemented you can print a value using\n * using {}, if only Debug is implemented (which can usually\n * be derived) you will have to use {:?}.\n *\n * Don't worry about all these details much. For now, just\n * get a sense of how to use println to log values.\n */\nfn logging_demonstration() -> bool {\n  println!(\"\\n- Examples of using the println macro:\\n\");\n\n  let value = 52;\n  println!(\"Log a number: {}\", value);\n\n  let boolean = true;\n  println!(\"Log a boolean: {}\", boolean);\n\n  let name = \"Oren\";\n  println!(\"Log a string slice: {}\", name);\n\n  let a = 2;\n  let b = false;\n  let c = \"Hi!\";\n  // You can provide multiple arguments to println:\n  println!(\"Log out multiple values, a: {}, b: {}, c: {}\", a, b, c);\n\n  // We derive the fmt::Debug trait on our Person struct, to\n  // allow it to be printed using {:?} - otherwise, we would\n  // have to implement the fmt::Display trait.\n  #[derive(Debug)]\n  struct Person {\n    name: String,\n  }\n\n  let person = Person {\n    name: \"Sam\".to_string(),\n  };\n\n  // You must use {:?} to format values for which the Display\n  // trait has not been implemented, like the above Person.\n  println!(\"A Person: {:?}\", person);\n\n  let complete: bool = true;\n  println!(\"\\n- When you are ready, change the value of the complete variable from false to true to complete the challenge.\");\n\n  complete\n}\n\nlogging_demonstration();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "$Do6$e1dD",
          "title": "Naming: Snake Case",
          "instructions": "What is the convention for naming variables and functions in Rust? `snake_case`of course: all lowercase with words separated by underscores. As you learn more Rust, you will see that enforces strong conventions and rules in many cases which cannot be deviated from. Naming is no exception\\! Although it might feel frustrating at first, it means that any Rust code will have a basic level of familiarity to a seasoned Rust developer.\n\nUpdate the naming conventions in the editor to adhere to snake casing rules.\n\n> The code in the editor will compile. But if you were running `rustc` locally to see the full output you would see warnings on the variable names like this:\n> \n> ```\n> warning: function `myFunction` should have a snake case name\n> \n> ```\n> \n> Although you can name you functions and variables different, we would recommend sticking with the Rust convention of snake case.\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `myFunction` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_function\")).toBe(true);\n});\n\ntest(\"The `mySpecialValue` variable should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_special_value\")).toBe(true);\n});\n\ntest(\"The `functionResultValue` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"function_result_value\")).toBe(true);\n});\n",
          "videoUrl": "",
          "starterCode": "fn myFunction() -> u64 {\n  let mySpecialValue = 5000;\n\n  return mySpecialValue;\n}\n\nlet functionResultValue = myFunction();\nprintln!(\"functionResultValue: {:?}\", functionResultValue);",
          "solutionCode": "fn my_function() -> u64 {\n  let my_special_value = 5000;\n\n  return my_special_value;\n}\n\nlet function_result_value = my_function();\nprintln!(\"function_result_value: {:?}\", function_result_value);",
          "content": ""
        }
      ]
    },
    {
      "id": "vjN$jfZeb",
      "title": "Data and Types",
      "challenges": [
        {
          "type": "section",
          "id": "6w$q0NkrZ",
          "title": "Primitive Data and Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust is a statically typed language which means the Rust compiler determines the type of all data in a program when it is compiled. The compiler enforces that only valid operations are allowed \\- for instance, you cannot arithmetically add a string to an integer type. This section will introduce the basic types and data primitives you have available to work with in the Rust language. In particular, there are two main categories of primitive types: scalar and compound.\n\n**Scalar** types represent a single value, and include the following:\n\n* Signed and unsigned integers.\n* Floating point numbers.\n* Arithmetic\\.\n* Booleans\\.\n* Characters\\.\n* The unit type.\n\n\n**Compound** types group several individual values into one type. In Rust compound type primitives include arrays and tuples.\n\nThroughout this module, you will also get a feeling for basic syntax in Rust, e.g. variable and function declarations, print statements, code comments, and other basics.\n\nIn the next module, we will cover basic Rust programming and higher level data structures."
        },
        {
          "type": "rust",
          "id": "hH8NF2FXav",
          "title": "Rust Syntax Primer",
          "instructions": "Before we dive in, let's start with a quick practice lesson to gain a foundation in basic Rust syntax, specifically how to define variables and functions in Rust.\n\nRead the code and comments in the editor, and then make a small change to solve the challenge.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = is_complete();\n\n  result\n}\n`;\n\ntest(\"The `is_complete` function should return the boolean `true`. Update this function to return `true` once you are satisifed you understand all the points here.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = false;\n}",
          "solutionCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = true;\n\n  i_read_and_understood_everything\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "d8WItf9JW",
          "title": "Integers",
          "instructions": "Initialize the `my_int` value in `get_integer` function in the editor to return a valid `i8` integer, an 8\\-bit signed integer. Rust supports multiple different integer data types, from 8 to 128 bit, each signed or unsigned. A \"signed\" integer is one that may be positive of negative, e.g. `-4` is a signed integer. Unsigned integers are assumed to be positive.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let n = get_integer();\n  let result = 5 + n;\n  let original = result - 5;\n\n  if n != original {\n    return false\n  }\n\n  return true\n}\n`;\n\ntest(\"The `my_int` variable in the `get_integer` should be correctly initialized.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "solutionCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8 = 15;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "z6DMvoh1T",
          "title": "Integer Type Sizes",
          "instructions": "The size of an integer data type refers to how much memory will be required to store the value, and hence, this imposes a limit on the size of the particular integer. An `i8` value, for instance, occupies 8 bits of space and can range from `-128` to `127`.\n\nThe editor below has a function `check_integer_i8_range` which uses the public `i8` constant `MIN` and `MAX` values and the `assert_eq!` macro \\(don't worry, more on all this later\\) to check that an input range falls within the bounds of an acceptable `i8` integer\\.\n\nUpdate the invocation of `check_integer_i8_range` so that the code compiles. Notice how the compiler is about to detect that the current code will fail, and even gives you a helpful hint\\!",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  check_integer_i8_range(-128, 127);\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `check_integer_i8_range` function should be invoked with the minimum and maximum bounds of an `i8` integer.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(\n    CODE_STRING.replace(/ /g, \"\").includes(\"check_integer_i8_range(-128,127)\")\n  ).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-500, 500);\n",
          "solutionCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-128, 127);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Y2SVKl8Xq",
          "title": "Practice With Integers",
          "instructions": "As we mentioned when introduced integer data types, Rust provides types from 8\\-bit up to 128\\-bit, signed and unsigned integers. Complete the function into the editor below by filling in all the integer types so the code compiles.\n\nDon't worry about the struct defined at the top of the editorâ€”we will cover this later. Just deal with defining the variables correctly in the body of the `get_all_integer_data_types` function\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = get_all_integer_data_types();\n\n  let TestStruct = IntegerTypes {\n    eight_bit_signed: 50,\n    eight_bit_unsigned: 50,\n    sixteen_bit_signed: 50,\n    sixteen_bit_unsigned: 50,\n    thirty_two_bit_signed: 5000,\n    thirty_two_bit_unsigned: 5000,\n    sity_four_bit_signed: 5000,\n    sity_four_bit_unsigned: 5000,\n    one_hundred_twenty_eight_bit_signed: 5000,\n    one_hundred_twenty_eight_bit_unsigned: 5000,\n  };\n\n  let _a: i8 = result.eight_bit_signed + TestStruct.eight_bit_signed;\n  let _b: u8 = result.eight_bit_unsigned + TestStruct.eight_bit_unsigned;\n  let _c: i16 = result.sixteen_bit_signed + TestStruct.sixteen_bit_signed;\n  let _d: u16 = result.sixteen_bit_unsigned + TestStruct.sixteen_bit_unsigned;\n  let _e: i32 = result.thirty_two_bit_signed + TestStruct.thirty_two_bit_signed;\n  let _f: u32 = result.thirty_two_bit_unsigned + TestStruct.thirty_two_bit_unsigned;\n  let _g: i64 = result.sity_four_bit_signed + TestStruct.sity_four_bit_signed;\n  let _h: u64 = result.sity_four_bit_unsigned + TestStruct.sity_four_bit_unsigned;\n  let _i: i128 = result.one_hundred_twenty_eight_bit_signed + TestStruct.one_hundred_twenty_eight_bit_signed;\n  let _j: u128 = result.one_hundred_twenty_eight_bit_unsigned + TestStruct.one_hundred_twenty_eight_bit_unsigned;\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `get_all_integer_data_types` function should return a properly defined `IntegerTypes` struct, which includes all 10 different integer data types.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed;\n  let eight_bit_unsigned;\n\n  // 16-bit\n  let sixteen_bit_signed;\n  let sixteen_bit_unsigned;\n\n  // 32-bit\n  let thirty_two_bit_signed;\n  let thirty_two_bit_unsigned;\n\n  // 64-bit\n  let sity_four_bit_signed;\n  let sity_four_bit_unsigned;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed;\n  let one_hundred_twenty_eight_bit_unsigned;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "solutionCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed = -4;\n  let eight_bit_unsigned = 4;\n\n  // 16-bit\n  let sixteen_bit_signed = -500;\n  let sixteen_bit_unsigned = 500;\n\n  // 32-bit\n  let thirty_two_bit_signed = -10000;\n  let thirty_two_bit_unsigned = 10000;\n\n  // 64-bit\n  let sity_four_bit_signed = -10000000;\n  let sity_four_bit_unsigned = 10000000;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed = -10000000000;\n  let one_hundred_twenty_eight_bit_unsigned = 10000000000;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "6DWRvh7zW",
          "title": "Floating Point Numbers",
          "instructions": "Rust also provides basic data types to deal with floating point numbers. In Rust there are two floating point types: `f32` and `f64`, which use 32 and 64 bits, respectively.\n\nInitialize the two variables in the function body to floating point values so the code compiles correctly.\n\nIf you don't explicitly declare the type, Rust will assign `f64` as the default floating point data type, try doing this for the second variable in the function body.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = floating_point_types();\n  let _x: f32 = result.0;\n  let _y: f64 = result.1;\n\n  true\n}\n`;\n\ntest(\"The `floating_point_types` function should return a `(f32, f64)` type tuple, using the properly initialized values in the function body.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32;\n\n  // The type will default to f64\n  let floating_point_sixty_four;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32 = 213.12311;\n\n  // The type will default to f64\n  let floating_point_sixty_four = 32423.12313131;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "7ZmqyOC7T",
          "title": "Rust Arithmetic",
          "instructions": "Rust supports basic arithmetic similar to many other programming languages, using common operators such as `+`, `-`, `*`, `/`, and `%`. Complete the arithmetic helper functions in the editor with the appropriate operators.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _a = add(23.532, 42.592);\n  let _b: f64 = subtract(23.532, 42.592);\n  let _c: f64 = multiply(23.532, 42.592);\n  let _d: f64 = divide(23.532, 42.592);\n  let _e: f64 = modulus(23.532, 42.592);\n\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "solutionCode": "fn add(a: f64, b: f64) -> f64 {\n  a + b\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  a - b\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  a * b\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  a / b\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  a % b\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "U3$RxoovO",
          "title": "Boolean Values",
          "instructions": "In Rust boolean values can be `true` or `false` and as a type can be represented using the  `bool` keyword\\. Change the value of the variables in the `all_should_be_truthy` function in the editor according to the type annotations so the code compiles, and then return an appropriate value from the function.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = all_should_be_truthy();\n\n  return result;\n}\n`;\n\ntest(\"The `all_should_be_truthy` function should compile and return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 50 < 10;\n\n  // Change the variable value, not the if statement\n  if should_be_true == false {\n    return false;\n  }\n\n  let should_be_false: bool = 250 > 50;\n\n  // Change the variable value, not the if statement\n  if should_be_false == true {\n    return false;\n  }\n\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "solutionCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 5 < 10;\n\n  if should_be_true == false {\n    return false;\n  }\n\n  let should_be_false: bool = 25 > 50;\n\n  if should_be_false == true {\n    return false;\n  }\n\n  return true;\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "content": ""
        },
        {
          "type": "rust",
          "id": "R@eJbCV7@",
          "title": "The Char Primitive",
          "instructions": "Next is the `char` data type, which represents a single character. This is the primitive type which is used to build up `str` and `String` types which are more commonly used to represent string values \\(more on these later\\). A `char` value is limited to a single character and represents a Unicode Scalar Value. Note that `char`s are declared using single quotes.\n\nAdjust the `return_a_char_value` function so the code compiles.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _result: char = return_a_char_value();\n\n  true\n}\n`;\n\ntest(\"The `return_a_char_value` function should compile and return a `char` value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn return_a_char_value() -> char {\n  let character: char = 'xyz';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "solutionCode": "fn return_a_char_value() -> char {\n  let character: char = 'x';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "FsJ$iEG44E",
          "title": "The Unit Type",
          "instructions": "In Rust, the [Unit](https://doc.rust-lang.org/std/primitive.unit.html) type exists to represent an empty/non\\-meaningful state. All expressions return the unit type unless they otherwise return another value explicitly.The unit type is useful when you need a placeholder to represent a specific state or value, but that particular state or value really has no other significant representation for it \\(such as the generic success or failure of some operation\\).\n\nInitialize the variable `four` in the editor below to the value of the unit type to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The variable `four` should be initialized as the unit type `()` so the code compiles correctly. \", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions, by deafult, return ()\nfn unit_one() {\n  println!(\"Functions return () by default.\");\n}\n\nfn unit_two() -> () {\n  println!(\"Adding a type signature doesn't change it.\");\n}\n\nfn unit_three() -> () {\n  println!(\"We can also return () directly at the end of the function.\");\n\n  ()\n}\n\nlet one = unit_one();\nlet two = unit_two();\nlet three = unit_three();\nlet four: ();\n\n// Assert the same return value\nif one == two && two == three && three == four {\n  println!(\"\\n- In Rust, all unit types are equivalent: () == ()\");\n}",
          "solutionCode": "// Functions, by deafult, return ()\nfn unit_one() {\n  println!(\"Functions return () by default.\");\n}\n\nfn unit_two() -> () {\n  println!(\"Adding a type signature doesn't change it.\");\n}\n\nfn unit_three() -> () {\n  println!(\"We can also return () directly at the end of the function.\");\n\n  ()\n}\n\nlet one = unit_one();\nlet two = unit_two();\nlet three = unit_three();\nlet four: () = ();\n\n// Assert the same return value\nif one == two && two == three && three == four {\n  println!(\"\\n- In Rust, all unit types are equivalent: () == ()\");\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "sLEaTrYvk",
          "title": "Array Primitives",
          "instructions": "Arrays in Rust have a fixed length and contain values of only a single type. Like arrays in other languages, they are zero indexed.\n\nTake a look at the code in the editor. It currently doesn't compile. Can you find the problem and fix it?",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = array_access();\n  assert_eq!(result.len(), 5);\n\n  true\n}\n`;\n\ntest(\"The code should compile and print out all 5 values in the `my_array` array.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn array_access() -> [i8; 5] {\n  // Arrays can be initialized as follows:\n  let my_array: [i8; 5] = [1,2,3,4,5];\n\n  // Array items can be accessed using the index:\n  let one = my_array[1];\n  println!(\"The 1st value in my_array is {}\", one);\n\n  let two = my_array[2];\n  println!(\"The 2nd value in my_array is {}\", two);\n\n  let three = my_array[3];\n  println!(\"The 3rd value in my_array is {}\", three);\n\n  let four = my_array[4];\n  println!(\"The 4th value in my_array is {}\", four);\n\n  let five = my_array[5];\n  println!(\"The 5th value in my_array is {}\", five);\n\n  my_array\n}\n\narray_access();",
          "solutionCode": "fn array_access() -> [i8; 5] {\n  // Arrays can be initialized as follows:\n  let my_array: [i8; 5] = [1,2,3,4,5];\n\n  // Array items can be accessed using the index:\n  let one = my_array[0];\n  println!(\"The 1st value in my_array is {}\", one);\n\n  let two = my_array[1];\n  println!(\"The 2nd value in my_array is {}\", two);\n\n  let three = my_array[2];\n  println!(\"The 3rd value in my_array is {}\", three);\n\n  let four = my_array[3];\n  println!(\"The 4th value in my_array is {}\", four);\n\n  let five = my_array[4];\n  println!(\"The 5th value in my_array is {}\", five);\n\n  my_array\n}\n\narray_access();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "sCOekMaC@",
          "title": "Array Indexing",
          "instructions": "The last challenge demonstrated something important: The Rust compiler checks for invalid array index access at compile time. If you have an array of length 3 and you try to access the item at index 10 this will fail at the compile step \\- assuming the compiler knows the value of the index you are trying to access at that step.\n\nIf it does not, i.e. if that value is only known at runtime, the program will _panic\\._ Take a look at the editor to see what we mean.\n\nThe code compiles, but fails at runtime. To fix this issue, update the while loop condition to stop at the length of the array. You can find the length of an array with the `.len` method\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and run without any runtime errors\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * When this code is run, it will compile but produce a runtime panic.\n */\nfn runtime_array_access() {\n  let array: [i8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  let mut index = 0;\n\n  while index < 11 {\n    let value = array[index];\n    println!(\"The value at index {} is: {}\", index, value);\n    index = index + 1;\n  }\n}\n\nruntime_array_access();",
          "solutionCode": "/**\n * When this code is run, it will compile but produce a runtime panic.\n */\nfn runtime_array_access() {\n  let array: [i8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  let mut index = 0;\n\n  while index < array.len() {\n    let value = array[index];\n    println!(\"The value at index {} is: {}\", index, value);\n    index = index + 1;\n  }\n}\n\nruntime_array_access();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "niJPS3cRO",
          "title": "Tuples",
          "instructions": "Tuples are the second primitive compound type available in Rust. They are similar to arrays in that they have a fixed length but different in that the items they contain may be of different types.\n\nIn the code below we define a new tuple type which contains several values, including an array. Update the function `tuple_demonstration` to return just this array from the provided tuple. Note that tuples are indexed just like arrays, but to access a tuple item by index you use a dot syntax, e.g. `my_tuple.2` would return the item at the 2nd index in `my_tuple`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let array = [7,3,5];\n  let example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\n  let result = tuple_demonstration(example_tuple);\n  assert_eq!(array, result);\n  true\n}\n`;\n\ntest(\"The `tuple_demonstration` function should return the array in the `CustomTuple` argument it is provided.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Tuple types can be declared like this:\ntype CustomTuple = (&'static str, bool, bool, u32, [i8; 3]);\n\nfn tuple_demonstration(custom_tuple: CustomTuple) -> [i8; 3] {  \n  println!(\"Tuple: {:?}\", custom_tuple);\n}\n\nlet array: [i8; 3] = [1, 2, 3];\n// A new tuple can be initialized directly like this:\nlet example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\ntuple_demonstration(example_tuple);",
          "solutionCode": "// Tuple types can be declared like this:\ntype CustomTuple = (&'static str, bool, bool, u32, [i8; 3]);\n\nfn tuple_demonstration(custom_tuple: CustomTuple) -> [i8; 3] {  \n  println!(\"Tuple: {:?}\", custom_tuple);\n\n  custom_tuple.4\n}\n\nlet array: [i8; 3] = [1, 2, 3];\n// A new tuple can be initialized directly like this:\nlet example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\ntuple_demonstration(example_tuple);",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "S3BmBYNCP",
      "title": "Rust Fundamentals",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "upbaggZVb",
          "title": "Variables and Functions",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will cover variables and functions in more detail. These challenges should be fairly quick since the previous module included many examples of variables and functions. Nevertheless, it should be helpful to explicitly mention a few points here."
        },
        {
          "type": "rust",
          "id": "C55Lmpb@L",
          "title": "Immutable by Default",
          "instructions": "In Rust, variables are immutable by default. This means you cannot change the value after declaration. Of course, sometimes you might want to change the value later on, so you can opt\\-in to mutability using the `mut` keyword\\.\n\nUpdate the code in the editor by making variables mutable. The `immutable_by_default` function should be invoked twice.\n\n> Use the `mut` keyword intentionally. When you see a mutable variable, it means the original programmer _intended_ for that variable to change later on. This conveys useful information, and it is important it is an opt\\-in behavior. \n> \n> Use `mut` only when you need it.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: u128 = immutable_by_default(807);\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `immutable_by_default` function should be invoked twice.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const matched = CODE_STRING.replace(/ /g, \"\").match(\n    /immutable_by_default\\(/g\n  ).length;\n  expect(matched).toBe(3);\n});\n\ntest(\"Two variables should be made mutable using the `mut` keyword.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const matched = CODE_STRING.replace(/ /g, \"\").match(/letmut/g).length;\n  expect(matched).toBe(2);\n});\n",
          "videoUrl": "",
          "starterCode": "fn immutable_by_default(input: u128) -> u128 {\n  let value = 52;\n\n  value = input;\n\n  value\n}\n\nlet result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "solutionCode": "fn immutable_by_default(input: u128) -> u128 {\n  let mut value = 52;\n\n  value = input;\n\n  value\n}\n\nlet mut result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "dMMvFPvNS",
          "title": "Variable Shadowing",
          "instructions": "While variables are immutable by default, it is in fact possible to change immutable variables values by redeclaring them with the same name. This is called variable shadowing. To shadow a variable, you simply declare it again using the `let` keyword\\.\n\nThe code in the editor tries to update the `name` variable\\. Allow this to work by using variable shadowingâ€”do not use the `mut` keyword\\.\n\n> Shadowing, although perhaps a bit unusual, is useful when working with values which need to be updated or redeclared \\(even, changing to a different type\\) throughout a program. Specifically, shadowing helps the programmer avoid coming up with a new name for the variable.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `name` variable should be shadowing and printed out for a total of 5 times.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const count = CODE_STRING.replace(/ /g, \"\").match(/letname=/g).length;\n  expect(count).toBe(5);\n});\n",
          "videoUrl": "",
          "starterCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "solutionCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  let name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  let name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  let name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  let name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ohaohA5x9",
          "title": "Constants",
          "instructions": "You can also declare constants in Rust. Constants are like variables but their value is fixed at compile time and not subject to change throughout the life of the program. Constants are declared with the `const` keyword, are always immutable, and must have an explicit type annotation. Constants can be declared in any scope, including the global scope. They are ideal for global values which do not change throughout the life of a program.\n\nAdd type annotations to the constants in the editor so the code compiles.\n\n> For the string type, try to use the string slice reference type `&str`. We will cover strings more in detail later.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let x = DEBUG;\n  let y = MAX_HEIGHT;\n  let z = NAME;\n\n  true\n}\n`;\n\ntest(\"The three constants should be initialized correctly and the code should compile.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const DEBUG = false;\n\nconst MAX_HEIGHT = 52;\n\nconst NAME = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "solutionCode": "const DEBUG: bool = false;\n\nconst MAX_HEIGHT: i64 = 52;\n\nconst NAME: &str = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "o0UpOqzg3",
          "title": "Functions",
          "instructions": "So far we've seen several functions, so you should have the basics down by now. But there is one important function we have not seen yet: the `main` function\\. Since we are working within the Pairwise workspace, some of the details of how to setup, compile, and run Rust code are hidden away \\(for now...\\).\n\nIn Rust, the entry point to a program is a `main` function\\. This is where everything starts, and it must be defined.\n\nIn the editor below, define a `main` function which returns the boolean `true`.\n\n> In the Pairwise workspace, we are taking your code from the editor below and wrapping it in the other code required to run a Rust program, e.g. the `main` function, and the test code for each challenge. This is all being compiled and run with the output captured to determine if you passed or failed the tests.\n> \n> The purpose of this is to get you off the ground quickly writing Rust code without having to deal with setup tasks like downloading the Rust compiler and learning how to use it \\(although, this is not that hard\\).\n> \n> But don't worry\\! We will cover these topics later in this course and by the end you will be compiling your own Rust code like a pro.\n\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = main();\n\n  return result;\n}\n`;\n\ntest(\"The `main` function should be defined and should return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "// Write your code here\nfn  main() -> bool {\n  true\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "eTZNP3td8",
          "title": "Returning Values from Functions",
          "instructions": "There are two ways to return values from functions, using the explicit `return` keyword and also by just writing the final value as an expression with no semicolon. \"Early\" returns are often written using the `return` keyword while it is somewhat standard for a return at the end of the function to be written as a standalone expression.\n\nThe `different_ways_to_return` contains three expressions for different conditions. Modify the function to return these three expressions. Try to return the final expression without using the `return` keyword\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  assert_eq!(different_ways_to_return(-5), \"Value is less than zero\");\n  assert_eq!(different_ways_to_return(0), \"Value is zero\");\n  assert_eq!(different_ways_to_return(5), \"Value is greater than zero\");\n\n  true\n}\n`;\n\ntest(\"The `different_ways_to_return` function should compile and return different string slices based on the input value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Don't worry about this 'static on the return parameter yet.\n// This is a lifetime parameter, which instructs the Rust compiler\n// how long the return value can live.\nfn different_ways_to_return(val: i32) -> &'static str {\n  // We will see more on if/else statements soon\n  if val == 0 {\n    \"Value is zero\";\n  }\n\n  if val < 0 {\n    \"Value is less than zero\";\n  }\n\n  // Final expression is returned from the function,\n  // without the need for a return keyword\n  \"Value is greater than zero\";\n}\n\nprintln!(\"Checking -5: {:?}\", different_ways_to_return(-5));\nprintln!(\"Checking 0: {:?}\", different_ways_to_return(0));\nprintln!(\"Checking +5: {:?}\", different_ways_to_return(5));",
          "solutionCode": "// Don't worry about this 'static on the return parameter yet.\n// This is a lifetime parameter, which instructs the Rust compiler\n// how long the return value can live.\nfn different_ways_to_return(val: i32) -> &'static str {\n  // We will see more on if/else statements soon\n  if val == 0 {\n    return \"Value is zero\";\n  }\n\n  if val < 0 {\n    return \"Value is less than zero\";\n  }\n\n  // Final expression is returned from the function,\n  // without the need for a return keyword\n  \"Value is greater than zero\"\n}\n\nprintln!(\"Checking -5: {:?}\", different_ways_to_return(-5));\nprintln!(\"Checking 0: {:?}\", different_ways_to_return(0));\nprintln!(\"Checking +5: {:?}\", different_ways_to_return(5));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "jLTXZFPZt",
          "title": "Multiply",
          "instructions": "Write a function from scratch to take two `f64` numbers and multiply them together and return the result.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  fn _mult(x: f64, y: f64) -> f64 {\n    x * y\n  }\n\n  let a = 5.231231;\n  let b = 7.912381;\n\n  let result = multiply(a, b);\n  let expected = _mult(a, b);\n  assert_eq!(result, expected);\n\n  true\n}\n`;\n\ntest(\"The `multiply` function should exist and return the result of multiplying its two arguments together.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Your code here",
          "solutionCode": "// Multiple function\nfn multiply(x: f64, y: f64) -> f64 {\n  x * y\n}",
          "content": ""
        },
        {
          "type": "section",
          "id": "@orxFOEdD",
          "title": "Structs and Enums",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust structures \"structs\" are a way to group several related values into a single meaningful group."
        },
        {
          "type": "rust",
          "id": "rONYoxCYV",
          "title": "Struct Definition",
          "instructions": "Struct are defined using the `struct` keyword\\. Like tuples, they can contain data of different types. Unlike tuples they have a much more defined structure which conveys more meaning and makes data access easier.\n\nWe've defined a struct in the editor below representing a rectangle. In the `create_rectangle` function, return a new instance of this struct whose fields match the parameters given to the function. You can create a new instance of a struct by writing its name followed by `{...}` brackets within which you defined the struct fields.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let x: u32 = 5;\n  let y: u32 = 10;\n  let width: u32 = 25;\n  let height: u32 = 50;\n  let rect = create_rectangle(x, y, width, height);\n  assert_eq!(rect.x, x);\n  assert_eq!(rect.y, y);\n  assert_eq!(rect.width, width);\n  assert_eq!(rect.height, height);\n\n  true\n}\n`;\n\ntest(\"The `create_rectangle` function should return a new `Rect` struct matching the parameters given to it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn create_rectangle(x: u32, y: u32, width: u32, height: u32) -> Rect {\n  // Write your code here\n}\n\nlet rect = create_rectangle(5, 10, 25, 50);\nprintln!(\"Rectangle Struct: {:?}\", rect);",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn create_rectangle(x: u32, y: u32, width: u32, height: u32) -> Rect {\n  // Write your code here\n  Rect {\n    x,\n    y,\n    width,\n    height\n  }\n}\n\nlet rect = create_rectangle(5, 10, 25, 50);\nprintln!(\"Rectangle Struct: {:?}\", rect);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "rONYaskiU",
          "title": "Create a New Struct",
          "instructions": "Let's get some more practice defining structs. This challenge is similar to the last but here we will start with an empty editor\\! Review the test cases to solve the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let radius: u32 = 51231;\n  let mass: u32 = 97612301731;\n  let inhabitants: u32 = 713231;\n  let planet = create_plant(radius, mass, inhabitants);\n  assert_eq!(planet.radius, radius);\n  assert_eq!(planet.mass, mass);\n  assert_eq!(planet.inhabitants, inhabitants);\n\n  true\n}\n`;\n\ntest(\"A `create_planet` function should exist and return a new `Planet` struct, which has the following `u32` fields: `radius`, `mass`, `inhabitants`. The function signature should accept these three fields, in that order, as parameters to initalize the `Planet` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "#[derive(Debug)]\nstruct Planet {\n  radius: u32,\n  mass: u32,\n  inhabitants: u32,\n}\n\nfn create_planet(radius: u32, mass: u32, inhabitants: u32) -> Planet {\n  // Fields can be initialized directly like this if a variable of\n  // matching type exists in the same scope:\n  let planet = Planet {\n    radius,\n    mass,\n    inhabitants,\n  };\n\n  planet\n}\n\nlet planet = create_planet(791231, 13211231, 1231311);\nprintln!(\"Planet Struct: {:?}\", planet);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "jQdiNPjQJK",
          "title": "Updating Struct Fields",
          "instructions": "How can we update the fields of a struct? Well, you can set them similar to how you would set a variable. Try to complete the function in the editor below.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n  // Returns a boolean representing challenge test status.\n  fn test() -> bool {\n    let rect = Rect {\n    x: 5,\n    y: 5,\n    width: 100,\n    height: 50,\n  };\n\n  let resized = resize_rectangle(rect, 500, 500);\n  assert_eq!(resized.width, 500);\n  assert_eq!(resized.height, 500);\n\n  true\n}\n`;\n\ntest(\"The `original_rect` function should return a struct matching the `original_rect` struct it receives as an argument but with update `width` and `height` properities.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn resize_rectangle(original_rect: Rect, new_width: u32, new_height: u32) -> Rect { \n  // Write your code here:\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nprintln!(\"[1] Original Rectangle: {:?}\", rect);\nlet resized = resize_rectangle(rect, 500, 500);\nprintln!(\"[2] Resized Rectangle: {:?}\", resized);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\n// First, we must make the original_rect argument mutable,\n// in order to change it. We could also, alternatively, create\n// a new rectangle in the function body and return that instead.\nfn resize_rectangle(mut original_rect: Rect, new_width: u32, new_height: u32) -> Rect { \n  // We can access and update the fields directly like this:\n  original_rect.width = new_width;\n  original_rect.height = new_height;\n  original_rect\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nprintln!(\"[1] Original Rectangle: {:?}\", rect);\nlet resized = resize_rectangle(rect, 500, 500);\nprintln!(\"[2] Resized Rectangle: {:?}\", resized);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "OsWEvgL6e",
          "title": "Struct Update Syntax",
          "instructions": "There is a special syntax for copying existing struct fields onto a new struct, which is useful when creating or updating structs. This syntax is the `..` struct update syntax and it will \"spread\" all the struct fields of one struct onto another. Consider this code:\n\n```\n// Create an item, using all the fields from an\n// existing 'other_item' and set a new id field.\nlet item = Item {\n    // Set the id field\n    id: get_random_id(),\n    // Include whatever other fields are in the\n    // other_item (imagine it is defined above)\n    // which are NOT already set above.\n    //\n    // Note that this syntax uses two dots and no\n    // comma at the end.\n    ..other_item\n}\n\n```\n\nIn the editor below, use the `..` struct update syntax to complete the `create_additional_tree_in_forest` function\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let forest = String::from(\"Pinegrove\");\n  let caretaker = String::from(\"Eddie\");\n  let tree_type = TreeTypes::Cedar;\n  let tree = Tree {\n    tree_type,\n    forest: String::from(&forest),\n    caretaker: String::from(&caretaker),\n    height: 52,\n    number_of_branches: 217,\n    number_of_bird_nests: 8,\n  };\n\n  let result = create_additional_tree_in_forest(tree, 88, 312, 14);\n  assert_eq!(result.forest, forest);\n  assert_eq!(result.caretaker, caretaker);\n  assert_eq!(result.height, 88);\n  assert_eq!(result.number_of_branches, 312);\n  assert_eq!(result.number_of_bird_nests, 14);\n\n  true\n}\n`;\n\ntest(\"The `create_additional_tree_in_forest` function should return a `Tree` struct matching the struct given to it with the additional fields provided as parameters.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum TreeTypes {\n  Sycamore,\n  Cedar,\n  Oak,\n  Redwood,\n  Pine,\n}\n\n#[derive(Debug)]\nstruct Tree {\n  tree_type: TreeTypes,\n  forest: String,\n  caretaker: String,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n}\n\nfn create_additional_tree_in_forest(\n  tree: Tree,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n  ) -> Tree {\n    // Write your code here\n};\n\nlet tree = Tree {\n  tree_type: TreeTypes::Cedar,\n  forest: String::from(\"Pinegrove\"),\n  caretaker: String::from(\"Eddie\"),\n  height: 52,\n  number_of_branches: 217,\n  number_of_bird_nests: 6,\n};\n\nprintln!(\"Original Tree: {:?}\", tree);\nlet result = create_additional_tree_in_forest(tree, 88, 312, 14);\nprintln!(\"New Tree: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nenum TreeTypes {\n  Sycamore,\n  Cedar,\n  Oak,\n  Redwood,\n  Pine,\n}\n\n#[derive(Debug)]\nstruct Tree {\n  tree_type: TreeTypes,\n  forest: String,\n  caretaker: String,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n}\n\nfn create_additional_tree_in_forest(\n  tree: Tree,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n  ) -> Tree {\n    Tree {\n      height,\n      number_of_branches,\n      number_of_bird_nests,\n      ..tree\n    }\n}\n\nlet tree = Tree {\n  tree_type: TreeTypes::Cedar,\n  forest: String::from(\"Pinegrove\"),\n  caretaker: String::from(\"Eddie\"),\n  height: 52,\n  number_of_branches: 217,\n  number_of_bird_nests: 6,\n};\n\nprintln!(\"Original Tree: {:?}\", tree);\nlet result = create_additional_tree_in_forest(tree, 88, 312, 14);\nprintln!(\"New Tree: {:?}\", result);",
          "content": ""
        },
        {
          "type": "section",
          "id": "@VZT4$txv",
          "title": "Strings",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In Rust strings are a more complex topic than in many other languages where you simply have the notion of a \"string\" type. In Rust there are multiple ways to represent strings which we need to spend some time explain."
        },
        {
          "type": "section",
          "id": "5B5@asRy6",
          "title": "Data Structures",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust provides a variety of primitive and advanced data structures to work with. We will explore the most common and useful of these in this module, such as:\n\n* Tuples\n* Arrays\n* Enums\n* Vectors\n* Structs\n* Hash Maps\n\n"
        },
        {
          "type": "section",
          "id": "owXHK17s4",
          "title": "Control Flow",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust contains many of the common control flow structures you will be familiar with from other programming languages. We will cover those in this section, along with a few other patterns which are unique and common to Rust, such as:\n\n* If/else statements\n* Iterators and loops\n* Match statements\n\n"
        },
        {
          "type": "section",
          "id": "R4TolzmG5",
          "title": "Rust's Result and Option Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust contains two well known and powerful types the `Result` and `Option` types which are used to model values which optionally may be in an error/failure state \\(the `Result` type\\) or in an optional/not\\-present state \\(the `Option` type\\). These types are so prevalent and important that we have given them their own section of challenges here."
        },
        {
          "type": "section",
          "id": "ITJBLJQnl",
          "title": "Generics, Traits and Lifetimes",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "PnCi8hB8E",
          "title": "Error Handling",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "JAYJEcvrv",
          "title": "Testing",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "usDs33hMCZ",
          "title": "Modules, Packages and Crates",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "section",
          "id": "RZAimitGF",
          "title": "Cargo",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        }
      ]
    },
    {
      "id": "AX04ZC5H8",
      "title": "Ownership and Borrowing",
      "free": false,
      "challenges": []
    },
    {
      "id": "zfbfBa6nP",
      "title": "Macros",
      "free": false,
      "challenges": []
    },
    {
      "id": "LeikXungd",
      "title": "Smart Pointers",
      "free": false,
      "challenges": []
    },
    {
      "id": "HiDVdMr4I",
      "title": "Concurrency",
      "free": false,
      "challenges": []
    },
    {
      "id": "XT73AIuM5",
      "title": "Additional Features",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "axPeNlByhG",
          "title": "Additional Rust Features",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "This section will cover additional Rust features, such as:\n\n* Functional programming techniques in Rust\n* Object\\-oriented programming techniques in Rust\n* Unsafe code\n* Some advanced features\n\n"
        }
      ]
    },
    {
      "id": "krVVmQd$S",
      "title": "Practice Challenges",
      "challenges": [
        {
          "type": "section",
          "id": "32C7HdQle",
          "title": "Practice Challenges",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this next section \\(and final section before the projects\\) we will cover various Rust programming challenges which are intended to give your more experience writing and working with Rust syntax, data structures, and functions."
        },
        {
          "id": "Flaxrbchq",
          "type": "rust",
          "title": "String Sub String",
          "instructions": "Write a function `string_sub_string` which accepts two string inputs and returns `true` if the second is a substring of the first. For instance, `\"plan\"` is a substring of `\"planned\"`, but not a substring of `\"globe\"`.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = string_sub_string(\"\", \"\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plannede\");\n      if result != false {\n        return false;\n      }\n\n      result = string_sub_string(\"planned\", \"planned\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plan\");\n      if result != true {\n        return false;\n      }\n\n      result = string_sub_string(\"as89df709asfuoiasudfisaodfusadFSAFASFASDf\", \"sfuoiasudfisaodfusadFSAF\");\n      if result != true {\n        return false;\n      }\n      \n      return true;\n    }\n  `;\n\ntest(\"`string_sub_string` should return `true` if the second input argument is a substring of the first.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n",
          "solutionCode": "// Determine if a string is a valid substring of another\nfn string_sub_string(a: &str, b: &str) -> bool {\n  // Immediately return true if strings are simply equal, including empty strings\n  if a == b {\n    return true;\n  }\n\n  // Convert both strings to vectors\n  let mut a_vec = Vec::new();\n  let mut b_vec = Vec::new();\n\n  for c in a.chars() {\n    a_vec.push(c);\n  }\n\n  for c in b.chars() {\n    b_vec.push(c);\n  }\n\n  // Ensure the first is longer than the second\n  if b_vec.len() > a_vec.len() {\n    return false;\n  }\n\n  // Iterate through the first string vector until the first character\n  // matches the first character of the second. If it does, try to\n  // iterate forward from there and match all adjacent characters.\n  let mut index = 0;\n  while index < a_vec.len() {\n    let a_value = a_vec[index];\n    let b_value = b_vec[0];\n\n    if a_value == b_value {\n      let mut a_index = index + 1;\n      let mut b_index = 1;\n      let mut valid = true;\n\n      while b_index < b_vec.len() {\n        if a_vec[a_index] == b_vec[b_index] {\n          a_index = a_index + 1;\n          b_index = b_index + 1;\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if valid {\n        return true;\n      }\n    }\n    index = index + 1;\n  }\n\n  // If you reached here and found no valid match, there is none.\n  return false;\n}\n",
          "content": ""
        },
        {
          "id": "y4tgWGLOS",
          "type": "rust",
          "title": "Fill a Vector",
          "instructions": "In Rust you can use a [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html) struct to represent a list of items. Write a function fillVector which takes a single integer input parameter and returns a vector with containing all of the integers up to and including the input parameter.\n\n```\nfill_vector(10) // -> Vec[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n```\n\n**Note: **You can assume the input will not be negative, but it may be zero.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      fn fill_vector_solution(max: i64) -> Vec<i64> {\n        let mut current = 0;\n        let mut v = Vec::new();\n        while current <= max {\n          v.push(current);\n          current = current + 1;\n        }\n        v\n      }\n\n      fn compare_vectors(v1: Vec<i64>, v2: Vec<i64>) -> bool {\n        let mut index = 0;\n        for x in &v1 {\n          let other = &v2[index];\n          if x != other {\n            return false;\n          }\n\n          index = index + 1;\n        }\n        true\n      }\n      \n      fn compare(value: i64) -> bool {\n        let mut result = fill_vector(value);\n        let mut expected = fill_vector_solution(value);\n        if compare_vectors(result.to_owned(), expected.to_owned()) == false {\n          return false;\n        }\n        true\n      }\n      \n      let mut value = 5;\n      let values = vec![0, 1, 6, 12, 15, 26, 88, 900];\n      for v in values {\n        if compare(v) == false {\n          return false;\n        }\n      }\n      true\n    }\n  `;\n\ntest(\"`fill_vector` should accept an integer argument and return a new vector of all of the integers up to and including that integer argument.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Fill up a vector",
          "solutionCode": "// Fill up a vector\nfn fill_vector(max: i64) -> Vec<i64> {\n  let mut current = 0;\n  let mut result = Vec::new();\n  while current <= max {\n    result.push(current);\n    current = current + 1;\n  }\n  return result;\n}\n",
          "content": ""
        },
        {
          "id": "sLQQLy12e",
          "type": "rust",
          "title": "Create a Struct",
          "instructions": "Rust [structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html) provide a way to represent more complex data structures. For this challenge, create a struct to represent a person. The struct should have the following fields: `name`, `age`, `height`, and `siblings`. These should be of type, string, integer, integer, and boolean, respectively.\n\nWrite a function `create_person` which accepts the above values as parameters and returns a new `Person` struct\\.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut person = create_person(String::from(\"Sean\"), 31, 82, true);\n      if person.name.eq(\"Sean\") != true {\n        return false\n      }\n      if person.age != 31 {\n        return false;\n      }\n      if person.height != 82 {\n        return false;\n      }\n      if person.siblings != true {\n        return false;\n      }\n\n       person = create_person(String::from(\"Zakaria\"), 717, 929, false);\n      if person.name.eq(\"Zakaria\") != true {\n        return false\n      }\n      if person.age != 717 {\n        return false;\n      }\n      if person.height != 929 {\n        return false;\n      }\n      if person.siblings != false {\n        return false;\n      }\n\n      true\n    }\n  `;\n\ntest(\"`create_person` should accept the arguments `name`, `age`, `height`, and `siblings` and return a new `Person` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here:",
          "solutionCode": "struct Person {\n  name: String,\n  age: u16,\n  height: u16,\n  siblings: bool,\n}\n\nfn create_person(name: String, age: u16, height: u16, siblings: bool) -> Person {\n  Person {\n    name,\n    age,\n    height,\n    siblings,\n  }\n}\n",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "uZZsKk7083",
      "title": "Projects",
      "challenges": [
        {
          "type": "section",
          "id": "tVYCXZbIl",
          "title": "Projects",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will build several projects in Rust to round off your Rust learning experience."
        },
        {
          "type": "project",
          "id": "NCoNBdnxF",
          "title": "Command Line Key Value Store",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "For this project we will build a simple key value store which can be used on the command line.\n\nWrite a Rust program to store key value pairs with the following command line API:\n\n* Set an item: `cargo run set foo bar`.\n* Get an item: `cargo run get foo`.\n* Get all items: `cargo run getAll`.\n* Remove an item: `cargo remove foo`.\n* Remove all items: `cargo removeAll`.\n\n\nYour program will store the cache in memory while it is running. For a bonus, consider adding input validation and testing for your project. For another bonus, consider having your program write the cache to disk to be able to persist cache state between sessions."
        },
        {
          "type": "project",
          "id": "NV9DixvF7",
          "title": "Key Value Web Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Here we will expand on our key value command line utility by writing a Rust server with an API for the same functionality.\n\nBuild a server in Rust which exposes a REST API to allow users to set, get, and remove items in a key value store. Unlike the command line utility, this should support set arbitrary JSON data in the `value` field for cache entries. The API should also support retrieving all existing entries, and remove all existing entries.\n\nBonus points:\n\n* Consider adding validation for requests.\n* Consider how you might add tests for your server.\n* Consider how you might add an authentication layer, or separate expose the functionality to multiple different users \\(e.g. N users consume your API, but they each access separate caches\\).\n* Consider how you might persist the cache data more permanently using a database.\n\n"
        },
        {
          "type": "project",
          "id": "UticrWdb1",
          "title": "Command Line Tic Tac Toe Game",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Let's create a Tic Tac Toe game in Rust. This will be similar to the Tic Tac Toe project in the FullStack TypeScript curriculum, if you completed that previously. Here, however, the game will be totally opened ended for you to design as you see fit. The main requirements are:\n\n* Players can play the computer in Tic Tac Toe.\n* The game will randomly choose who plays first.\n* The computer will choose a random move each round.\n* The game will obey the ordinary rules of Tic Tac Toe, and declare a winner or tie at the end.\n* Once a game completes, the player will have the option to play again.\n* For a given session, the game should get track of overall wins/losses.\n\n\nFor your program, consider edge cases, handling errors, and how you can add tests to verify the game behavior is correct. Good luck\\!\n"
        },
        {
          "type": "project",
          "id": "s2Ph4e5cp",
          "title": "Real Time Chat Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Build a web server using Rust which provides a real time chat functionality. For the basic implementation, consider a single chatroom which anyone can join and post messages to. The server forwards messages in real time to all connected clients.\n\nFor client implementations, you may disregard implementing a client \\(if you wish\\), or build a simple UI web client, or build a command line client in Rust which allows you to post a message to the chat server and can also subscribe to the server and print out any new messages as they arrive.\n\nFor more challenges, consider how you might change this to persist messages using a database and allow for more advanced chat features \\(e.g. direct messages between users, replies/threads, reactions, etc.\\). Finally, consider how you might test your project."
        }
      ],
      "free": false
    },
    {
      "id": "aUHE3cOCli",
      "title": "Rust in Production",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "663qF3qvRe",
          "title": "Rust Applications",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "What is Rust actually used for in the real world, and what can you do with your Rust skills?"
        }
      ]
    }
  ]
}