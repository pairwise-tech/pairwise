{
  "free": true,
  "price": 0,
  "premiumPrice": 0,
  "id": "alosiqu45",
  "title": "Rust",
  "description": "Rust is a statically typed, multi paradigm programming language which excels at performance and safety.",
  "modules": [
    {
      "id": "alosiuqwk",
      "title": "Rust Basics",
      "challenges": [
        {
          "id": "1UMWYNFnEH",
          "type": "section",
          "title": "The Rust Language",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined.\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "[Rust](https://doc.rust-lang.org/rust-by-example/index.html) is a powerful programming language which offers the speed of a compiled language like C\\+\\+ but with many of the abstractions and safety guarantees present in higher level languages. It does this with the help of a sophisticated compiler system.\n\nFirst we will start with 3 intro challenges which are intended to highlight some of the basics of Rust and give you a quick onboarding to writing some Rust code.\n\nProceed to the next challenge to begin\\!"
        },
        {
          "id": "S@Ghw6X75",
          "type": "rust",
          "title": "Intro to Rust",
          "instructions": "Complete the function in the editor which adds two numbers together. [Rust](https://www.rust-lang.org) is a fairly new programming language which is growing rapidly in popularity. Rust famously tries to provide the speed of a low level compiled language with the productivity of a richly featured high level language.",
          "testCode": "test(\"The `add` function should exist and add two numbers together.\", async () => {\n  const RUST_CODE_STRING = __user_code_string__;\n\n  const RUST_TEST_STRING = `\n    fn test() -> bool {\n      let mut result = add(10, 5);\n      let mut expected = 15;\n      if result != expected {\n          return false;\n      }\n\n      result = add(100, 200);\n      expected = 300;\n      if result != expected {\n          return false;\n      }\n\n      result = add(10, 25);\n      expected = 35;\n      if result != expected {\n          return false;\n      }\n\n      result = add(-15, 15);\n      expected = 0;\n      if result != expected {\n          return false;\n      }\n\n      result = add(1000, -2000);\n      expected = -1000;\n      if result != expected {\n          return false;\n      }\n\n      true\n    }\n  `;\n\n  const result = await executeRustChallengeTests(\n    RUST_CODE_STRING,\n    RUST_TEST_STRING\n  );\n\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A function to add two numbers together\nfn add(a: i32, b: i32) -> i32 {\n  // Your code here\n}\n",
          "solutionCode": "// Write an add function using Rust\nfn add(a: i32, b: i32) -> i32 {\n  a + b\n}\n",
          "content": ""
        },
        {
          "id": "Qug@7dDI$",
          "type": "rust",
          "title": "Variable Mutability",
          "instructions": "In Rust values are immutable by default. You have to opt\\-in to mutability. You can do this in variable declarations using the `mut` keyword\\. The `cost` integer is defined in the editor below. Next, we try to change this valueâ€”but this code doesn't compile. Fix the problem by making the variable mutable.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let result = get_cost();\n      if result != 500 {\n        return false;\n      }\n\n      return true;\n    }\n  `;\n\ntest(\"The `cost` variable should be mutable and equal to `500`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  if (!CODE_STRING.includes(\"let mut cost\")) {\n    throw new Error(\"cost must be mutable.\");\n  }\n\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_cost() -> i32 {\n  let cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "solutionCode": "fn get_cost() -> i32{\n  let mut cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "EknAkk16W",
          "title": "Rust's Result Type",
          "instructions": "Some of the most commonly used and powerful types in Rust are the [Option](https://doc.rust-lang.org/rust-by-example/std/option.html) and [Result](https://doc.rust-lang.org/rust-by-example/error/result.html) type\\. These types allow you to represent values that may be in one of two potential states, i.e. \"some\" or \"none\" in the case of the `Option` type and \"valid/ok\" or \"error/failure\" in the case of the `Result` type\\.\n\nThe application of these types in Rust combined with the strictness of the Rust compiler are intended to create a programming experience where all of the \"null point exception\" and \"cannot read property of undefined\" classes of errors are simply not possible because of extensive type checking.\n\nIn the editor below, we have some simple code which explores usage of the Result type. You will see the `is_number_valid` which returns a `Result`. Your job is to add a conditional `if` clause to this function which returns the valid Result, an \"ok\" [unit type](https://doc.rust-lang.org/std/primitive.unit.html), if the provided `num` parameter is less than 25.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = true;\n\n      let mut fn_result = is_number_valid(5);\n      match fn_result {\n        Ok(()) => (),\n        Err(e) => {\n          result = false;\n        }\n      }\n\n      fn_result = is_number_valid(50);\n      match fn_result {\n        Ok(()) => {\n          result = false;\n        },\n        Err(e) => (),\n      }\n      \n      return result;\n    }\n  `;\n\ntest(\"The `is_number_valid` function should return a Result unit type `()` if the provided input is less than 25, or an `Err` type otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  // Your code here\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(50);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(5);\ncheck_result(invalid);",
          "solutionCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  if num < 25 {\n    return Ok(())\n  }\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(15);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(50);\ncheck_result(invalid);",
          "content": ""
        },
        {
          "type": "section",
          "id": "6w$q0NkrZ",
          "title": "Primitives and Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust is a fully typed language so our discussion should begin by defining the basic data primitives and types you have to work with. That will be the topic of this section."
        },
        {
          "type": "rust",
          "id": "d8WItf9JW",
          "title": "Rust Integer Types",
          "instructions": "Initialize the `my_int` value in `get_integer` function in the editor to return a valid `i8` integer, an 8\\-bit signed integer. Rust supports multiple different integer data types, from 8 to 128 bit, each signed or unsigned. A \"signed\" integer is one that may be positive of negative, e.g. `-4` is a signed integer. Unsigned integers are assumed to be positive.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let n = get_integer();\n  let result = 5 + n;\n  let original = result - 5;\n\n  if n != original {\n    return false\n  }\n\n  return true\n}\n`;\n\ntest(\"The `my_int` variable in the `get_integer` should be correctly initialized.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "solutionCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8 = 15;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "z6DMvoh1T",
          "title": "Integer Type Sizes",
          "instructions": "The size of an integer data type refers to how much memory will be required to store the value, and hence, this imposes a limit on the size of the particular integer. An `i8` value, for instance, occupies 8 bits of space and can range from `-128` to `127`.\n\nThe editor below has a function `check_integer_i8_range` which uses the public `i8` constant `MIN` and `MAX` values and the `assert_eq!` macro \\(don't worry, more on all this later\\) to check that an input range falls within the bounds of an acceptable `i8` integer\\.\n\nUpdate the invocation of `check_integer_i8_range` so that the code compiles. Notice how the compiler is about to detect that the current code will fail, and even gives you a helpful hint\\!",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  check_integer_i8_range(-128, 127);\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `check_integer_i8_range` function should be invoked with the minimum and maximum bounds of an `i8` integer.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(\n    CODE_STRING.replace(/ /g, \"\").includes(\"check_integer_i8_range(-128,127)\")\n  ).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-500, 500);\n",
          "solutionCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-128, 127);\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "32C7HdQle",
          "title": "Practice Challenges",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this next section \\(and final section before the projects\\) we will cover various Rust programming challenges which are intended to give your more experience writing and working with Rust syntax, data structures, and functions."
        },
        {
          "id": "Flaxrbchq",
          "type": "rust",
          "title": "String Sub String",
          "instructions": "Write a function `string_sub_string` which accepts two string inputs and returns `true` if the second is a substring of the first. For instance, `\"plan\"` is a substring of `\"planned\"`, but not a substring of `\"globe\"`.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = string_sub_string(\"\", \"\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plannede\");\n      if result != false {\n        return false;\n      }\n\n      result = string_sub_string(\"planned\", \"planned\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plan\");\n      if result != true {\n        return false;\n      }\n\n      result = string_sub_string(\"as89df709asfuoiasudfisaodfusadFSAFASFASDf\", \"sfuoiasudfisaodfusadFSAF\");\n      if result != true {\n        return false;\n      }\n      \n      return true;\n    }\n  `;\n\ntest(\"`string_sub_string` should return `true` if the second input argument is a substring of the first.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n",
          "solutionCode": "// Determine if a string is a valid substring of another\nfn string_sub_string(a: &str, b: &str) -> bool {\n  // Immediately return true if strings are simply equal, including empty strings\n  if a == b {\n    return true;\n  }\n\n  // Convert both strings to vectors\n  let mut a_vec = Vec::new();\n  let mut b_vec = Vec::new();\n\n  for c in a.chars() {\n    a_vec.push(c);\n  }\n\n  for c in b.chars() {\n    b_vec.push(c);\n  }\n\n  // Ensure the first is longer than the second\n  if b_vec.len() > a_vec.len() {\n    return false;\n  }\n\n  // Iterate through the first string vector until the first character\n  // matches the first character of the second. If it does, try to\n  // iterate forward from there and match all adjacent characters.\n  let mut index = 0;\n  while index < a_vec.len() {\n    let a_value = a_vec[index];\n    let b_value = b_vec[0];\n\n    if a_value == b_value {\n      let mut a_index = index + 1;\n      let mut b_index = 1;\n      let mut valid = true;\n\n      while b_index < b_vec.len() {\n        if a_vec[a_index] == b_vec[b_index] {\n          a_index = a_index + 1;\n          b_index = b_index + 1;\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if valid {\n        return true;\n      }\n    }\n    index = index + 1;\n  }\n\n  // If you reached here and found no valid match, there is none.\n  return false;\n}\n",
          "content": ""
        },
        {
          "id": "y4tgWGLOS",
          "type": "rust",
          "title": "Fill a Vector",
          "instructions": "In Rust you can use a [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html) struct to represent a list of items. Write a function fillVector which takes a single integer input parameter and returns a vector with containing all of the integers up to and including the input parameter.\n\n```\nfill_vector(10) // -> Vec[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n```\n\n**Note: **You can assume the input will not be negative, but it may be zero.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      fn fill_vector_solution(max: i64) -> Vec<i64> {\n        let mut current = 0;\n        let mut v = Vec::new();\n        while current <= max {\n          v.push(current);\n          current = current + 1;\n        }\n        v\n      }\n\n      fn compare_vectors(v1: Vec<i64>, v2: Vec<i64>) -> bool {\n        let mut index = 0;\n        for x in &v1 {\n          let other = &v2[index];\n          if x != other {\n            return false;\n          }\n\n          index = index + 1;\n        }\n        true\n      }\n      \n      fn compare(value: i64) -> bool {\n        let mut result = fill_vector(value);\n        let mut expected = fill_vector_solution(value);\n        if compare_vectors(result.to_owned(), expected.to_owned()) == false {\n          return false;\n        }\n        true\n      }\n      \n      let mut value = 5;\n      let values = vec![0, 1, 6, 12, 15, 26, 88, 900];\n      for v in values {\n        if compare(v) == false {\n          return false;\n        }\n      }\n      true\n    }\n  `;\n\ntest(\"`fill_vector` should accept an integer argument and return a new vector of all of the integers up to and including that integer argument.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Fill up a vector",
          "solutionCode": "// Fill up a vector\nfn fill_vector(max: i64) -> Vec<i64> {\n  let mut current = 0;\n  let mut result = Vec::new();\n  while current <= max {\n    result.push(current);\n    current = current + 1;\n  }\n  return result;\n}\n",
          "content": ""
        },
        {
          "id": "sLQQLy12e",
          "type": "rust",
          "title": "Create a Struct",
          "instructions": "Rust [structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html) provide a way to represent more complex data structures. For this challenge, create a struct to represent a person. The struct should have the following fields: `name`, `age`, `height`, and `siblings`. These should be of type, string, integer, integer, and boolean, respectively.\n\nWrite a function `create_person` which accepts the above values as parameters and returns a new `Person` struct\\.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut person = create_person(String::from(\"Sean\"), 31, 82, true);\n      if person.name.eq(\"Sean\") != true {\n        return false\n      }\n      if person.age != 31 {\n        return false;\n      }\n      if person.height != 82 {\n        return false;\n      }\n      if person.siblings != true {\n        return false;\n      }\n\n       person = create_person(String::from(\"Zakaria\"), 717, 929, false);\n      if person.name.eq(\"Zakaria\") != true {\n        return false\n      }\n      if person.age != 717 {\n        return false;\n      }\n      if person.height != 929 {\n        return false;\n      }\n      if person.siblings != false {\n        return false;\n      }\n\n      true\n    }\n  `;\n\ntest(\"`create_person` should accept the arguments `name`, `age`, `height`, and `siblings` and return a new `Person` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here:",
          "solutionCode": "struct Person {\n  name: String,\n  age: u16,\n  height: u16,\n  siblings: bool,\n}\n\nfn create_person(name: String, age: u16, height: u16, siblings: bool) -> Person {\n  Person {\n    name,\n    age,\n    height,\n    siblings,\n  }\n}\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "tVYCXZbIl",
          "title": "Projects",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will build several projects in Rust to round off your Rust learning experience."
        },
        {
          "type": "project",
          "id": "NCoNBdnxF",
          "title": "Command Line Key Value Store",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "For this project we will build a simple key value store which can be used on the command line.\n\nWrite a Rust program to store key value pairs with the following command line API:\n\n* Set an item: `cargo run set foo bar`.\n* Get an item: `cargo run get foo`.\n* Get all items: `cargo run getAll`.\n* Remove an item: `cargo remove foo`.\n* Remove all items: `cargo removeAll`.\n\n\nYour program will store the cache in memory while it is running. For a bonus, consider adding input validation and testing for your project. For another bonus, consider having your program write the cache to disk to be able to persist cache state between sessions."
        },
        {
          "type": "project",
          "id": "NV9DixvF7",
          "title": "Key Value Web Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Here we will expand on our key value command line utility by writing a Rust server with an API for the same functionality.\n\nBuild a server in Rust which exposes a REST API to allow users to set, get, and remove items in a key value store. Unlike the command line utility, this should support set arbitrary JSON data in the `value` field for cache entries. The API should also support retrieving all existing entries, and remove all existing entries.\n\nBonus points:\n\n* Consider adding validation for requests.\n* Consider how you might add tests for your server.\n* Consider how you might add an authentication layer, or separate expose the functionality to multiple different users \\(e.g. N users consume your API, but they each access separate caches\\).\n* Consider how you might persist the cache data more permanently using a database.\n\n"
        },
        {
          "type": "project",
          "id": "UticrWdb1",
          "title": "Command Line Tic Tac Toe Game",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Let's create a Tic Tac Toe game in Rust. This will be similar to the Tic Tac Toe project in the FullStack TypeScript curriculum, if you completed that previously. Here, however, the game will be totally opened ended for you to design as you see fit. The main requirements are:\n\n* Players can play the computer in Tic Tac Toe.\n* The game will randomly choose who plays first.\n* The computer will choose a random move each round.\n* The game will obey the ordinary rules of Tic Tac Toe, and declare a winner or tie at the end.\n* Once a game completes, the player will have the option to play again.\n* For a given session, the game should get track of overall wins/losses.\n\n\nFor your program, consider edge cases, handling errors, and how you can add tests to verify the game behavior is correct. Good luck\\!\n"
        },
        {
          "type": "project",
          "id": "s2Ph4e5cp",
          "title": "Real Time Chat Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Build a web server using Rust which provides a real time chat functionality. For the basic implementation, consider a single chatroom which anyone can join and post messages to. The server forwards messages in real time to all connected clients.\n\nFor client implementations, you may disregard implementing a client \\(if you wish\\), or build a simple UI web client, or build a command line client in Rust which allows you to post a message to the chat server and can also subscribe to the server and print out any new messages as they arrive.\n\nFor more challenges, consider how you might change this to persist messages using a database and allow for more advanced chat features \\(e.g. direct messages between users, replies/threads, reactions, etc.\\). Finally, consider how you might test your project."
        }
      ]
    }
  ]
}