{
  "free": false,
  "price": 50,
  "premiumPrice": 500,
  "id": "alosiqu45",
  "title": "Rust",
  "description": "Rust is a statically typed, multi paradigm programming language which excels at performance and safety.",
  "modules": [
    {
      "id": "alosiuqwk",
      "title": "Intro to Rust",
      "free": true,
      "challenges": [
        {
          "id": "1UMWYNFnEH",
          "type": "section",
          "title": "The Rust Language",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined.\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "[Rust](https://doc.rust-lang.org/rust-by-example/index.html) is a powerful programming language which offers the speed of a compiled language like C\\+\\+ but with many of the abstractions and safety guarantees present in higher level languages. It does this with the help of a sophisticated compiler system.\n\nFirst we will start with 3 intro challenges which are intended to highlight some of the basics of Rust and give you a quick onboarding to writing some Rust code.\n\nProceed to the next challenge to begin\\!"
        },
        {
          "id": "S@Ghw6X75",
          "type": "rust",
          "title": "Intro to Rust",
          "instructions": "Complete the function in the editor which adds two numbers together. [Rust](https://www.rust-lang.org) is a fairly new programming language which is growing rapidly in popularity. Rust famously tries to provide the speed of a low level compiled language with the productivity of a richly featured high level language.",
          "testCode": "test(\"The `add` function should exist and add two numbers together.\", async () => {\n  const RUST_CODE_STRING = __user_code_string__;\n\n  const RUST_TEST_STRING = `\n    fn test() -> bool {\n      let mut result = add(10, 5);\n      let mut expected = 15;\n      if result != expected {\n          return false;\n      }\n\n      result = add(100, 200);\n      expected = 300;\n      if result != expected {\n          return false;\n      }\n\n      result = add(10, 25);\n      expected = 35;\n      if result != expected {\n          return false;\n      }\n\n      result = add(-15, 15);\n      expected = 0;\n      if result != expected {\n          return false;\n      }\n\n      result = add(1000, -2000);\n      expected = -1000;\n      if result != expected {\n          return false;\n      }\n\n      true\n    }\n  `;\n\n  const result = await executeRustChallengeTests(\n    RUST_CODE_STRING,\n    RUST_TEST_STRING\n  );\n\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A function to add two numbers together\nfn add(a: i32, b: i32) -> i32 {\n  // Your code here\n}\n",
          "solutionCode": "// Write an add function using Rust\nfn add(a: i32, b: i32) -> i32 {\n  a + b\n}\n",
          "content": ""
        },
        {
          "id": "Qug@7dDI$",
          "type": "rust",
          "title": "Variable Mutability",
          "instructions": "In Rust values are immutable by default. You have to opt\\-in to mutability. You can do this in variable declarations using the `mut` keyword\\. The `cost` integer is defined in the editor below. Next, we try to change this value—but this code doesn't compile. Fix the problem by making the variable mutable.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let result = get_cost();\n      if result != 500 {\n        return false;\n      }\n\n      return true;\n    }\n  `;\n\ntest(\"The `cost` variable should be mutable and equal to `500`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n\n  if (!CODE_STRING.includes(\"let mut cost\")) {\n    throw new Error(\"cost must be mutable.\");\n  }\n\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_cost() -> i32 {\n  let cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "solutionCode": "fn get_cost() -> i32{\n  let mut cost: i32 = 1000;\n\n  println!(\"[1] The current cost is: {}\", cost);\n\n  // This doesn't compile:\n  cost = 500;\n\n  println!(\"[2] The current cost is: {}\", cost);\n\n  cost\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "EknAkk16W",
          "title": "Rust's Result Type",
          "instructions": "Some of the most commonly used and powerful types in Rust are the [Option](https://doc.rust-lang.org/rust-by-example/std/option.html) and [Result](https://doc.rust-lang.org/rust-by-example/error/result.html) type\\. These types allow you to represent values that may be in one of two potential states, i.e. \"some\" or \"none\" in the case of the `Option` type and \"valid/ok\" or \"error/failure\" in the case of the `Result` type\\.\n\nThe application of these types in Rust combined with the strictness of the Rust compiler are intended to create a programming experience where all of the \"null point exception\" and \"cannot read property of undefined\" classes of errors are simply not possible because of extensive type checking.\n\nIn the editor below, we have some simple code which explores usage of the Result type. You will see the `is_number_valid` which returns a `Result`. Your job is to add a conditional `if` clause to this function which returns the valid Result, an \"ok\" [unit type](https://doc.rust-lang.org/std/primitive.unit.html), if the provided `num` parameter is less than 25.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = true;\n\n      let mut fn_result = is_number_valid(5);\n      match fn_result {\n        Ok(()) => (),\n        Err(e) => {\n          result = false;\n        }\n      }\n\n      fn_result = is_number_valid(50);\n      match fn_result {\n        Ok(()) => {\n          result = false;\n        },\n        Err(e) => (),\n      }\n      \n      return result;\n    }\n  `;\n\ntest(\"The `is_number_valid` function should return a Result unit type `()` if the provided input is less than 25, or an `Err` type otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  // Your code here\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(50);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(5);\ncheck_result(invalid);",
          "solutionCode": "// Here a simple string type is used to represent the error\n// possibility of a Result type.\ntype NumberValidResult = Result<(), String>;\n\n// Arbitrary check on a number input, which returns a Result type.\nfn is_number_valid(num: i32) -> NumberValidResult {\n  if num < 25 {\n    return Ok(())\n  }\n\n  return Err(\"Number is invalid\".to_string())\n}\n\n// Function which inspects a Result type.\nfn check_result(result: NumberValidResult) {\n  println!(\"\\nChecking Result: {:?}\", result);\n\n  // Idiomatic Rust match statement.\n  match result {\n    Ok(()) => println!(\"Result is valid\"),\n    Err(err) => println!(\"Result is invalid, error: {:?}\", err),\n  }\n}\n\n// Get a valid result:\nlet valid = is_number_valid(15);\ncheck_result(valid);\n\n// Get an invalid result:\nlet invalid = is_number_valid(50);\ncheck_result(invalid);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "IIMmCDTle8",
          "title": "Comments",
          "instructions": "Comments in Rust are ignored by the compiler and convey helpful information and context to other future programmers. Their syntax is very similar to comment syntax in other languages.\n\nRead through the code in the editor to get a feel for the different comment styles in Rust. Don't worry if not all the code makes sense yet. When you are ready, click \"Run\" to complete the challenge. Don't forget to take a look at the console output before moving on.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code compiles. When you are ready run the code and take a look at the console output before moving on.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * This is a multi-line comment.\n *\n * The following code demonstrates various types of comment\n * usage. For regular comments you have /* ... */ multiline\n * comments like we are in now, and also single-line comments,\n * e.g. // This is my comment.\n *\n * Rust also supports standard documentation comments, which\n * are indicated using a triple slash: ///\n *\n * These documentation comments are displayed in the HTML\n * documentation generated when running 'cargo doc'. For\n * more on this take a look here:\n * https://doc.rust-lang.org/rust-by-example/meta/doc.html\n */\n\n/// Enum representing different possible weapon types\n#[derive(Debug)]\nenum WeaponTypes {\n  Sword,\n  Spear,\n  Dagger,\n  BowAndArrow,\n  Mace,\n  Axe,\n}\n\n/// A struct for a package item in a game\n#[derive(Debug)]\nstruct Weapon {\n  /// The weapon type\n  weapon_type: WeaponTypes,\n}\n\nimpl Weapon {\n  /// Create a new weapon, given a weapon type\n  pub fn new(weapon_type: WeaponTypes) -> Weapon {\n    Weapon {\n      weapon_type,\n    }\n  }\n}\n\n/**\n * This is a function to create some new weapons.\n */\nfn create_three_weapons() -> (Weapon, Weapon, Weapon) {\n  println!(\"\\nCreating 3 new weapons...\\n\");\n\n  // Create a sword\n  let sword = Weapon::new(WeaponTypes::Sword);\n  println!(\"Created a sword: {:?}\", sword);\n\n  // Create a mace\n  let mace = Weapon::new(WeaponTypes::Mace);\n  println!(\"Created a mace: {:?}\", mace);\n\n  // Create a sword\n  let dagger = Weapon::new(WeaponTypes::Dagger);\n  println!(\"Created a dagger: {:?}\", dagger);\n\n  println!(\"\\nFinished weapon creation!\");\n\n  // Return a tuple of the three created weapons\n  return (sword, mace, dagger);\n}\n\n// Create some weapons\ncreate_three_weapons();",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "vxOeSToH8",
          "title": "Logging Values with println!",
          "instructions": "Logging data while a program is running is important for development, debugging and various production use cases. Rust supports logging values primarily using the `println` macro which can be invoked with a `!`.\n\n```\n// Invoking the println macro:\nprintln!(\"Hello!\"); // Logs out \"Hello\"\n\n```\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = logging_demonstration();\n  \n  result\n}\n`;\n\ntest(\"The `logging_demonstration` function should return `true` once you are finished reading through the examples of `println`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * For most values you can use the println macro with {}\n * followed by the values you want to print out.\n *\n * For some values, you may need to use {:?}.\n *\n * The std::fmt library handles printing values and relies\n * on various traits, such as fmt::Debug and fmt::Display.\n * These traits must be derived or implemented for the values\n * you want to print out.\n *\n * If fmt::Display is implemented you can print a value using\n * using {}, if only Debug is implemented (which can usually\n * be derived) you will have to use {:?}.\n *\n * Don't worry about all these details much. For now, just\n * get a sense of how to use println to log values.\n */\nfn logging_demonstration() -> bool {\n  println!(\"\\n- Examples of using the println macro:\\n\");\n\n  let value = 52;\n  println!(\"Log a number: {}\", value);\n\n  let boolean = true;\n  println!(\"Log a boolean: {}\", boolean);\n\n  let name = \"Oren\";\n  println!(\"Log a string slice: {}\", name);\n\n  let a = 2;\n  let b = false;\n  let c = \"Hi!\";\n  // You can provide multiple arguments to println:\n  println!(\"Log out multiple values, a: {}, b: {}, c: {}\", a, b, c);\n\n  // We derive the fmt::Debug trait on our Person struct, to\n  // allow it to be printed using {:?} - otherwise, we would\n  // have to implement the fmt::Display trait.\n  #[derive(Debug)]\n  struct Person {\n    name: String,\n  }\n\n  let person = Person {\n    name: \"Sam\".to_string(),\n  };\n\n  // You must use {:?} to format values for which the Display\n  // trait has not been implemented, like the above Person.\n  println!(\"A Person: {:?}\", person);\n\n  let complete: bool = false;\n  println!(\"\\n- When you are ready, change the value of the complete variable from false to true to complete the challenge.\");\n\n  complete\n}\n\nlogging_demonstration();",
          "solutionCode": "/**\n * For most values you can use the println macro with {}\n * followed by the values you want to print out.\n *\n * For some values, you may need to use {:?}.\n *\n * The std::fmt library handles printing values and relies\n * on various traits, such as fmt::Debug and fmt::Display.\n * These traits must be derived or implemented for the values\n * you want to print out.\n *\n * If fmt::Display is implemented you can print a value using\n * using {}, if only Debug is implemented (which can usually\n * be derived) you will have to use {:?}.\n *\n * Don't worry about all these details much. For now, just\n * get a sense of how to use println to log values.\n */\nfn logging_demonstration() -> bool {\n  println!(\"\\n- Examples of using the println macro:\\n\");\n\n  let value = 52;\n  println!(\"Log a number: {}\", value);\n\n  let boolean = true;\n  println!(\"Log a boolean: {}\", boolean);\n\n  let name = \"Oren\";\n  println!(\"Log a string slice: {}\", name);\n\n  let a = 2;\n  let b = false;\n  let c = \"Hi!\";\n  // You can provide multiple arguments to println:\n  println!(\"Log out multiple values, a: {}, b: {}, c: {}\", a, b, c);\n\n  // We derive the fmt::Debug trait on our Person struct, to\n  // allow it to be printed using {:?} - otherwise, we would\n  // have to implement the fmt::Display trait.\n  #[derive(Debug)]\n  struct Person {\n    name: String,\n  }\n\n  let person = Person {\n    name: \"Sam\".to_string(),\n  };\n\n  // You must use {:?} to format values for which the Display\n  // trait has not been implemented, like the above Person.\n  println!(\"A Person: {:?}\", person);\n\n  let complete: bool = true;\n  println!(\"\\n- When you are ready, change the value of the complete variable from false to true to complete the challenge.\");\n\n  complete\n}\n\nlogging_demonstration();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "$Do6$e1dD",
          "title": "Naming: Snake Case",
          "instructions": "What is the convention for naming variables and functions in Rust? `snake_case`of course: all lowercase with words separated by underscores. As you learn more Rust, you will see that enforces strong conventions and rules in many cases which cannot be deviated from. Naming is no exception\\! Although it might feel frustrating at first, it means that any Rust code will have a basic level of familiarity to a seasoned Rust developer.\n\nUpdate the naming conventions in the editor to adhere to snake casing rules.\n\n> The code in the editor will compile. But if you were running `rustc` locally to see the full output you would see warnings on the variable names like this:\n> \n> ```\n> warning: function `myFunction` should have a snake case name\n> \n> ```\n> \n> Although you can name you functions and variables different, we would recommend sticking with the Rust convention of snake case.\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `myFunction` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_function\")).toBe(true);\n});\n\ntest(\"The `mySpecialValue` variable should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"my_special_value\")).toBe(true);\n});\n\ntest(\"The `functionResultValue` function should renamed using snake case.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"function_result_value\")).toBe(true);\n});\n",
          "videoUrl": "",
          "starterCode": "fn myFunction() -> u64 {\n  let mySpecialValue = 5000;\n\n  return mySpecialValue;\n}\n\nlet functionResultValue = myFunction();\nprintln!(\"functionResultValue: {:?}\", functionResultValue);",
          "solutionCode": "fn my_function() -> u64 {\n  let my_special_value = 5000;\n\n  return my_special_value;\n}\n\nlet function_result_value = my_function();\nprintln!(\"function_result_value: {:?}\", function_result_value);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "r2nYe0r8uk",
          "title": "Don't Panic",
          "instructions": "Rust is a type\\-safe language which tries meticulously to prevent runtime program errors. However, inevitably things still tend to go wrong from time to time. In Rust, a language facility exists for program states which are un\\-recoverable, or should not be possible. The \"panic\" macro can be invoked in such states:\n\n```\npanic!(\"This should not happen!\");\n\n```\n\nThis will halt and exit the program. We mention it here in the introduction, because you might encounter panicked code in the following challenges before we fully introduce topics such as macros, panicking, handling errors, the `Result` type, and so on. The purpose of this introduction is to inform you in advance in case you see a stacktrace like... well, try running the code in the editor to see what we mean.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and run without issues.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// What could go wrong here?\nlet x = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nlet y = x[80];\nprintln!(\"The value in x at index 80 is: {}\", y);",
          "solutionCode": "// What could go wrong here?\nlet x = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nlet y = x[8];\nprintln!(\"The value in x at index 80 is: {}\", y);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "TRAA2QQYn",
          "title": "Ownership Primer",
          "instructions": "Borrowing and ownership are fundamental concepts in Rust, but they are more advanced, can be hard to understand in practice, and tend to trip up many beginning Rust programmers.\n\nWe want to introduce the concept of ownership and borrowing here but we will deep dive on this topic later. You will inevitably encounter some compiler errors related to ownership so it is helpful to have a brief primer in advance.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ki3WuKjhV",
          "title": "Rust's & * and 'a Syntax Primer",
          "instructions": "If you are coming from other higher level programming languages like JavaScript or Python, you may be surprised to see strange symbols like `&` and `*` in Rust code. You may even see `&&` from time to time. Not to mentioned the especially alien `<'a>`. What are these?\n\nWe will deep dive on all of these concepts later, but for now we want to briefly introduce them so you will not be totally lost if you encounter some of these in the upcoming challenges.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "media",
          "id": "3q8AK1mvF",
          "title": "How to Approach the Following Challenges",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "We've now seen some of the basics of the Rust language."
        }
      ]
    },
    {
      "id": "vjN$jfZeb",
      "title": "Data and Types",
      "challenges": [
        {
          "type": "section",
          "id": "6w$q0NkrZ",
          "title": "Primitive Data and Types",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust is a statically typed language which means the Rust compiler determines the type of all data in a program when it is compiled. The compiler enforces that only valid operations are allowed \\- for instance, you cannot arithmetically add a string to an integer type. This section will introduce the basic types and data primitives you have available to work with in the Rust language. In particular, there are two main categories of primitive types: scalar and compound.\n\n**Scalar** types represent a single value, and include the following:\n\n* Signed and unsigned integers.\n* Floating point numbers.\n* Arithmetic\\.\n* Booleans\\.\n* Characters\\.\n* The unit type.\n\n\n**Compound** types group several individual values into one type. In Rust compound type primitives include arrays and tuples.\n\nThroughout this module, you will also get a feeling for basic syntax in Rust, e.g. variable and function declarations, print statements, code comments, and other basics.\n\nIn the next module, we will cover basic Rust programming and higher level data structures."
        },
        {
          "type": "rust",
          "id": "hH8NF2FXav",
          "title": "Rust Syntax Primer",
          "instructions": "Before we dive in, let's start with a quick practice lesson to gain a foundation in basic Rust syntax, specifically how to define variables and functions in Rust.\n\nRead the code and comments in the editor, and then make a small change to solve the challenge.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = is_complete();\n\n  result\n}\n`;\n\ntest(\"The `is_complete` function should return the boolean `true`. Update this function to return `true` once you are satisifed you understand all the points here.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = false;\n}",
          "solutionCode": "// Functions are defined using the 'fn' keyword, and usually\n// written in all lowercase with underscores separating words:\nfn defining_variables() -> u64 {\n  // Variables are defined using the 'let' keyword,\n  // and are immutable by default:\n  let x = 32;\n\n  // To make a variable mutable, add the 'mut' keyword:\n  let mut y = 58;\n\n  // Mutable variables can be changed\n  y = 42;\n\n  // The 'return' keyword returns a values from a\n  // function:\n  return x + y;\n}\n\nlet result = defining_variables();\n\n// We can use the println! macro to print out values:\nprintln!(\"defining_variables result: {:?}\", result);\n\n// Constants are declared used the `const` keyword and are\n// valid for the entire life of the program:\nconst FIVE_HUNDRED: u64 = 500;\n\n// Rust allows you to return values from a function\n// by just writing the value with no 'return' keyword\n// or semicolon:\nfn implicitly_return() -> u64 {\n    500\n}\n\n// Or you can use a 'return' to return explicitly:\nfn explicitly_return() -> u64 {\n    return 500;\n}\n\nlet a = implicitly_return();\nlet b = explicitly_return();\nlet c = FIVE_HUNDRED;\n\n// This is a macro - we will cover it later:\nassert_eq!(a, b);\nassert_eq!(b, c);\nprintln!(\"a ({:?}), b ({:?}) and c ({:?}) are equal\", a, b, c);\n\n// Type annotations work as you might expect,\n// this is a 32-bit signed integer:\nlet integer: i32 = -57;\nprintln!(\"integer value: {:?}\", integer);\n\n// Before changing the code, click the \"Run\" button and take\n// a look at the Rust compiler's feedback in the console panel.\n// The compiler is smart and works hard to correct your code for\n// you.\nfn is_complete() -> bool {\n  // Update this value, and then return it:\n  let i_read_and_understood_everything: bool = true;\n\n  i_read_and_understood_everything\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "d8WItf9JW",
          "title": "Integers",
          "instructions": "Initialize the `my_int` value in `get_integer` function in the editor to return a valid `i8` integer, an 8\\-bit signed integer. Rust supports multiple different integer data types, from 8 to 128 bit, each signed or unsigned. A \"signed\" integer is one that may be positive of negative, e.g. `-4` is a signed integer. Unsigned integers are assumed to be positive.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let n = get_integer();\n  let result = 5 + n;\n  let original = result - 5;\n\n  if n != original {\n    return false\n  }\n\n  return true\n}\n`;\n\ntest(\"The `my_int` variable in the `get_integer` should be correctly initialized.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "solutionCode": "// Return an i8 integer value\nfn get_integer() -> i8 {\n  let my_int: i8 = 15;\n\n  my_int\n}\n\nlet integer = get_integer();\nprintln!(\"my_int value: {:?}\", integer);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "z6DMvoh1T",
          "title": "Integer Type Sizes",
          "instructions": "The size of an integer data type refers to how much memory will be required to store the value, and hence, this imposes a limit on the size of the particular integer. An `i8` value, for instance, occupies 8 bits of space and can range from `-128` to `127`.\n\nThe editor below has a function `check_integer_i8_range` which uses the public `i8` constant `MIN` and `MAX` values and the `assert_eq!` macro \\(don't worry, more on all this later\\) to check that an input range falls within the bounds of an acceptable `i8` integer\\.\n\nUpdate the invocation of `check_integer_i8_range` so that the code compiles. Notice how the compiler is about to detect that the current code will fail, and even gives you a helpful hint\\!",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  check_integer_i8_range(-128, 127);\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `check_integer_i8_range` function should be invoked with the minimum and maximum bounds of an `i8` integer.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(\n    CODE_STRING.replace(/ /g, \"\").includes(\"check_integer_i8_range(-128,127)\")\n  ).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-500, 500);\n",
          "solutionCode": "fn check_integer_i8_range(min: i8, max: i8) -> () {\n  assert_eq!(i8::MIN, min);\n  assert_eq!(i8::MAX, max);\n  println!(\"Valid i8 Range, min: {:?} max: {:?}\", min, max);\n}\n\n// Update this line:\ncheck_integer_i8_range(-128, 127);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Y2SVKl8Xq",
          "title": "Practice With Integers",
          "instructions": "As we mentioned when introduced integer data types, Rust provides types from 8\\-bit up to 128\\-bit, signed and unsigned integers. Complete the function into the editor below by filling in all the integer types so the code compiles.\n\nDon't worry about the struct defined at the top of the editor—we will cover this later. Just deal with defining the variables correctly in the body of the `get_all_integer_data_types` function\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = get_all_integer_data_types();\n\n  let TestStruct = IntegerTypes {\n    eight_bit_signed: 50,\n    eight_bit_unsigned: 50,\n    sixteen_bit_signed: 50,\n    sixteen_bit_unsigned: 50,\n    thirty_two_bit_signed: 5000,\n    thirty_two_bit_unsigned: 5000,\n    sity_four_bit_signed: 5000,\n    sity_four_bit_unsigned: 5000,\n    one_hundred_twenty_eight_bit_signed: 5000,\n    one_hundred_twenty_eight_bit_unsigned: 5000,\n  };\n\n  let _a: i8 = result.eight_bit_signed + TestStruct.eight_bit_signed;\n  let _b: u8 = result.eight_bit_unsigned + TestStruct.eight_bit_unsigned;\n  let _c: i16 = result.sixteen_bit_signed + TestStruct.sixteen_bit_signed;\n  let _d: u16 = result.sixteen_bit_unsigned + TestStruct.sixteen_bit_unsigned;\n  let _e: i32 = result.thirty_two_bit_signed + TestStruct.thirty_two_bit_signed;\n  let _f: u32 = result.thirty_two_bit_unsigned + TestStruct.thirty_two_bit_unsigned;\n  let _g: i64 = result.sity_four_bit_signed + TestStruct.sity_four_bit_signed;\n  let _h: u64 = result.sity_four_bit_unsigned + TestStruct.sity_four_bit_unsigned;\n  let _i: i128 = result.one_hundred_twenty_eight_bit_signed + TestStruct.one_hundred_twenty_eight_bit_signed;\n  let _j: u128 = result.one_hundred_twenty_eight_bit_unsigned + TestStruct.one_hundred_twenty_eight_bit_unsigned;\n\n  true\n}\n`;\n\ntest(\"The code should compile and the `get_all_integer_data_types` function should return a properly defined `IntegerTypes` struct, which includes all 10 different integer data types.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed;\n  let eight_bit_unsigned;\n\n  // 16-bit\n  let sixteen_bit_signed;\n  let sixteen_bit_unsigned;\n\n  // 32-bit\n  let thirty_two_bit_signed;\n  let thirty_two_bit_unsigned;\n\n  // 64-bit\n  let sity_four_bit_signed;\n  let sity_four_bit_unsigned;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed;\n  let one_hundred_twenty_eight_bit_unsigned;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "solutionCode": "// This is a struct, don't worry about the details for now ;)\n#[derive(Debug)]\nstruct IntegerTypes {\n  eight_bit_signed: i8,\n  eight_bit_unsigned: u8,\n  sixteen_bit_signed: i16,\n  sixteen_bit_unsigned: u16,\n  thirty_two_bit_signed: i32,\n  thirty_two_bit_unsigned: u32,\n  sity_four_bit_signed: i64,\n  sity_four_bit_unsigned: u64,\n  one_hundred_twenty_eight_bit_signed: i128,\n  one_hundred_twenty_eight_bit_unsigned: u128,\n}\n\nfn get_all_integer_data_types() -> IntegerTypes {\n  // Update code below this line:\n\n  // 8-bit\n  let eight_bit_signed = -4;\n  let eight_bit_unsigned = 4;\n\n  // 16-bit\n  let sixteen_bit_signed = -500;\n  let sixteen_bit_unsigned = 500;\n\n  // 32-bit\n  let thirty_two_bit_signed = -10000;\n  let thirty_two_bit_unsigned = 10000;\n\n  // 64-bit\n  let sity_four_bit_signed = -10000000;\n  let sity_four_bit_unsigned = 10000000;\n\n  // 128-bit\n  let one_hundred_twenty_eight_bit_signed = -10000000000;\n  let one_hundred_twenty_eight_bit_unsigned = 10000000000;\n\n  // Update code above this line:\n\n  return IntegerTypes {\n    eight_bit_signed,\n    eight_bit_unsigned,\n    sixteen_bit_signed,\n    sixteen_bit_unsigned,\n    thirty_two_bit_signed,\n    thirty_two_bit_unsigned,\n    sity_four_bit_signed,\n    sity_four_bit_unsigned,\n    one_hundred_twenty_eight_bit_signed,\n    one_hundred_twenty_eight_bit_unsigned,\n  };\n}\n\nlet result = get_all_integer_data_types();\nprintln!(\"Result:\");\nprintln!(\"{:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "6DWRvh7zW",
          "title": "Floating Point Numbers",
          "instructions": "Rust also provides basic data types to deal with floating point numbers. In Rust there are two floating point types: `f32` and `f64`, which use 32 and 64 bits, respectively.\n\nInitialize the two variables in the function body to floating point values so the code compiles correctly.\n\nIf you don't explicitly declare the type, Rust will assign `f64` as the default floating point data type, try doing this for the second variable in the function body.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result = floating_point_types();\n  let _x: f32 = result.0;\n  let _y: f64 = result.1;\n\n  true\n}\n`;\n\ntest(\"The `floating_point_types` function should return a `(f32, f64)` type tuple, using the properly initialized values in the function body.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32;\n\n  // The type will default to f64\n  let floating_point_sixty_four;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// This function returns a tuple type\nfn floating_point_types() -> (f32, f64) {\n  // Explicitly defined as an f32 value\n  let floating_point_thirty_two: f32 = 213.12311;\n\n  // The type will default to f64\n  let floating_point_sixty_four = 32423.12313131;\n\n  // Disregard .into() usage, again ;)\n  return (floating_point_thirty_two, floating_point_sixty_four);\n}\n\nlet result = floating_point_types();\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "7ZmqyOC7T",
          "title": "Rust Arithmetic",
          "instructions": "Rust supports basic arithmetic similar to many other programming languages, using common operators such as `+`, `-`, `*`, `/`, and `%`. Complete the arithmetic helper functions in the editor with the appropriate operators.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _a = add(23.532, 42.592);\n  let _b: f64 = subtract(23.532, 42.592);\n  let _c: f64 = multiply(23.532, 42.592);\n  let _d: f64 = divide(23.532, 42.592);\n  let _e: f64 = modulus(23.532, 42.592);\n\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  // Your code here\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "solutionCode": "fn add(a: f64, b: f64) -> f64 {\n  a + b\n}\n\nfn subtract(a: f64, b: f64) -> f64 {\n  a - b\n}\n\nfn multiply(a: f64, b: f64) -> f64 {\n  a * b\n}\n\nfn divide(a: f64, b: f64) -> f64 {\n  a / b\n}\n\nfn modulus(a: f64, b: f64) -> f64 {\n  a % b\n}\n\nprintln!(\"Rust Arithmetic Results:\");\nprintln!(\"Result add: {:?}\", add(23.532, 42.592));\nprintln!(\"Result subtract: {:?}\", subtract(23.532, 42.592));\nprintln!(\"Result multiply: {:?}\", multiply(23.532, 42.592));\nprintln!(\"Result divide: {:?}\", divide(23.532, 42.592));\nprintln!(\"Result modulus: {:?}\", modulus(23.532, 42.592));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "U3$RxoovO",
          "title": "Boolean Values",
          "instructions": "In Rust boolean values can be `true` or `false` and as a type can be represented using the  `bool` keyword\\. Change the value of the variables in the `all_should_be_truthy` function in the editor according to the type annotations so the code compiles, and then return an appropriate value from the function.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = all_should_be_truthy();\n\n  result\n}\n`;\n\ntest(\"The `all_should_be_truthy` function should compile and return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 50 < 10;\n\n  // Change the variable value, not the if statement\n  if should_be_true  {\n    return false;\n  }\n\n  let should_be_false: bool = 250 > 50;\n\n  // Change the variable value, not the if statement\n  if should_be_false == true {\n    return false;\n  }\n\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "solutionCode": "fn all_should_be_truthy() -> bool {\n  let should_be_true: bool = 5 < 10;\n\n  if should_be_true == false {\n    return false;\n  }\n\n  let should_be_false: bool = 25 > 50;\n\n  if should_be_false == true {\n    return false;\n  }\n\n  return true;\n}\n\nprintln!(\"Result should be true, result: {:?}\", all_should_be_truthy());",
          "content": ""
        },
        {
          "type": "rust",
          "id": "R@eJbCV7@",
          "title": "The Char Primitive",
          "instructions": "Next is the `char` data type, which represents a single character. This is the primitive type which is used to build up `str` and `String` types which are more commonly used to represent string values \\(more on these later\\). A `char` value is limited to a single character and represents a Unicode Scalar Value. Note that `char`s are declared using single quotes.\n\nAdjust the `return_a_char_value` function so the code compiles.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let _result: char = return_a_char_value();\n\n  true\n}\n`;\n\ntest(\"The `return_a_char_value` function should compile and return a `char` value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn return_a_char_value() -> char {\n  let character: char = 'xyz';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "solutionCode": "fn return_a_char_value() -> char {\n  let character: char = 'x';\n\n  character\n}\n\nlet result = return_a_char_value();\nprintln!(\"Character: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "FsJ$iEG44E",
          "title": "The Unit Type",
          "instructions": "In Rust, the [Unit](https://doc.rust-lang.org/std/primitive.unit.html) type exists to represent an empty/non\\-meaningful state. All expressions return the unit type unless they otherwise return another value explicitly.The unit type is useful when you need a placeholder to represent a specific state or value, but that particular state or value really has no other significant representation for it \\(such as the generic success or failure of some operation\\).\n\nInitialize the variable `four` in the editor below to the value of the unit type to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The variable `four` should be initialized as the unit type `()` so the code compiles correctly. \", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Functions, by deafult, return ()\nfn unit_one() {\n  println!(\"Functions return () by default.\");\n}\n\nfn unit_two() -> () {\n  println!(\"Adding a type signature doesn't change it.\");\n}\n\nfn unit_three() -> () {\n  println!(\"We can also return () directly at the end of the function.\");\n\n  ()\n}\n\nlet one = unit_one();\nlet two = unit_two();\nlet three = unit_three();\nlet four: ();\n\n// Assert the same return value\nif one == two && two == three && three == four {\n  println!(\"\\n- In Rust, all unit types are equivalent: () == ()\");\n}",
          "solutionCode": "// Functions, by deafult, return ()\nfn unit_one() {\n  println!(\"Functions return () by default.\");\n}\n\nfn unit_two() -> () {\n  println!(\"Adding a type signature doesn't change it.\");\n}\n\nfn unit_three() -> () {\n  println!(\"We can also return () directly at the end of the function.\");\n\n  ()\n}\n\nlet one = unit_one();\nlet two = unit_two();\nlet three = unit_three();\nlet four: () = ();\n\n// Assert the same return value\nif one == two && two == three && three == four {\n  println!(\"\\n- In Rust, all unit types are equivalent: () == ()\");\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "sLEaTrYvk",
          "title": "Array Primitives",
          "instructions": "Arrays in Rust have a fixed length and contain values of only a single type. Like arrays in other languages, they are zero indexed.\n\nTake a look at the code in the editor. It currently doesn't compile. Can you find the problem and fix it?",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = array_access();\n  assert_eq!(result.len(), 5);\n\n  true\n}\n`;\n\ntest(\"The code should compile and print out all 5 values in the `my_array` array.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn array_access() -> [i8; 5] {\n  // Arrays can be initialized as follows:\n  let my_array: [i8; 5] = [1,2,3,4,5];\n\n  // Array items can be accessed using the index:\n  let one = my_array[1];\n  println!(\"The 1st value in my_array is {}\", one);\n\n  let two = my_array[2];\n  println!(\"The 2nd value in my_array is {}\", two);\n\n  let three = my_array[3];\n  println!(\"The 3rd value in my_array is {}\", three);\n\n  let four = my_array[4];\n  println!(\"The 4th value in my_array is {}\", four);\n\n  let five = my_array[5];\n  println!(\"The 5th value in my_array is {}\", five);\n\n  my_array\n}\n\narray_access();",
          "solutionCode": "fn array_access() -> [i8; 5] {\n  // Arrays can be initialized as follows:\n  let my_array: [i8; 5] = [1,2,3,4,5];\n\n  // Array items can be accessed using the index:\n  let one = my_array[0];\n  println!(\"The 1st value in my_array is {}\", one);\n\n  let two = my_array[1];\n  println!(\"The 2nd value in my_array is {}\", two);\n\n  let three = my_array[2];\n  println!(\"The 3rd value in my_array is {}\", three);\n\n  let four = my_array[3];\n  println!(\"The 4th value in my_array is {}\", four);\n\n  let five = my_array[4];\n  println!(\"The 5th value in my_array is {}\", five);\n\n  my_array\n}\n\narray_access();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "sCOekMaC@",
          "title": "Array Indexing",
          "instructions": "The last challenge demonstrated something important: The Rust compiler checks for invalid array index access at compile time. If you have an array of length 3 and you try to access the item at index 10 this will fail at the compile step \\- assuming the compiler knows the value of the index you are trying to access at that step.\n\nIf it does not, i.e. if that value is only known at runtime, the program will _panic\\._ Take a look at the editor to see what we mean.\n\nThe code compiles, but fails at runtime. To fix this issue, update the while loop condition to stop at the length of the array. You can find the length of an array with the `.len` method\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and run without any runtime errors\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "/**\n * When this code is run, it will compile but produce a runtime panic.\n */\nfn runtime_array_access() {\n  let array: [i8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  let mut index = 0;\n\n  while index < 11 {\n    let value = array[index];\n    println!(\"The value at index {} is: {}\", index, value);\n    index = index + 1;\n  }\n}\n\nruntime_array_access();",
          "solutionCode": "/**\n * When this code is run, it will compile but produce a runtime panic.\n */\nfn runtime_array_access() {\n  let array: [i8; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n  let mut index = 0;\n\n  while index < array.len() {\n    let value = array[index];\n    println!(\"The value at index {} is: {}\", index, value);\n    index = index + 1;\n  }\n}\n\nruntime_array_access();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "niJPS3cRO",
          "title": "Tuples",
          "instructions": "Tuples are the second primitive compound type available in Rust. They are similar to arrays in that they have a fixed length but different in that the items they contain may be of different types.\n\nIn the code below we define a new tuple type which contains several values, including an array. Update the function `tuple_demonstration` to return just this array from the provided tuple. Note that tuples are indexed just like arrays, but to access a tuple item by index you use a dot syntax, e.g. `my_tuple.2` would return the item at the 2nd index in `my_tuple`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let array = [7,3,5];\n  let example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\n  let result = tuple_demonstration(example_tuple);\n  assert_eq!(array, result);\n  true\n}\n`;\n\ntest(\"The `tuple_demonstration` function should return the array in the `CustomTuple` argument it is provided.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Tuple types can be declared like this:\ntype CustomTuple = (&'static str, bool, bool, u32, [i8; 3]);\n\nfn tuple_demonstration(custom_tuple: CustomTuple) -> [i8; 3] {  \n  println!(\"Tuple: {:?}\", custom_tuple);\n}\n\nlet array: [i8; 3] = [1, 2, 3];\n// A new tuple can be initialized directly like this:\nlet example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\ntuple_demonstration(example_tuple);",
          "solutionCode": "// Tuple types can be declared like this:\ntype CustomTuple = (&'static str, bool, bool, u32, [i8; 3]);\n\nfn tuple_demonstration(custom_tuple: CustomTuple) -> [i8; 3] {  \n  println!(\"Tuple: {:?}\", custom_tuple);\n\n  custom_tuple.4\n}\n\nlet array: [i8; 3] = [1, 2, 3];\n// A new tuple can be initialized directly like this:\nlet example_tuple: CustomTuple = (\"Tuples contain primitive types\", true, false, 50, array);\ntuple_demonstration(example_tuple);",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "S3BmBYNCP",
      "title": "Rust Fundamentals",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "upbaggZVb",
          "title": "Variables and Functions",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will cover variables and functions in more detail. These challenges should be fairly quick since the previous module included many examples of variables and functions. Nevertheless, it should be helpful to explicitly mention a few points here."
        },
        {
          "type": "rust",
          "id": "C55Lmpb@L",
          "title": "Immutable by Default",
          "instructions": "In Rust, variables are immutable by default. This means you cannot change the value after declaration. Of course, sometimes you might want to change the value later on, so you can opt\\-in to mutability using the `mut` keyword\\.\n\nUpdate the code in the editor by making variables mutable. The `immutable_by_default` function should be invoked twice.\n\n> Use the `mut` keyword intentionally. When you see a mutable variable, it means the original programmer _intended_ for that variable to change later on. This conveys useful information, and it is important it is an opt\\-in behavior. \n> \n> Use `mut` only when you need it.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: u128 = immutable_by_default(807);\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `immutable_by_default` function should be invoked twice.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const matched = CODE_STRING.replace(/ /g, \"\").match(\n    /immutable_by_default\\(/g\n  ).length;\n  expect(matched).toBe(3);\n});\n\ntest(\"Two variables should be made mutable using the `mut` keyword.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const matched = CODE_STRING.replace(/ /g, \"\").match(/letmut/g).length;\n  expect(matched).toBe(2);\n});\n",
          "videoUrl": "",
          "starterCode": "fn immutable_by_default(input: u128) -> u128 {\n  let value = 52;\n\n  value = input;\n\n  value\n}\n\nlet result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "solutionCode": "fn immutable_by_default(input: u128) -> u128 {\n  let mut value = 52;\n\n  value = input;\n\n  value\n}\n\nlet mut result = immutable_by_default(41);\nprintln!(\"Result 2 is: {:?}\", result);\n\nresult = immutable_by_default(502);\nprintln!(\"Result 1 is: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "dMMvFPvNS",
          "title": "Variable Shadowing",
          "instructions": "While variables are immutable by default, it is in fact possible to change immutable variables values by redeclaring them with the same name. This is called variable shadowing. To shadow a variable, you simply declare it again using the `let` keyword\\.\n\nThe code in the editor tries to update the `name` variable\\. Allow this to work by using variable shadowing—do not use the `mut` keyword\\.\n\n> Shadowing, although perhaps a bit unusual, is useful when working with values which need to be updated or redeclared \\(even, changing to a different type\\) throughout a program. Specifically, shadowing helps the programmer avoid coming up with a new name for the variable.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\ntest(\"The `name` variable should be shadowing and printed out for a total of 5 times.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const count = CODE_STRING.replace(/ /g, \"\").match(/letname=/g).length;\n  expect(count).toBe(5);\n});\n",
          "videoUrl": "",
          "starterCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "solutionCode": "fn variable_shadowing() {\n  let name = \"Sam\";\n  println!(\"[1] The name is: {:?}\", name);\n\n  let name = \"Joe\";\n  println!(\"[2] The name is: {:?}\", name);\n\n  let name = \"Ryan\";\n  println!(\"[3] The name is: {:?}\", name);\n\n  let name = \"Sara\";\n  println!(\"[4] The name is: {:?}\", name);\n\n  let name = 52;\n  println!(\"[5] The name is: {:?}\", name);\n}\n\nvariable_shadowing();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ohaohA5x9",
          "title": "Constants",
          "instructions": "You can also declare constants in Rust. Constants are like variables but their value is fixed at compile time and not subject to change throughout the life of the program. Constants are declared with the `const` keyword, are always immutable, and must have an explicit type annotation. Constants can be declared in any scope, including the global scope. They are ideal for global values which do not change throughout the life of a program.\n\nAdd type annotations to the constants in the editor so the code compiles.\n\n> For the string type, try to use the string slice reference type `&str`. We will cover strings more in detail later.\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let x = DEBUG;\n  let y = MAX_HEIGHT;\n  let z = NAME;\n\n  true\n}\n`;\n\ntest(\"The three constants should be initialized correctly and the code should compile.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const DEBUG = false;\n\nconst MAX_HEIGHT = 52;\n\nconst NAME = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "solutionCode": "const DEBUG: bool = false;\n\nconst MAX_HEIGHT: i64 = 52;\n\nconst NAME: &str = \"Pairwise\";\n\nprintln!(\"DEBUG value: {:?}\", DEBUG);\nprintln!(\"MAX_HEIGHT value: {:?}\", MAX_HEIGHT);\nprintln!(\"NAME value: {:?}\", NAME);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "o0UpOqzg3",
          "title": "Functions",
          "instructions": "So far we've seen several functions, so you should have the basics down by now. But there is one important function we have not seen yet: the `main` function\\. Since we are working within the Pairwise workspace, some of the details of how to setup, compile, and run Rust code are hidden away \\(for now...\\).\n\nIn Rust, the entry point to a program is a `main` function\\. This is where everything starts, and it must be defined.\n\nIn the editor below, define a `main` function which returns the boolean `true`.\n\n> In the Pairwise workspace, we are taking your code from the editor below and wrapping it in the other code required to run a Rust program, e.g. the `main` function, and the test code for each challenge. This is all being compiled and run with the output captured to determine if you passed or failed the tests.\n> \n> The purpose of this is to get you off the ground quickly writing Rust code without having to deal with setup tasks like downloading the Rust compiler and learning how to use it \\(although, this is not that hard\\).\n> \n> But don't worry\\! We will cover these topics later in this course and by the end you will be compiling your own Rust code like a pro.\n\n\n",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  let result: bool = main();\n\n  return result;\n}\n`;\n\ntest(\"The `main` function should be defined and should return `true`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "// Write your code here\nfn  main() -> bool {\n  true\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "eTZNP3td8",
          "title": "Returning Values from Functions",
          "instructions": "There are two ways to return values from functions, using the explicit `return` keyword and also by just writing the final value as an expression with no semicolon. \"Early\" returns are often written using the `return` keyword while it is somewhat standard for a return at the end of the function to be written as a standalone expression.\n\nThe `different_ways_to_return` contains three expressions for different conditions. Modify the function to return these three expressions. Try to return the final expression without using the `return` keyword\\.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  assert_eq!(different_ways_to_return(-5), \"Value is less than zero\");\n  assert_eq!(different_ways_to_return(0), \"Value is zero\");\n  assert_eq!(different_ways_to_return(5), \"Value is greater than zero\");\n\n  true\n}\n`;\n\ntest(\"The `different_ways_to_return` function should compile and return different string slices based on the input value.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Don't worry about this 'static on the return parameter yet.\n// This is a lifetime parameter, which instructs the Rust compiler\n// how long the return value can live.\nfn different_ways_to_return(val: i32) -> &'static str {\n  // We will see more on if/else statements soon\n  if val == 0 {\n    \"Value is zero\";\n  }\n\n  if val < 0 {\n    \"Value is less than zero\";\n  }\n\n  // Final expression is returned from the function,\n  // without the need for a return keyword\n  \"Value is greater than zero\";\n}\n\nprintln!(\"Checking -5: {:?}\", different_ways_to_return(-5));\nprintln!(\"Checking 0: {:?}\", different_ways_to_return(0));\nprintln!(\"Checking +5: {:?}\", different_ways_to_return(5));",
          "solutionCode": "// Don't worry about this 'static on the return parameter yet.\n// This is a lifetime parameter, which instructs the Rust compiler\n// how long the return value can live.\nfn different_ways_to_return(val: i32) -> &'static str {\n  // We will see more on if/else statements soon\n  if val == 0 {\n    return \"Value is zero\";\n  }\n\n  if val < 0 {\n    return \"Value is less than zero\";\n  }\n\n  // Final expression is returned from the function,\n  // without the need for a return keyword\n  \"Value is greater than zero\"\n}\n\nprintln!(\"Checking -5: {:?}\", different_ways_to_return(-5));\nprintln!(\"Checking 0: {:?}\", different_ways_to_return(0));\nprintln!(\"Checking +5: {:?}\", different_ways_to_return(5));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "jLTXZFPZt",
          "title": "Multiply Floats",
          "instructions": "Write a function from scratch to take two `f64` numbers and multiply them together and return the result.",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  fn _mult(x: f64, y: f64) -> f64 {\n    x * y\n  }\n\n  let a = 5.231231;\n  let b = 7.912381;\n\n  let result = multiply(a, b);\n  let expected = _mult(a, b);\n  assert_eq!(result, expected);\n\n  true\n}\n`;\n\ntest(\"The `multiply` function should exist and return the result of multiplying its two arguments together.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Your code here",
          "solutionCode": "// Multiple function\nfn multiply(x: f64, y: f64) -> f64 {\n  x * y\n}",
          "content": ""
        },
        {
          "type": "section",
          "id": "owXHK17s4",
          "title": "Control Flow",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust contains many of the common control flow structures you will be familiar with from other programming languages. We will cover those in this section, along with a few other patterns which are unique and common to Rust, such as:\n\n* If/else statements\n* Iterators and loops\n* Match statements\n\n"
        },
        {
          "type": "rust",
          "id": "@i3sE3J3Q",
          "title": "Creating Conditional If Statements",
          "instructions": "Rust supports if/else statements which work in the expected way. Complete the `conditionals` function so all of the assertions are valid.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = conditionals(-5);\n  assert_eq!(result, String::from(\"The value is negative.\"));\n\n  let result = conditionals(0);\n  assert_eq!(result, String::from(\"The value is zero.\"));\n\n  let result = conditionals(52);\n  assert_eq!(result, String::from(\"The value is positive.\"));\n\n  true\n}\n`;\n\ntest(\"The `conditionals` function should return the `String` values specified in the `assert_eq!` assertions depending on whether the input is positive, negative, or zero.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Implement the body of this function using if/else expressions\nfn conditionals(value: i64) -> String {\n  // Write your code here\n}\n\nlet result = conditionals(-5);\nassert_eq!(result, String::from(\"The value is negative.\"));\n\nlet result = conditionals(0);\nassert_eq!(result, String::from(\"The value is zero.\"));\n\nlet result = conditionals(52);\nassert_eq!(result, String::from(\"The value is positive.\"));",
          "solutionCode": "// Implement the body of this function using if/else expressions\nfn conditionals(value: i64) -> String {\n  if value < 0 {\n    String::from(\"The value is negative.\")\n  } else if value == 0 {\n    String::from(\"The value is zero.\")\n  } else {\n    String::from(\"The value is positive.\")\n  }\n}\n\nlet result = conditionals(-5);\nassert_eq!(result, String::from(\"The value is negative.\"));\n\nlet result = conditionals(0);\nassert_eq!(result, String::from(\"The value is zero.\"));\n\nlet result = conditionals(52);\nassert_eq!(result, String::from(\"The value is positive.\"));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "lqTN5PoAV",
          "title": "Conditional Expressions Require Booleans",
          "instructions": "Unlike in some other languages, conditional expressions in Rust _must_ evaluate to a boolean value. There is no implicit coercion. Consider this point and then correct the code in the editor.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `conditions_require_booleans` function should compile.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn conditions_require_booleans() {\n  let value: u32 = 500;\n\n  if value {\n    println!(\"Value exists: {}\", value);\n  }\n\n  let name: &str = \"Joseph\";\n\n  if name {\n    println!(\"Name exists: {}\", name);\n  }\n}\n\nconditions_require_booleans();",
          "solutionCode": "fn conditions_require_booleans() {\n  let value: u32 = 500;\n\n  if value == 500 {\n    println!(\"Value exists: {}\", value);\n  }\n\n  let name: &str = \"Joseph\";\n\n  if name == \"Joseph\" {\n    println!(\"Name exists: {}\", name);\n  }\n}\n\nconditions_require_booleans();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "QHQPQktNv",
          "title": "Assigning Values with a Conditional Expression",
          "instructions": "Rust also supports using an `if` expression to define a variable directly. This is similar to a ternary expression in other languages \\(something that Rust does not support\\). The code in the editor is a little mixed up though. See if you can correct it.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = is_a_greater_than_b(5, 10);\n  assert_eq!(result, false);\n\n  let result = is_a_greater_than_b(50, 10);\n  assert_eq!(result, true);\n  true\n}\n`;\n\ntest(\"The `is_a_greater_than_b` function should return `true` if the provided argument `a` is greater than `b`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn is_a_greater_than_b(a: i128, b: i128) -> bool {\n  let greater_than = if a > b { false } else { true };\n\n  greater_than\n}\n\nlet result = is_a_greater_than_b(5, 10);\nassert_eq!(result, false);\n\nlet result = is_a_greater_than_b(50, 10);\nassert_eq!(result, true);",
          "solutionCode": "fn is_a_greater_than_b(a: i128, b: i128) -> bool {\n  let greater_than = if a > b { true } else { false };\n\n  greater_than\n}\n\nlet result = is_a_greater_than_b(5, 10);\nassert_eq!(result, false);\n\nlet result = is_a_greater_than_b(50, 10);\nassert_eq!(result, true);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "vB5grXNR8",
          "title": "Loop Expressions",
          "instructions": "The `loop` keyword always you to repeat an action indefinitely. Fix the code below to `break` out of the loop after `x` is reassigned to the `target_value`.\n\n> NOTE: The code execution will be aborted after about 10 seconds if it does not finishing running.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let value = 283;\n  let result = loops_are_dangerous(value);\n  assert_eq!(result, value);\n\n  true\n}\n`;\n\ntest(\"The `loops_are_dangerous` function should `break` out of the loop after assigning `target_value` to `x`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn loops_are_dangerous(target_value: u32) -> u32 {\n  let mut x: u32 = 5;\n\n  // There is really no point to this code, except to demonstrate\n  // the loop construct.\n  loop {\n    x = target_value;\n  }\n\n  x\n}\n\nlet value = 500;\nlet result = loops_are_dangerous(value);\nassert_eq!(result, value);\nprintln!(\"Result = {}\", result);",
          "solutionCode": "fn loops_are_dangerous(target_value: u32) -> u32 {\n  let mut x: u32 = 5;\n\n  // There is really no point to this code, except to demonstrate\n  // the loop construct.\n  loop {\n    x = target_value;\n    break;\n  }\n\n  x\n}\n\nlet value = 500;\nlet result = loops_are_dangerous(value);\nassert_eq!(result, value);\nprintln!(\"Result = {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "UIQ8YPdV7",
          "title": "Using Loop Expressions to Assign Values",
          "instructions": "Loops can also be used to assign values, similar to `if/else` blocks\\. This may be useful if you need to an attempt an operation which may fail and needs to be retried. Take a look at the code in the editor, and then return a `String` from the `get_result` function to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result: String = get_result();\n\n  true\n}\n`;\n\ntest(\"The `get_result` function should return a `String` which should be assigned to the `result` variable in the loop expression.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn get_result() -> String {\n  // Write your code here\n}\n\nfn retry_logic() {\n  // A counter to limit retries\n  let mut attempts_remaining = 5;\n\n  let result: String = loop {\n    // Decrement remaining retry amounts\n    attempts_remaining = attempts_remaining - 1;\n\n    // This contrived code artificially just returns the result\n    // when the retry reaches zero, you can imagine in reality\n    // the operation would either succeed or fail after the retry\n    // limit is reached.\n    if attempts_remaining == 0 {\n      break get_result();\n    }\n  };\n\n  println!(\"The result is: {}\", result);\n}\n\nretry_logic();",
          "solutionCode": "fn get_result() -> String {\n  String::from(\"Imagine this is the data from some request which may fail at first.\")\n}\n\nfn retry_logic() {\n  // A counter to limit retries\n  let mut attempts_remaining = 5;\n\n  let result: String = loop {\n    // Decrement remaining retry amounts\n    attempts_remaining = attempts_remaining - 1;\n\n    // This contrived code artificially just returns the result\n    // when the retry reaches zero, you can imagine in reality\n    // the operation would either succeed or fail after the retry\n    // limit is reached.\n    if attempts_remaining == 0 {\n      break get_result();\n    }\n  };\n\n  println!(\"The result is: {}\", result);\n}\n\nretry_logic();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "UwDUOEzL5",
          "title": "While Loops",
          "instructions": "Rust also provides standard `while` loops to execute some operations while a condition is true. Complete the body of the `add_all_up_to_limit` function to use a `while` loop to calculate the total sum of all numbers from zero up to and including the given `limit`. For instance, the total sum for `3` would be `0 + 1 + 2 + 3 = 6`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = add_all_up_to_limit(4);\n  assert_eq!(result, 10);\n\n  let result = add_all_up_to_limit(17);\n  assert_eq!(result, 153);\n\n  let result = add_all_up_to_limit(48);\n  assert_eq!(result, 1176);\n\n  true\n}\n`;\n\ntest(\"The `add_all_up_to_limit` function should return the sum of all numbers from zero up to the provided `limit`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add_all_up_to_limit(limit: u128) -> u128 {\n  // Write your code here\n}\n\nlet result = add_all_up_to_limit(3);\nassert_eq!(result, 6);\nprintln!(\"add_all_up_to_limit(3)  = {}\", result);\n\nlet result = add_all_up_to_limit(15);\nassert_eq!(result, 120);\nprintln!(\"add_all_up_to_limit(15) = {}\", result);\n\nlet result = add_all_up_to_limit(53);\nassert_eq!(result, 1431);\nprintln!(\"add_all_up_to_limit(53) = {}\", result);",
          "solutionCode": "fn add_all_up_to_limit(limit: u128) -> u128 {\n  let mut total: u128 = 0;\n  let mut current: u128 = 0;\n\n  while current <= limit {\n    total = total + current;\n    current = current + 1;\n  }\n\n  total\n}\n\nlet result = add_all_up_to_limit(3);\nassert_eq!(result, 6);\nprintln!(\"add_all_up_to_limit(3)  = {}\", result);\n\nlet result = add_all_up_to_limit(15);\nassert_eq!(result, 120);\nprintln!(\"add_all_up_to_limit(15) = {}\", result);\n\nlet result = add_all_up_to_limit(53);\nassert_eq!(result, 1431);\nprintln!(\"add_all_up_to_limit(53) = {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ONCKyRCRf7",
          "title": "Iteration With For Loops",
          "instructions": "Although the `loop` and `while` expressions are available to use, it is generally preferable to use other iteration patterns which reduce the need for manually tracking the looping logic. It's always pleasant to avoid potential infinite loops.\n\nWith arrays and other collections we will see later, we can easily iterate through their members using a `for .. in` syntax\\. Finish the `iterate_names_array` function to use the `for .. in` syntax to iterate through the given `names_array`. You can turn an array into an iterator to use in the `for .. in` expression using the `iter()` method\\.\n\nUse a for loop to iterate through the given `names_array` and create a new array containing the reversed order of the names. You can use some indexing math to create this new array as your iterate through the for loop. Try to avoid using any built\\-in reverse methods.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut names: [&str; 5] = [\n    \"Sara\",\n    \"Ryan\",\n    \"Ben\",\n    \"Sam\",\n    \"Eddie\",\n  ];\n\n  // Get code result\n  let result = iterate_and_reverse_names_array(names);\n\n  // Reverse original list\n  names.reverse();\n  let names_reversed = names;\n\n  // Assert result\n  assert_eq!(result, names_reversed);\n\n  true\n}\n`;\n\ntest(\"The `iterate_and_reverse_names_array` function should return an array of names in the reverse order of the given `names_array`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "let names: [&str; 5] = [\n  \"Sam\",\n  \"Ryan\",\n  \"Joe\",\n  \"Sara\",\n  \"Ben\",\n];\n\nfn iterate_and_reverse_names_array(names_array: [&str; 5]) -> [&str; 5] {\n  // Implement your solution here\n  //\n  // NOTE: Try to use a for..in loop, do not use any built-in\n  // reverse methods ;)\n}\n\nlet result = iterate_and_reverse_names_array(names);\nprintln!(\"Original list of names: {:?}\", names);\nprintln!(\"Reversed list of names: {:?}\", result);\n",
          "solutionCode": "let names: [&str; 5] = [\n  \"Sam\",\n  \"Ryan\",\n  \"Joe\",\n  \"Sara\",\n  \"Ben\",\n];\n\nfn iterate_and_reverse_names_array(names_array: [&str; 5]) -> [&str; 5] {\n  let mut reversed_list: [&str; 5] = [\"\", \"\", \"\", \"\", \"\"];\n  let mut index: usize = 5;\n\n  for name in names_array.iter() {\n      println!(\"The current name is: {}\", name);\n      index = index - 1;\n      reversed_list[index] = name;\n  }\n\n  return reversed_list;\n}\n\nlet result = iterate_and_reverse_names_array(names);\nprintln!(\"Original list of names: {:?}\", names);\nprintln!(\"Reversed list of names: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "@orxFOEdD",
          "title": "Structs and Enums",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust structures \"structs\" are a way to group several related values into a single meaningful group."
        },
        {
          "type": "rust",
          "id": "rONYoxCYV",
          "title": "Struct Definition",
          "instructions": "Struct are defined using the `struct` keyword\\. Like tuples, they can contain data of different types. Unlike tuples they have a much more defined structure which conveys more meaning and makes data access easier.\n\nWe've defined a struct in the editor below representing a rectangle. In the `create_rectangle` function, return a new instance of this struct whose fields match the parameters given to the function. You can create a new instance of a struct by writing its name followed by `{...}` brackets within which you defined the struct fields.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let x: u32 = 5;\n  let y: u32 = 10;\n  let width: u32 = 25;\n  let height: u32 = 50;\n  let rect = create_rectangle(x, y, width, height);\n  assert_eq!(rect.x, x);\n  assert_eq!(rect.y, y);\n  assert_eq!(rect.width, width);\n  assert_eq!(rect.height, height);\n\n  true\n}\n`;\n\ntest(\"The `create_rectangle` function should return a new `Rect` struct matching the parameters given to it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn create_rectangle(x: u32, y: u32, width: u32, height: u32) -> Rect {\n  // Write your code here\n}\n\nlet rect = create_rectangle(5, 10, 25, 50);\nprintln!(\"Rectangle Struct: {:?}\", rect);",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn create_rectangle(x: u32, y: u32, width: u32, height: u32) -> Rect {\n  // Write your code here\n  Rect {\n    x,\n    y,\n    width,\n    height\n  }\n}\n\nlet rect = create_rectangle(5, 10, 25, 50);\nprintln!(\"Rectangle Struct: {:?}\", rect);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "rONYaskiU",
          "title": "Create a New Struct",
          "instructions": "Let's get some more practice defining structs. This challenge is similar to the last but here we will start with an empty editor\\! Review the test cases to solve the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let radius: u32 = 51231;\n  let mass: u32 = 9701731;\n  let inhabitants: u32 = 712231;\n  let planet = create_planet(radius, mass, inhabitants);\n  assert_eq!(planet.radius, radius);\n  assert_eq!(planet.mass, mass);\n  assert_eq!(planet.inhabitants, inhabitants);\n\n  true\n}\n`;\n\ntest(\"A `create_planet` function should exist and return a new `Planet` struct, which has the following `u32` fields: `radius`, `mass`, `inhabitants`. The function signature should accept these three fields, in that order, as parameters to initalize the `Planet` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "#[derive(Debug)]\nstruct Planet {\n  radius: u32,\n  mass: u32,\n  inhabitants: u32,\n}\n\nfn create_planet(radius: u32, mass: u32, inhabitants: u32) -> Planet {\n  // Fields can be initialized directly like this if a variable of\n  // matching type exists in the same scope:\n  let planet = Planet {\n    radius,\n    mass,\n    inhabitants,\n  };\n\n  planet\n}\n\nlet planet = create_planet(791231, 13211231, 1231311);\nprintln!(\"Planet Struct: {:?}\", planet);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "PvQraNq37",
          "title": "Reading Struct Fields",
          "instructions": "Accessing a field on a struct can be done using the dot syntax, e.g.` user.first_name`. Complete the `get_rectangle_area` function to return the area of the given rectangle.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let rect = Rect {\n    x: 5,\n    y: 5,\n    width: 102,\n    height: 908,\n  };\n  let result = get_rectangle_area(rect);\n  assert_eq!(result, 102 * 908);\n\n  true\n}\n`;\n\ntest(\"The `get_rectangle_area` function should return the `u32` area of the rectangle given to it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn get_rectangle_area(rect: Rect) -> u32 { \n  // Write your code here:\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nlet area = get_rectangle_area(rect);\nprintln!(\"Rectangle Area: {:?}\", area);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn get_rectangle_area(rect: Rect) -> u32 { \n  rect.width * rect.height\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nlet area = get_rectangle_area(rect);\nprintln!(\"Rectangle Area: {:?}\", area);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "jQdiNPjQJK",
          "title": "Updating Struct Fields",
          "instructions": "How can we update the fields of a struct? Well, you can set them similar to how you would set a variable. Try to complete the function in the editor below.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n  // Returns a boolean representing challenge test status.\n  fn test() -> bool {\n    let rect = Rect {\n    x: 5,\n    y: 5,\n    width: 100,\n    height: 50,\n  };\n\n  let resized = resize_rectangle(rect, 500, 500);\n  assert_eq!(resized.width, 500);\n  assert_eq!(resized.height, 500);\n\n  true\n}\n`;\n\ntest(\"The `original_rect` function should return a struct matching the `original_rect` struct it receives as an argument but with update `width` and `height` properities.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\nfn resize_rectangle(original_rect: Rect, new_width: u32, new_height: u32) -> Rect { \n  // Write your code here:\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nprintln!(\"[1] Original Rectangle: {:?}\", rect);\nlet resized = resize_rectangle(rect, 500, 500);\nprintln!(\"[2] Resized Rectangle: {:?}\", resized);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Rect {\n  x: u32,\n  y: u32,\n  width: u32,\n  height: u32,\n}\n\n// First, we must make the original_rect argument mutable,\n// in order to change it. We could also, alternatively, create\n// a new rectangle in the function body and return that instead.\nfn resize_rectangle(mut original_rect: Rect, new_width: u32, new_height: u32) -> Rect { \n  // We can access and update the fields directly like this:\n  original_rect.width = new_width;\n  original_rect.height = new_height;\n  original_rect\n}\n\nlet rect = Rect {\n  x: 5,\n  y: 5,\n  width: 100,\n  height: 50,\n};\n\nprintln!(\"[1] Original Rectangle: {:?}\", rect);\nlet resized = resize_rectangle(rect, 500, 500);\nprintln!(\"[2] Resized Rectangle: {:?}\", resized);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "OsWEvgL6e",
          "title": "Struct Update Syntax",
          "instructions": "There is a special syntax for copying existing struct fields onto a new struct, which is useful when creating or updating structs. This syntax is the `..` struct update syntax and it will \"spread\" all the struct fields of one struct onto another. Consider this code:\n\n```\n// Create an item, using all the fields from an\n// existing 'other_item' and set a new id field.\nlet item = Item {\n    // Set the id field\n    id: get_random_id(),\n    // Include whatever other fields are in the\n    // other_item (imagine it is defined above)\n    // which are NOT already set above.\n    //\n    // Note that this syntax uses two dots and no\n    // comma at the end.\n    ..other_item\n}\n\n```\n\nIn the editor below, use the `..` struct update syntax to complete the `create_additional_tree_in_forest` function\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let forest = String::from(\"Pinegrove\");\n  let caretaker = String::from(\"Eddie\");\n  let tree_type = TreeTypes::Cedar;\n  let tree = Tree {\n    tree_type,\n    forest: String::from(&forest),\n    caretaker: String::from(&caretaker),\n    height: 52,\n    number_of_branches: 217,\n    number_of_bird_nests: 8,\n  };\n\n  let result = create_additional_tree_in_forest(tree, 88, 312, 14);\n  assert_eq!(result.forest, forest);\n  assert_eq!(result.caretaker, caretaker);\n  assert_eq!(result.height, 88);\n  assert_eq!(result.number_of_branches, 312);\n  assert_eq!(result.number_of_bird_nests, 14);\n\n  true\n}\n`;\n\ntest(\"The `create_additional_tree_in_forest` function should return a `Tree` struct matching the struct given to it with the additional fields provided as parameters.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum TreeTypes {\n  Sycamore,\n  Cedar,\n  Oak,\n  Redwood,\n  Pine,\n}\n\n#[derive(Debug)]\nstruct Tree {\n  tree_type: TreeTypes,\n  forest: String,\n  caretaker: String,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n}\n\nfn create_additional_tree_in_forest(\n  tree: Tree,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n  ) -> Tree {\n    // Write your code here\n};\n\nlet tree = Tree {\n  tree_type: TreeTypes::Cedar,\n  forest: String::from(\"Pinegrove\"),\n  caretaker: String::from(\"Eddie\"),\n  height: 52,\n  number_of_branches: 217,\n  number_of_bird_nests: 6,\n};\n\nprintln!(\"Original Tree: {:?}\", tree);\nlet result = create_additional_tree_in_forest(tree, 88, 312, 14);\nprintln!(\"New Tree: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nenum TreeTypes {\n  Sycamore,\n  Cedar,\n  Oak,\n  Redwood,\n  Pine,\n}\n\n#[derive(Debug)]\nstruct Tree {\n  tree_type: TreeTypes,\n  forest: String,\n  caretaker: String,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n}\n\nfn create_additional_tree_in_forest(\n  tree: Tree,\n  height: u32,\n  number_of_branches: u32,\n  number_of_bird_nests: u32,\n  ) -> Tree {\n    Tree {\n      height,\n      number_of_branches,\n      number_of_bird_nests,\n      ..tree\n    }\n}\n\nlet tree = Tree {\n  tree_type: TreeTypes::Cedar,\n  forest: String::from(\"Pinegrove\"),\n  caretaker: String::from(\"Eddie\"),\n  height: 52,\n  number_of_branches: 217,\n  number_of_bird_nests: 6,\n};\n\nprintln!(\"Original Tree: {:?}\", tree);\nlet result = create_additional_tree_in_forest(tree, 88, 312, 14);\nprintln!(\"New Tree: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "l0YwrWngu",
          "title": "Tuple Structs",
          "instructions": "Structs can also be defined as tuples. Tuple structs are regular tuples, but have a distinct type and name and also lack the additional field names of a regular struct. They are appropriate for certain use cases. Take a look at the code in the editor and complete the `are_players_on_same_space` to solve the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut a = Coordinate(5, 2);\n  let mut b = Coordinate(5, 2);\n  let mut same_space = are_players_on_same_space(a, b);\n  assert_eq!(same_space, true);\n\n  a = Coordinate(5, 2);\n  b = Coordinate(5, 1);\n  same_space = are_players_on_same_space(a, b);\n  assert_eq!(same_space, false);\n\n  true\n}\n`;\n\ntest(\"The `are_players_on_same_space` function should return `true` if the two given coordiantes represent the same space.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// (x, y) coordinate representing position on a board\nstruct Coordinate(i32, i32);\n\nfn are_players_on_same_space(a_coordinate: Coordinate, b_coordinate: Coordinate) -> bool {\n  // Your code here\n}\n\nlet mut a = Coordinate(5, 2);\nlet mut b = Coordinate(5, 2);\n\nlet mut same_space = are_players_on_same_space(a, b);\nprintln!(\"[1] Same Space: {}\", same_space);\n\na = Coordinate(5, 2);\nb = Coordinate(5, 1);\n\nsame_space = are_players_on_same_space(a, b);\nprintln!(\"[2] Same Space: {}\", same_space);",
          "solutionCode": "// (x, y) coordinate representing position on a board\nstruct Coordinate(i32, i32);\n\nfn are_players_on_same_space(a_coordinate: Coordinate, b_coordinate: Coordinate) -> bool {\n  let same_x = a_coordinate.0 == b_coordinate.0;\n  let same_y = a_coordinate.1 == b_coordinate.1;\n\n  same_x && same_y\n}\n\nlet mut a = Coordinate(5, 2);\nlet mut b = Coordinate(5, 2);\n\nlet mut same_space = are_players_on_same_space(a, b);\nprintln!(\"[1] Same Space: {}\", same_space);\n\na = Coordinate(5, 2);\nb = Coordinate(5, 1);\n\nsame_space = are_players_on_same_space(a, b);\nprintln!(\"[2] Same Space: {}\", same_space);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Unlagm$ty",
          "title": "Implementing Struct Methods I",
          "instructions": "We have seen how to define struct fields which contain data. Now we will look at how we can implement methods on structs to associate specific behavior or functionality with a struct. Struct methods are defined in implementation blocks signified by the `impl` keyword and in their series of arguments always receive the current instance of the struct as a `self` argument\\.\n\nThe `Person` struct in the editor below has an empty `say_hello` implementation started. Complete this to return a `String` of the given person saying hello.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let name = String::from(\"Frank\");\n  let age = 25;\n\n  let sam = Person {\n    name,\n    age,\n  };\n\n  let result = sam.say_hello();\n  let expected = String::from(\"Hello, my name is Frank!\");\n  assert_eq!(result, expected);\n\n  let name = String::from(\"Vivian\");\n  let age = 25;\n\n  let vivian = Person {\n    name,\n    age,\n  };\n\n  let result = vivian.say_hello();\n  let expected = String::from(\"Hello, my name is Vivian!\");\n  assert_eq!(result, expected);\n\n  true\n}\n`;\n\ntest(\"The `Person` struct `say_hello` implementation should return a `String` saying hello for the given person, like this: `Hello, my name is Eddie!`\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  // Return a string hello message of the pattern: Hello, my name is <name>!\n  // This method implementation takes as an argument a reference to\n  // the current instance of the struct, denoted by &self.\n  // We will see more on references in future challenges.\n  fn say_hello(&self) -> String {\n    // Implement this method, note you can use the format!\n    // macro just like println! to interpolate a variable into\n    // a string. The format! macro returns a String, just what\n    // we need to return here.\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nsam.say_hello();\n",
          "solutionCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn say_hello(&self) -> String {\n    format!(\"Hello, my name is {}!\", self.name)\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nlet x = sam.say_hello();\nprintln!(\"{}\", x);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Unlaaiu1P",
          "title": "Implementing Struct Methods II",
          "instructions": "We have our same `Person` from the last challenge in the editor below. This time, create a new `impl` block which implements a function `can_vote` which returns whether the given person is 18 or older.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let name = String::from(\"Frank\");\n  let age = 25;\n\n  let sam = Person {\n    name,\n    age,\n  };\n\n  let result = sam.can_vote();\n  assert_eq!(result, true);\n\n  let name = String::from(\"Vivian\");\n  let age = 12;\n\n  let vivian = Person {\n    name,\n    age,\n  };\n\n  let result = vivian.can_vote();\n  assert_eq!(result, false);\n\n  true\n}\n`;\n\ntest(\"The `Person` struct `say_hello` implementation should return a `String` saying hello for the given person, like this: `Hello, my name is Eddie!`\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\n// Your code here\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n}\n\nimpl Person {\n  fn can_vote(&self) -> bool {\n    self.age >= 18\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person {\n  name,\n  age,\n};\n\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "fisyTm$ty",
          "title": "Struct Associated Functions",
          "instructions": "Struct `impl` blocks may also implement standalone functions which can be invoked with the `::` syntax\\. These are called associated functions are return an instance of the struct they are implement on. They _do not_ receive a reference to `self` as a parameter. A common example of this is the `String::from(\"...\")` method\\.\n\nA typical use of associated functions is to implement a `new` method for a struct. Take a look at the editor below. We've modified our code from the last two challenges to now set a field `can_vote` on our `Person` struct\\. We can now assign this field in a `new` associated function.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let name = String::from(\"Frank\");\n  let age = 25;\n  let sam = Person::new(name, age);\n  let can_vote = sam.can_vote();\n  assert_eq!(can_vote, true);\n\n  let name = String::from(\"Vivian\");\n  let age = 12;\n  let vivian = Person::new(name, age);\n  let can_vote = vivian.can_vote();\n  assert_eq!(can_vote, false);\n\n  true\n}\n`;\n\ntest(\"The `Person` struct `new` associated function should be implemented and return new `Person` instances with the `can_vote` property assigned correctly.`\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n  can_vote: bool,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n    // Define and return a new Person here, assigning\n    // the can_vote field based on if the given age\n    // is over 18 or not.\n  }\n\n  fn can_vote(&self) -> bool {\n    self.can_vote\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person::new(name, age);\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Person {\n  name: String,\n  age: u32,\n  can_vote: bool,\n}\n\nimpl Person {\n  fn new(name: String, age: u32) -> Person {\n    let can_vote = age >= 18;\n    Person {\n      name,\n      age,\n      can_vote,\n    }\n  }\n\n  fn can_vote(&self) -> bool {\n    self.can_vote\n  }\n}\n\n// We convert a string slice to an owned String type:\nlet name = String::from(\"Sam\");\nlet age = 25;\n\nlet sam = Person::new(name, age);\nlet can_vote = sam.can_vote();\nprintln!(\"Can Sam vote? Result = {}\", can_vote);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "efEpmQap5",
          "title": "Enums",
          "instructions": "Enums, or \"enumerations\",  are a way to represent a single type which may be one of many variants. Such a type can be useful in a variety of programming scenarios. Enums can be created using the `enum` keyword and specific variants can be referenced use the enum name followed by the `::` syntax\\. Take a look at the code below to see enums in action.\n\nIn the following section, we will see more on enums and Rust's powerful pattern matching techniques which can be used to perform operations on enums and other variants.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = get_default_user_registration_stage();\n  if let UserRegistrationStage::NotStarted = result {\n    return true;\n  } else {\n    panic!(\"Expected UserRegistrationStage to be NotStarted\");\n  }\n}\n`;\n\ntest(\"The `get_default_user_registration_stage` function should the `NotStarted` variant of the `UserRegistrationStage` enum.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// An enum to represent the current stage a user is in within\n// some registration process\n#[derive(Debug)]\nenum UserRegistrationStage {\n  NotStarted,\n  EnterNameAndEmail,\n  EnterPassword,\n  PendingConfirmation,\n  RegistrationSuccessful,\n}\n\nstruct User {\n  // Imagine various user struct fields here...\n  registration_stage: UserRegistrationStage,\n}\n\nfn get_default_user_registration_stage() -> UserRegistrationStage {\n  // Write your code here\n}\n\nlet result = get_default_user_registration_stage();\nprintln!(\"Current registration stage: {:?}\", result);",
          "solutionCode": "// An enum to represent the current stage a user is in within\n// some registration process\n#[derive(Debug)]\nenum UserRegistrationStage {\n  NotStarted,\n  EnterNameAndEmail,\n  EnterPassword,\n  PendingConfirmation,\n  RegistrationSuccessful,\n}\n\nstruct User {\n  // Imagine various user struct fields here...\n  registration_stage: UserRegistrationStage,\n}\n\nfn get_default_user_registration_stage() -> UserRegistrationStage {\n  UserRegistrationStage::NotStarted\n}\n\nlet result = get_default_user_registration_stage();\nprintln!(\"Current registration stage: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "HBWCQFb6b",
          "title": "Enums Can Contain Data",
          "instructions": "The variants of an enum may also contain data. In this way, enums can be a very flexible and powerful type to use in your programs.\n\nTake a look at the `Message` enum in the editor below, which might represent messages sent on a real\\-time chat application.\n\nNow, complete the `construct_message_for_reply_to_channel` function to return a new `Message` variant of the appropriate type. To create an enum variant which includes data, simply call the variant name like a function and pass the data in, like this: `FriendsGraph::FirstOrderConnections(list_of_friends)` \\(imagine what these types and structs might represent\\).",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let author_id = \"sa09df89aas98df7as\";\n  let channel_id = \"ads9f78sa0f7sa0\";\n  let result = construct_message_for_reply_to_channel(channel_id, author_id, \"Hello!\");\n\n  if let Message::ReplyToChannel(x) = result {\n    assert_eq!(String::from(author_id), x.author_id);\n    assert_eq!(String::from(channel_id), x.channel_id);\n    return true;\n  } else {\n    panic!(\"Expected construct_message_for_reply_to_channel to return a Message::ReplyToChannel variant\");\n  }\n}\n`;\n\ntest(\"The `construct_message_for_reply_to_channel` function should return the `Message::ReplyToChannel` correctly.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct ThreadMessage {\n  thread_id: String,\n  author_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nstruct ChannelMessage {\n  thread_id: String,\n  author_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nenum Message {\n  Connected,\n  Disconnected,\n  ReplyToThread(ThreadMessage),\n  ReplyToChannel(ChannelMessage),\n}\n\nfn construct_message_for_reply_to_channel(\n  thread_id: &str,\n  author_id: &str,\n  message_content: &str) -> Message {\n  // Create a new ChannelMessage struct here, given the arguments\n  // provided above and then return it in a Message ReplyToChannel\n  // variant.\n  //\n  // HINT: You can conver tthe &str arguments to String values using\n  // String::from().\n}\n\nlet result = construct_message_for_reply_to_channel(\"asd7f8as90\", \"a89s7fdsa\", \"Hello!\");\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nstruct ThreadMessage {\n  author_id: String,\n  thread_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nstruct ChannelMessage {\n  author_id: String,\n  channel_id: String,\n  message_content: String,\n}\n\n#[derive(Debug)]\nenum Message {\n  Connected,\n  Disconnected,\n  ReplyToThread(ThreadMessage),\n  ReplyToChannel(ChannelMessage),\n}\n\nfn construct_message_for_reply_to_channel(\n  channel_id: &str,\n  author_id: &str,\n  message_content: &str) -> Message {\n  let message = ChannelMessage {\n    author_id: String::from(author_id),\n    channel_id: String::from(channel_id),\n    message_content: String::from(message_content),\n  };\n\n  Message::ReplyToChannel(message)\n}\n\nlet result = construct_message_for_reply_to_channel(\"asd7f8as90\", \"a89s7fdsa\", \"Hello!\");\nprintln!(\"Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "514h0g6Hp",
          "title": "Enums Can Contain Any Data",
          "instructions": "Enum variants can contain any data, even other enums, or no data at all. Complete the code in the editor for an illustration. After this, we will start to see how we can match against different variants of enums and other types in Rust.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = create_enum();\n  let mut matched = false;\n  match result {\n    ManyDifferentVariants::BasicVariant => {\n      matched = true;\n    }\n    ManyDifferentVariants::AdvancedVariant => {\n      matched = true;\n    }\n    ManyDifferentVariants::Numbers(x, y, z) => {\n      matched = true;\n    }\n    ManyDifferentVariants::FlagEnabled(x) => {\n      matched = true;\n    }\n    ManyDifferentVariants::ID(x) => {\n      matched = true;\n    }\n    ManyDifferentVariants::Data(x) => {\n      matched = true;\n    }\n  }\n\n  return matched;\n}\n`;\n\ntest(\"The `create_enum` function should a properly defined `ManyDifferentVariants` enum.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// This enum should include a variety of different\n// variants. Read the commented instructions and then\n// add the variants to proceed.\n#[derive(Debug)]\nenum ManyDifferentVariants {\n  // A 'BasicVariant' should exist like this:\n  BasicVariant,\n\n  // A 'AdvancedVariant' should exist:\n\n  // A 'Numbers' tuple should exist: (u32, u32, u32)\n\n  // A 'FlagEnabled' variant should exist and contain a boolean value:\n\n  // An 'ID' field should exist of a u128 type:\n\n  // A 'Data' field should exist and contain a Data struct\n  // (define the Data struct above however you like):\n}\n\nfn create_enum() -> ManyDifferentVariants {\n  // Instantiate a new ManyDifferentVariants enum here and return it\n}\n\nlet result = create_enum();\nprintln!(\"Result: {:?}\", result);\n",
          "solutionCode": "#[derive(Debug)]\nstruct Data {\n  members: [u8; 5],\n}\n\n// This enum should include a variety of different\n// variants. Read the commented instructions and then\n// add the variants to proceed.\n#[derive(Debug)]\nenum ManyDifferentVariants {\n  // A 'BasicVariant' should exist like this:\n  BasicVariant,\n\n  // A 'AdvancedVariant' should exist:\n  AdvancedVariant,\n\n  // A 'Numbers' tuple should exist: (u32, u32, u32)\n  Numbers(u32, u32, u32),\n\n  // A 'FlagEnabled' variant should exist and contain a boolean value:\n  FlagEnabled(bool),\n\n  // An 'ID' field should exist of a u128 type:\n  ID(u128),\n\n  // A 'Data' field should exist and contain a Data struct\n  // (define the Data struct above however you like):\n  Data(Data)\n}\n\nfn create_enum() -> ManyDifferentVariants {\n  // Instantiate a new ManyDifferentVariants enum here and return it\n  let data = Data {\n    members: [1, 5, 8, 2, 7],\n  };\n\n  ManyDifferentVariants::Data(data)\n}\n\nlet result = create_enum();\nprintln!(\"Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "R4TolzmG5",
          "title": "Pattern Matching",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "One of Rust's most useful and common techniques is pattern matching, which allows you to match against different variants of a particular type and then perform different actions. We have just seen one built\\-in type which can exist as one of several variants, the `enum` type\\. Rust also provides the `Result` and `Option` types, which can represent values that may be in an error/failure state or a null/non\\-existent/value\\-less state, respectively.\n\nThe compiler's strictness ensures that when you have a type which can be one of multiple variants you must handle all the possible variants. Pattern matching is one powerful way for you to do this.\n\nThese types and pattern matching against them are an indispensable part of your toolbox as a Rust programmer and will be the focus of this section."
        },
        {
          "type": "rust",
          "id": "FmcnGuM3zu",
          "title": "Pattern Matching an Enum",
          "instructions": "How can we match against different enum variants? The `match` syntax allows us to do this. We've defined an enum called `FailureStates` in the editor below and a function `map_failure_state_to_message`. Ensure that this function returns a new `String` for each failure variant.\n\nAlso notice how the Rust compiler is very helpful in explaining that the current code does not exhaustively check for different variants in the match expression. The compiler guarantees you must handle each case\\!",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut result: String = map_failure_state_to_message(FailureState::Unauthorized);\n  result = map_failure_state_to_message(FailureState::ResourceNotFound);\n  result = map_failure_state_to_message(FailureState::ResourceDeleted);\n  result = map_failure_state_to_message(FailureState::InternalError);\n\n  true\n}\n`;\n\ntest(\"The `map_failure_state_to_message` function should handle all `FailureState` variants and return a `String` message for each.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\nfn map_failure_state_to_message(failure_state: FailureState) -> String {\n  // The match expression allows us to match against several\n  // possible variants of a particular value\n  match failure_state {\n    FailureState::Unauthorized => {\n      // A 'return' express here will return the given value from the\n      // function that this match block is in\n      String::from(\"You are unauthorized to access this resource!\")\n    }\n    // Your code here\n  }\n}\n\nlet mut result = map_failure_state_to_message(FailureState::Unauthorized);\nprintln!(\"[1] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceNotFound);\nprintln!(\"[2] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceDeleted);\nprintln!(\"[3] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::InternalError);\nprintln!(\"[4] Result: {:?}\", result);\n",
          "solutionCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\nfn map_failure_state_to_message(failure_state: FailureState) -> String {\n  match failure_state {\n    FailureState::Unauthorized => {\n      String::from(\"You are unauthorized to access this resource!\")\n    }\n    FailureState::ResourceNotFound => {\n      String::from(\"Resource could not be found.\")\n    }\n    FailureState::ResourceDeleted => {\n      String::from(\"Resource was deleted.\")\n    }\n    FailureState::InternalError => {\n      String::from(\"Sorry, an internal error occurred.\")\n    }\n  }\n}\n\nlet mut result = map_failure_state_to_message(FailureState::Unauthorized);\nprintln!(\"[1] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceNotFound);\nprintln!(\"[2] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::ResourceDeleted);\nprintln!(\"[3] Result: {:?}\", result);\n\nresult = map_failure_state_to_message(FailureState::InternalError);\nprintln!(\"[4] Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "pn@ANcAKj",
          "title": "Matching Using the if let Syntax",
          "instructions": "There is another syntax which is useful for matching a single variant in isolation, the `if let` syntax\\. This is useful for performing equality checks against an enum value, for instance. Consider the following code:\n\n```\nenum Letters {\n    X,\n    Y,\n    Z,\n}\n\nlet value = Letters::X;\n\nif Letters::X = value {\n    // This code block will run\n}\n\n```\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = is_unauthorized_error(FailureState::Unauthorized);\n  assert_eq!(result, true);\n\n  let result = is_unauthorized_error(FailureState::ResourceNotFound);\n  assert_eq!(result, false);\n\n  let result = is_unauthorized_error(FailureState::ResourceDeleted);\n  assert_eq!(result, false);\n\n  let result = is_unauthorized_error(FailureState::InternalError);\n  assert_eq!(result, false);\n\n  true\n}\n`;\n\ntest(\"The `is_unauthorized_error` function should return `true` when given the `Unauthorized` variant of the `FailureState` enum, and `false` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\n// In this function, we only care about one of the enum\n// variants. For this use case, it makes sense to use an\n// 'if let' expression.\nfn is_unauthorized_error(failure_state: FailureState) -> bool {\n  // Write your code here\n}\n\nlet is_unauthorized = is_unauthorized_error(FailureState::Unauthorized);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n\nlet is_unauthorized = is_unauthorized_error(FailureState::ResourceNotFound);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n",
          "solutionCode": "#[derive(Debug)]\nenum FailureState {\n  Unauthorized,\n  ResourceNotFound,\n  ResourceDeleted,\n  InternalError,\n}\n\n// In this function, we only care about one of the enum\n// variants. For this use case, it makes sense to use an\n// 'if let' expression.\nfn is_unauthorized_error(failure_state: FailureState) -> bool {\n  if let FailureState::Unauthorized = failure_state {\n    return true;\n  }\n\n  return false;\n}\n\nlet is_unauthorized = is_unauthorized_error(FailureState::Unauthorized);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n\nlet is_unauthorized = is_unauthorized_error(FailureState::ResourceNotFound);\nprintln!(\"Is unauthorized: {}\", is_unauthorized);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "SlRfSz95Mt",
          "title": "Matching Enum Variants",
          "instructions": "Let's get some more practice matching enum variants. This is a very common pattern when writing Rust so it will be good to practice it thoroughly. In the editor below is an enum `Planet`. Write a new function `distance_from_sun` which takes a `Planet` as an argument and returns a `u128` value for the distance of each planet from the sun. Use a match statement to handle each `Planet` variant\\.\n\nOf course, the distances do not have to be accurate\\! The point here is to practice matching enums—feel free to make up any distances you like.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result: u128 = distance_from_sun(Planet::Mercury);\n  let result: u128 = distance_from_sun(Planet::Venus);\n  let result: u128 = distance_from_sun(Planet::Earth);\n  let result: u128 = distance_from_sun(Planet::Mars);\n  let result: u128 = distance_from_sun(Planet::Jupiter);\n  let result: u128 = distance_from_sun(Planet::Saturn);\n  let result: u128 = distance_from_sun(Planet::Uranus);\n  let result: u128 = distance_from_sun(Planet::Neptune);\n  let result: u128 = distance_from_sun(Planet::Pluto);\n\n  true\n}\n`;\n\ntest(\"The `distance_from_sun` function should return a `u128` representing the distance of each planet from the sun.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "enum Planet {\n  Mercury,\n  Venus,\n  Earth,\n  Mars,\n  Jupiter,\n  Saturn,\n  Uranus,\n  Neptune,\n  Pluto,\n}\n\n// Write your code here",
          "solutionCode": "enum Planet {\n  Mercury,\n  Venus,\n  Earth,\n  Mars,\n  Jupiter,\n  Saturn,\n  Uranus,\n  Neptune,\n  Pluto,\n}\n\nfn distance_from_sun(planet: Planet) -> u128 {\n  match planet {\n    Planet::Mercury => 52,\n    Planet::Venus => 123,\n    Planet::Earth => 321,\n    Planet::Mars => 521,\n    Planet::Jupiter => 3123,\n    Planet::Saturn => 7281,\n    Planet::Uranus => 98123,\n    Planet::Neptune => 321314,\n    Planet::Pluto => 1263891,\n  }\n}\n\nlet earth_distance = distance_from_sun(Planet::Earth);\nprintln!(\"Earth's Distance: {}\", earth_distance);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "ZTWdmKRlHe",
          "title": "Default Matching with the _ Placeholder",
          "instructions": "Sometimes you may find yourself matching against some enum with many variants, and you are only concerned with a few specific cases. Rust allows you to match any fall through cases with the `_` placeholder\\. Consider the code below and try to use the `_` placeholder to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = is_vowel('a');\n  assert_eq!(result, true);\n\n  let result = is_vowel('e');\n  assert_eq!(result, true);\n\n  let result = is_vowel('m');\n  assert_eq!(result, false);\n\n  let result = is_vowel('x');\n  assert_eq!(result, false);\n\n  true\n}\n`;\n\ntest(\"The `is_vowel` function should `true` for vowel characters and `false` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn is_vowel(character: char) -> bool {\n  match character {\n    'a' => true,\n    'e' => true,\n    'i' => true,\n    'o' => true,\n    'u' => true,\n  }\n}\n\nlet result = is_vowel('a');\nassert_eq!(result, true);\n\nlet result = is_vowel('e');\nassert_eq!(result, true);\n\nlet result = is_vowel('m');\nassert_eq!(result, false);\n\nlet result = is_vowel('x');\nassert_eq!(result, false);",
          "solutionCode": "fn is_vowel(character: char) -> bool {\n  match character {\n    'a' => true,\n    'e' => true,\n    'i' => true,\n    'o' => true,\n    'u' => true,\n    _ => false,\n  }\n}\n\nlet result = is_vowel('a');\nprintln!(\"Is 'a' a vowel: {}\", result);\nassert_eq!(result, true);\n\nlet result = is_vowel('e');\nprintln!(\"Is 'e' a vowel: {}\", result);\nassert_eq!(result, true);\n\nlet result = is_vowel('m');\nprintln!(\"Is 'm' a vowel: {}\", result);\nassert_eq!(result, false);\n\nlet result = is_vowel('x');\nprintln!(\"Is 'x' a vowel: {}\", result);\nassert_eq!(result, false);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "@4dmTg5UA",
          "title": "The Option Type",
          "instructions": "One of the scourges of many programmers is the so\\-called \"null pointer exception\" or generally the type of error where at runtime your program tries to access some value which it expects to exist only to find that value is null, undefined, or in some way missing.\n\nThis would not be so common if it were not possible in a variety of scenarios for such values to indeed be \"not present\". However, the devastation caused by such errors in the runtime of programs doesn't need to be the case.\n\nWith Rust, values cannot be \"null\" or \"undefined\". However, Rust does provide a way capture this potentiality using the `Option` enum\\. Yes, it's just a regular enum like we have seen, albeit a generic one:\n\n```\n// Rust's Option:\nenum Option<T> {\n    None,\n    Some(T),\n}\n\n```\n\nAn `Option` can either by \"Some\" \\(a value is present\\) or \"None\" \\(a nothing/empty/value\\-less state\\). This is the closest thing you will find in Rust to represent what is familiar as \"null\" in many other programming languages.\n\nBecause this is fundamentally an enum, we can work with it just like the other enums we have seen in the last few challenges.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = maybe_find_user_by_id(\"sa0df87sas\");\n  if let Some(x) = result {\n    panic!(\"No Some should be returned here!\");\n  }\n\n  let result = maybe_find_user_by_id(USER_ID);\n  if let Some(x) = result {\n    assert_eq!(x.id, USER_ID);\n  } else {\n    panic!(\"No None should be returned here!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `maybe_find_user_by_id` function should return a new `User` if the given `id` matches the `USER_ID`, and `None` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const USER_ID: &str = \"as897df0sa7f0dsa7df0as987df90sa\";\n\n#[derive(Debug)]\nstruct User {\n  id: &'static str,\n  name: &'static str,\n}\n\n// Imagine this is some API or database call where we may\n// find a user or not... the 'not' possibility can be represented\n// with the None variant of Rust's Option. In this case, just\n// return a new User struct when given an id matching the\n// hard-coded USER_ID above.\nfn maybe_find_user_by_id(id: &'static str) -> Option<User> {\n  // Write your code here\n}\n\n// Lookup user by random ID\nlet result = maybe_find_user_by_id(\"sa0df87sas\");\nprintln!(\"Did we find anything? -> {:?}\", result);\n\n// Lookup user by static ID\nlet result = maybe_find_user_by_id(USER_ID);\nprintln!(\"Did we find anything? -> {:?}\", result);\n\nif let Some(user) = result {\n  // Assert ids match\n  assert_eq!(user.id, USER_ID);\n}",
          "solutionCode": "const USER_ID: &str = \"as897df0sa7f0dsa7df0as987df90sa\";\n\n#[derive(Debug)]\nstruct User {\n  id: &'static str,\n  name: &'static str,\n}\n\n// Imagine this is some API or database call where we may\n// find a user or not... the 'not' possibility can be represented\n// with the None variant of Rust's Option. In this case, just\n// return a new User struct when given an id matching the\n// hard-coded USER_ID above.\nfn maybe_find_user_by_id(id: &'static str) -> Option<User> {\n  if id == USER_ID {\n    return Some(User {\n      id,\n      name: \"Samantha\",\n    })\n  }\n\n  None\n}\n\n// Lookup user by random ID\nlet result = maybe_find_user_by_id(\"sa0df87sas\");\nprintln!(\"Did we find anything? -> {:?}\", result);\n\n// Lookup user by static ID\nlet result = maybe_find_user_by_id(USER_ID);\nprintln!(\"Did we find anything? -> {:?}\", result);\n\nif let Some(user) = result {\n  // Assert ids match\n  assert_eq!(user.id, USER_ID);\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "A69i0d3FY",
          "title": "Working with Options",
          "instructions": "Let's get some more practice with the `Option` type\\. This type is pervasive in Rust code. Once you have a good feel for working with it, you will be quite happy to find that those insidious null pointer exceptions plague your code no more\\!\n\nIn the editor below is a `sum` function\\. Finish it to return the sum of all of the optional values provided to it.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = sum((\n    Some(321),\n    Some(192),\n    None,\n  ));\n  assert_eq!(result, 513);\n\n  let result = sum((\n    None,\n    None,\n    None,\n  ));\n  assert_eq!(result, 0);\n\n  let result = sum((\n    Some(2),\n    Some(2),\n    Some(2),\n  ));\n  assert_eq!(result, 6);\n\n  true\n}\n`;\n\ntest(\"The `sum` function should add up all of the values present in the `SomeValues` tuple. If any value is `None`, add zero.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// A tuple of three options\ntype SomeValues = (\n  Option<u32>,\n  Option<u32>,\n  Option<u32>,\n);\n\nfn sum(values: SomeValues) -> u32 {\n  // Add up the values in the tuple\n  // If an option is None, add 0\n}\n\nlet values: SomeValues = (\n  Some(5),\n  Some(72),\n  None,\n);\n\nlet result = sum(values);\nprintln!(\"Result: {}\", result);",
          "solutionCode": "// A tuple of three options\ntype SomeValues = (\n  Option<u32>,\n  Option<u32>,\n  Option<u32>,\n);\n\nfn sum(values: SomeValues) -> u32 {\n  let mut result = 0;\n\n  if let Some(x) = values.0 {\n    result = result + x;\n  }\n\n  if let Some(x) = values.1 {\n    result = result + x;\n  }\n\n  if let Some(x) = values.2 {\n    result = result + x;\n  }\n\n  result\n}\n\nlet values: SomeValues = (\n  Some(5),\n  Some(72),\n  None,\n);\n\nlet result = sum(values);\nprintln!(\"Result: {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "W6slZ2r0Y",
          "title": "Matching Options",
          "instructions": "In addition to use an \"if let\" expression we can also match against option enums using a `match` expression\\.  This can be appealing because it ensures both variants of the option are handled. Take a look at the code in the editor. Looks good right? Try to run it and see what the compiler has to say about it. Fix the errors to continue.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = add_one_if_value_exists(Some(10));\n  if let Some(x) = result {\n    assert_eq!(x, 11);\n  } else {\n    panic!(\"Given Some, add_one_if_value_exists should not return None\");\n  }\n\n  let result = add_one_if_value_exists(None);\n  if let Some(_x) = result {\n    panic!(\"Given None, add_one_if_value_exists should return None\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `add_one_if_value_exists` function should return an `Option` with an incremented value, if the given Option is not `None`. Given `None`, it should return `None`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add_one_if_value_exists(opt: Option<u32>) -> Option<u32> {\n  match opt {\n    Some(x) => Some(x + 1)\n  }\n}\n\nlet result = add_one_if_value_exists(Some(10));\nprintln!(\"The result is: {:?}\", result);",
          "solutionCode": "fn add_one_if_value_exists(opt: Option<u32>) -> Option<u32> {\n  match opt {\n    Some(x) => Some(x + 1),\n    None => None\n  }\n}\n\nlet result = add_one_if_value_exists(Some(10));\nprintln!(\"The result is: {:?}\", result);",
          "content": ""
        },
        {
          "type": "section",
          "id": "@VZT4$txv",
          "title": "Strings",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Strings are a more complicated data structure in Rust than in most other programming languages. In Rust there are primarily two types of strings: owned, heap\\-allocated `Strings` which are vector collections of UTF\\-8 encoded bytes and the string slice `str`.\n\nRather than explaining these in more depth here, let's dive into the challenges to see these two string variations in action."
        },
        {
          "type": "rust",
          "id": "f72ZE5IDZ",
          "title": "Creating Strings",
          "instructions": "Let's start with the owned `String` type, since it is more similar to the strings most programmers might expect when coming from other languages. A `String` in Rust is a collection from the standard library and not built in to the core language. Strings are implemented as vectors of UTF\\-8 encoded bytes and are heap\\-allocated, meaning they can grow and shrink in size during runtime. A `String` is an owned piece of data, and can be manipulated or mutated. Finally, `String`s provide several helpful methods for creating, copying, and interacting with strings.\n\n> UTF\\-8 is a character encoding character specification for representing text, specifically human language and human readable characters, in a byte format. Each character comprises one to four bytes of data and overall UTF\\-8 can encode 1,112,064 different characters. Both Strings and string slices in Rust both rely on UTF\\-8 encoding to store string data.\n\nThe `String` type provides associated methods `new` to create a new `String` and `from` to create a `String` directly from a string slice. You can also call `.to_string` on a string slice to convert it into a `String`. Complete the function in the editor below to create three new `String`s using these different methods.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let strings = create_new_strings();\n  let a: String = strings.0;\n  let b: String = strings.1;\n  let c: String = strings.2;\n\n  true\n}\n`;\n\ntest(\"The `create_new_strings` function should return three new `String`s.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn create_new_strings() -> (String, String, String) {\n  // Use the new associated method to create a new string:\n  let new_empty_string: String;\n\n  // Create a new String from a string slice:\n  let string_from_str_a: String;\n\n  // Create a String by calling the `to_string` method no a string slice:\n  let string_from_str_b: String;\n\n  (new_empty_string, string_from_str_a, string_from_str_b)\n}\n\nlet result = create_new_strings();\nprintln!(\"Result = {:?}\", result);\n",
          "solutionCode": "fn create_new_strings() -> (String, String, String) {\n  // Use the new associated method to create a new string:\n  let new_empty_string: String = String::new();\n\n  // Create a new String from a string slice:\n  let string_from_str_a: String = String::from(\"Hello,\");\n\n  // Create a String by calling the `to_string` method no a string slice:\n  let string_from_str_b: String = \"World!\".to_string();\n\n  (new_empty_string, string_from_str_a, string_from_str_b)\n}\n\nlet result = create_new_strings();\nprintln!(\"Result = {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "WMb@d9Nd@",
          "title": "Pushing Data on to a String",
          "instructions": "`String` data is fully owned and allocated on the heap, which means it can grow or shrink in size as needed. Remember, `String`s are implemented as vectors of bytes. This is helpful to remember when you are working with a `String` and struggling to perform some operation. Consider: could I do this with a vector of bytes?\n\nSpeaking of vectors, let's say we have a vector of references to string literals \\(string slices\\) `Vec<&str>`. Complete the function in the editor below to iterate through this vector and add the string slices to a new `String`, which then gets returned from the function.\n\n> Hint: You can use the `push_str` method on a `String` to concatenate additional string slices onto an existing `String`.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let v = vec![\"What\", \" \", \"is\", \" \", \"your\", \" \", \"name?\"];\n  let result = vector_to_string(v);\n  let expected = String::from(\"What is your name?\");\n  assert_eq!(expected, result);\n  true\n}\n`;\n\ntest(\"The `vector_to_string` function should return a single `String` representing the concatenated result of all the string slices in the vector.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn vector_to_string(v: Vec<&str>) -> String {\n  // Write your code here\n}\n\nlet v = vec![\"What\", \" \", \"is\", \" \", \"your\", \" \", \"name?\"];\nlet result = vector_to_string(v);\nprintln!(\"Result: {}\", result);",
          "solutionCode": "fn vector_to_string(v: Vec<&str>) -> String {\n  let mut result = String::new();\n\n  for x in v.iter() {\n    result.push_str(x)\n  }\n\n  result\n}\n\nlet v = vec![\"What\", \" \", \"is\", \" \", \"your\", \" \", \"name?\"];\nlet result = vector_to_string(v);\nprintln!(\"Result = {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "qhjdZvp4cH",
          "title": "Cloning Strings",
          "instructions": "We can create a copy of a `String` using the `clone` method \\(which is an implementation of the `Clone` trait\\. This allows us to create a new copy of a `String`.\n\nIn the editor below we are passing `s1` to the `do_something_with_a_string` function and as an initial value to create `s2`. Then, we are trying to print out the value of `s1`. However, `s1` has already first been \"moved\" into `do_something_with_a_string`. What does this mean? This means the current scope no longer has \"ownership\" over `s1`. This is the notorious Rust concept of ownership and borrowing which we are fast approaching in a future module.\n\nBut let this be a simple demonstration of it: once `s1` is moved into the `do_something_with_a_string` call, we can no longer safely read from the variable in the current scope. To avoid this, simple clone `s1` in the two usages of it.\n\n> Note: some values in Rust, when passed to a function, are automatically copied. This avoids the ownership issue we see in this challenge. But this does not occur for all types, in the case of a `String` such as in this challenge we have to manually clone the `String` when passing it to a function. For more on this see the [Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) and [Copy](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait docs.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = clone_a_string();\n  let a: String = result.0;\n  let b: String = result.1;\n\n  true\n}\n`;\n\ntest(\"The `clone_a_string` function should return a tuple of the two strings `(s1, s2)`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn do_something_with_a_string(s: String) {\n  let x = s.as_bytes();\n  println!(\"String Bytes: {:?}\", x);\n}\n\nfn clone_a_string() -> (String, String) {\n  let s1 = String::from(\"This is just an ordinary string.\");\n  do_something_with_a_string(s1);\n  let s2 = String::from(s1);\n  println!(\"s1: {}\", s1);\n  println!(\"s2: {}\", s2);\n\n  (s1, s2)\n}\n\nclone_a_string();",
          "solutionCode": "fn do_something_with_a_string(s: String) {\n  let x = s.as_bytes();\n  println!(\"String Bytes: {:?}\", x);\n}\n\nfn clone_a_string() -> (String, String) {\n  let s1 = String::from(\"This is just an ordinary string.\");\n  do_something_with_a_string(s1.clone());\n  let s2 = String::from(s1.clone());\n  println!(\"s1: {}\", s1);\n  println!(\"s2: {}\", s2);\n\n  (s1, s2)\n}\n\nclone_a_string();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Pd$BL98l2",
          "title": "Strings and Bytes",
          "instructions": "Just to drive the point home that a `String` is just a vector of bytes, let's convert a `String` to bytes and then back to the same `String` again\\. Complete the two functions `string_to_bytes` and `bytes_to_string`. Feel free to jump into the Rust documentation for help, this will require looking up a few new methods and debugging with the aid of the Rust compiler. Good luck\\!",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let s1 = String::from(\"s9ad7fa9s7f9sd7f8a0s7fd0a7f09as76df9as\");\n  let bytes = string_to_bytes(s1.clone());\n  let s2 = bytes_to_string(bytes);\n  assert_eq!(s1, s2);\n\n  true\n}\n`;\n\ntest(\"The `string_to_bytes` and `bytes_to_string` functions should be implemented and correctly convert from a `String` to bytes and back to a `String`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn string_to_bytes(string: String) -> Vec<u8> {\n  // TODO: Implement this function\n}\n\nfn bytes_to_string(bytes: Vec<u8>) -> String {\n  // TODO: Implement this function\n}\n\nfn convert_string(original_string: String) {\n  println!(\"\\n[1] Original string: {}\", original_string);\n\n  let bytes = string_to_bytes(original_string);\n  println!(\"\\n[2] String bytes: {:?}\", bytes);\n\n  let string = bytes_to_string(bytes.to_vec());\n  println!(\"\\n[3] Result string: {}\", string);\n}\n\nconvert_string(\"Fair is foul, foul is fair.\".to_string());",
          "solutionCode": "fn string_to_bytes(string: String) -> Vec<u8> {\n  string.into_bytes().to_vec()\n}\n\nfn bytes_to_string(bytes: Vec<u8>) -> String {\n  String::from_utf8(bytes).unwrap()\n}\n\nfn convert_string(original_string: String) {\n  println!(\"\\n[1] Original string: {}\", original_string);\n\n  let bytes = string_to_bytes(original_string);\n  println!(\"\\n[2] String bytes: {:?}\", bytes);\n\n  let string = bytes_to_string(bytes.to_vec());\n  println!(\"\\n[3] Result string: {}\", string);\n}\n\nconvert_string(\"Fair is foul, foul is fair.\".to_string());",
          "content": ""
        },
        {
          "type": "rust",
          "id": "qqG6eBY82",
          "title": "The String Slice",
          "instructions": "Now that we have seen the `String` data type, let's move on to the more primitive string slice which is built into the core Rust language. The `str` type is the most primitive string type in Rust and can be declared as a string literal:\n\n```\nconst my_string_slice = \"This is a string slice\";\n\n```\n\nString slices are always valid UTF\\-8. A string slice is comprised of a pointer to some bytes in memory, and a length. The `str` type is immutable by default and unlike `String`s which are always heap\\-allocated, a `str` may be stored in heap memory, stack memory, and compiled into the static binary itself, depending on the usage in the program. A `String` for instance dereferences into `&str`s, which are stored on the heap.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let expected = String::from(\"Static string slices are compiled directly into the program binary.\");\n  let actual = String::from(working_with_string_slices());\n  assert_eq!(actual, expected);\n\n  true\n}\n`;\n\ntest('The `static_string` should have the value `\"Static string slices are compiled directly into the program binary.\"`.', async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn working_with_string_slices() -> &'static str {\n  let static_string: &'static str = \"My static string\";\n\n  println!(\"Static String = {}\", static_string);\n  println!(\"Static String Length = {}\", static_string.len());\n  println!(\"Is the string empty? Empty = {}\", static_string.is_empty());\n\n  for c in static_string.chars() {\n    println!(\"Current Character: {}\", c);\n  }\n\n  let other_string: &str = \"Another string slice\";\n  // String slices can be compared directly to other string slices\n  assert_eq!(other_string, \"Another string slice\");\n\n  static_string\n}\n",
          "solutionCode": "fn working_with_string_slices() -> &'static str {\n  let static_string: &'static str = \"Static string slices are compiled directly into the program binary.\";\n\n  println!(\"Static String = {}\", static_string);\n  println!(\"Static String Length = {}\", static_string.len());\n  println!(\"Is the string empty? Empty = {}\", static_string.is_empty());\n\n  for c in static_string.chars() {\n    println!(\"Current Character: {}\", c);\n  }\n\n  let other_string: &str = \"Another string slice\";\n  // String slices can be compared directly to other string slices\n  assert_eq!(other_string, \"Another string slice\");\n\n  static_string\n}\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "KUliVUh0I",
          "title": "Concatenating Strings and String Slices",
          "instructions": "Concatenating strings is a common thing to do. One common and slightly idiosyncratic way to do this is to add a string slice to a `String`. A `String` provides an `add` function whose signature generally is `fn add(self, s: &str) -> String {...}`. This allows us to add additional string slices to a `String`, but only if we adhere to that function signature.\n\nFix and complete the `concat_strings` function in the editor below to return the text `\"Order: first second third\"` by correctly concatenating the string values defined in the function body.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = concat_strings();\n  let expected = String::from(\"Order: first second third\");\n  assert_eq!(result, expected);\n\n  true\n}\n`;\n\ntest('The `concat_strings` function should add the strings together and return a `String` result of the text value: `\"Order: first second third\".` ', async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn concat_strings() -> String {\n  let s1 = \"first\";\n  let s2 = \"second\";\n  let s3 = \"third\";\n\n  let string = String::from(\"Order:\");\n\n  // This won't compile, remove it\n  let result = s1 + s2 + s3;\n\n  // This won't compile, remove it\n  let result = s1 + s2 + s3 + string;\n\n  // Add the above strings without changing their type so the\n  // 'result' String is \"Order: first second third\"\n\n  println!(\"Result = {}\", result);\n  return result;\n}\n\nconcat_strings();",
          "solutionCode": "fn concat_strings() -> String {\n  let s1 = \"first\";\n  let s2 = \"second\";\n  let s3 = \"third\";\n\n  let string = String::from(\"Order:\");\n\n  // Add the above strings without changing their type so the\n  // 'result' String is \"Order: first second third\"\n  let result = string + \" \" + s1 + \" \" + s2 + \" \" + s3;\n\n  println!(\"Result = {}\", result);\n  return result;\n}\n\nconcat_strings();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "3mqD3wUKJ",
          "title": "Combining Strings with the format! Macro",
          "instructions": "Another common way to combine strings is using the `format!` macro\\. This macro uses the same value interpolation syntax as the `println!` macro, i.e. `format!(\"The value is: {}\", 100)` would create a `String` `\"The value is 100\"`. This can be used to concatenate string slices directly into a `String` or when you have more specific formatting  which is easier to apply in using string interpolation rather than manually adding string slice values together.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let expected = String::from(\"String slices can be concatenated using the format! macro.\");\n  let result = strings_can_be_concatenated_using_format();\n  assert_eq!(expected, result);\n\n  true\n}\n`;\n\ntest(\"The `strings_can_be_concatenated_using_format` function should return a new `String` representing the concatenation of all of the string slices values defined within it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn strings_can_be_concatenated_using_format() -> String {\n  let s1 = \"String\";\n  let s2 = \"slices\";\n  let s3 = \"can\";\n  let s4 = \"be\";\n  let s5 = \"concatenated\";\n  let s6 = \"using\";\n  let s7 = \"the\";\n  let s8 = \"format!\";\n  let s9 = \"macro.\";\n\n  // Write your code here\n}\n\nlet result = strings_can_be_concatenated_using_format();\nprintln!(\"Result = {}\", result);",
          "solutionCode": "fn strings_can_be_concatenated_using_format() -> String {\n  let s1 = \"String\";\n  let s2 = \"slices\";\n  let s3 = \"can\";\n  let s4 = \"be\";\n  let s5 = \"concatenated\";\n  let s6 = \"using\";\n  let s7 = \"the\";\n  let s8 = \"format!\";\n  let s9 = \"macro.\";\n\n  let result = format!(\"{} {} {} {} {} {} {} {} {}\", s1, s2, s3, s4, s5, s6, s7, s8, s9);\n\n  result\n}\n\nlet result = strings_can_be_concatenated_using_format();\nprintln!(\"Result = {}\", result);",
          "content": ""
        },
        {
          "type": "section",
          "id": "5B5@asRy6",
          "title": "Collections",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Rust provides a variety of primitive and advanced data structures to work with. We will explore the most common and useful of these in this module, such as:\n\n* Tuples\n* Arrays\n* Enums\n* Vectors\n* Structs\n* Hash Maps\n\n"
        },
        {
          "type": "rust",
          "id": "yh$liP$ml",
          "title": "Vectors",
          "instructions": "A vector is a collection of elements of dynamic size. It is stored on the heap and unlike arrays can grow or shrink during the life of a program. Vectors are ideal for storing lists of elements, especially ones whose size needs to change or whose size is not known at compile time.\n\nBecause vectors have an unknown length at compile time, you need to be a little more careful when working with them.\n\nConsider the code in the editor below which panics when run because of an \"index out of bounds\" error. Modify the code to check if the index `i` is in bounds of the vector and change the return type of the function to return an `Option<i32>`. Return `None` if the given index is out of bounds.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = maybe_get_item_at_index(vec![1,2,3,4,5], 2);\n  assert_eq!(result.unwrap(), 3);\n\n  let result = maybe_get_item_at_index(vec![1,2,3,4,5], 4);\n  assert_eq!(result.unwrap(), 5);\n\n  let result = maybe_get_item_at_index(vec![1,2,3,4,5], 20);\n  if let Some(_) = result {\n    panic!(\"maybe_get_item_at_index should return None when the index is out of bounds\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `maybe_get_item_at_index` function should return an `Option<i32>`, returning the element at index `i` or `None` if the index is out of bounds.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Change the return type and body of this function\n// to solve the challenge\nfn maybe_get_item_at_index(v: Vec<i32>, i: usize) -> i32 {\n  v[i]\n}\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 2);\nprintln!(\"Result: {:?}\", result);\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 20);\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// Change the return type and body of this function\n// to solve the challenge\nfn maybe_get_item_at_index(v: Vec<i32>, i: usize) -> Option<i32> {\n  if i < v.len() {\n    return Some(v[i]);\n  }\n\n  None\n}\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 2);\nprintln!(\"Result: {:?}\", result);\n\nlet result = maybe_get_item_at_index(vec![1,2,3,4,5], 20);\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "AKUw7arOt",
          "title": "Initializing Vectors",
          "instructions": "Vectors can be initialized in a few different ways. Write a new function in the editor below called `create_new_vector`. This function should accept a `usize` parameter and an `i32` default value parameter. Return a new vector of that size with every position in the vector filled with the `default_value`.  Take a look a look at the [Vec documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html) if you need to.\n\n> Remember back to the challenges covering arrays, and recall that arrays have a fixed length. The vector is very useful because it has a dynamic size at runtime, as we see in this challenge.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let size: usize = 1000;\n  let vec = create_new_vector(size, 5);\n  assert_eq!(vec.len(), size);\n\n  let size: usize = 52;\n  let vec = create_new_vector(size, 51);\n  assert_eq!(vec.len(), size);\n\n  let size: usize = 999;\n  let vec = create_new_vector(size, 28);\n  assert_eq!(vec.len(), size);\n\n  true\n}\n`;\n\ntest(\"The `create_new_vector` function should exist and return a new vector of that size.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n\nlet vec = create_new_vector(500, 5);\nprintln!(\"Result: {:?}\", vec);\nassert_eq!(vec.len(), 500);\n",
          "solutionCode": "// Using the vec! macro\nfn create_new_vector(size: usize, default_value: i32) -> Vec<i32> {\n  vec![default_value; size]\n}\n\nlet vec = create_new_vector(250, 5);\nprintln!(\"[1] Result: {:?}\", vec);\nassert_eq!(vec.len(), 250);\n\n// Using logic to fill in the vector during runtime\nfn create_new_vector_alternate(size: usize, default_value: i32) -> Vec<i32> {\n  let mut v = Vec::new();\n  let mut current = 0;\n  while current < size {\n    v.push(default_value);\n    current = current + 1;\n  }\n  v\n}\n\nlet vec = create_new_vector_alternate(250, 7);\nprintln!(\"[2] Result: {:?}\", vec);\nassert_eq!(vec.len(), 250);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "SyJsNcFRxE",
          "title": "Swap Items in a Vector",
          "instructions": "Similar to \"list\" data structures in other programming languages, vectors support many operations you would expect. You can pop the last item, get the length of the vector, iterate through it, index into it, push new items on it, and so on.\n\nTo get more practice with vectors, implement a function `swap_at_indexes` which takes a `Vec<i32>` and two `usize`indexes\\. Then, return the vector with the values at those indexes swapped, or, if one of the indexes is out of bounds return the original vector without swapping anything.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 0, 32);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 19, 2);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 1, 2);\n  assert_eq!(list, vec![9, 7, 8, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 1, 1);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 3, 2, 1]);\n\n  let list = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n  let list = swap_at_indexes(list, 6, 8);\n  assert_eq!(list, vec![9, 8, 7, 6, 5, 4, 1, 2, 3]);\n\n  true\n}\n`;\n\ntest(\"The `swap_at_indexes` function should take a `Vec<i32>` and swap the values at the two indexes given to it, if the indexes are not out of bounds.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n\nlet list = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nprintln!(\"Original: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 50);\nassert_eq!(list, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\nprintln!(\"Result [1]: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 5);\nassert_eq!(list, vec![6, 2, 3, 4, 5, 1, 7, 8, 9, 10]);\nprintln!(\"Result [2]: {:?}\", list);\n",
          "solutionCode": "fn swap_at_indexes(mut v: Vec<i32>, a: usize, b: usize) -> Vec<i32> {\n  if a > v.len() || b > v.len() {\n    return v;\n  }\n\n  let a_value = v[a];\n  let b_value = v[b];\n\n  v[a] = b_value;\n  v[b] = a_value;\n\n  v\n}\n\nlet list = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nprintln!(\"Original: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 50);\nassert_eq!(list, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\nprintln!(\"Result [1]: {:?}\", list);\n\nlet list = swap_at_indexes(list, 0, 5);\nassert_eq!(list, vec![6, 2, 3, 4, 5, 1, 7, 8, 9, 10]);\nprintln!(\"Result [2]: {:?}\", list);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "XNHkdURTA0",
          "title": "Iterating Vectors",
          "instructions": "Write a function `get_vector_sum` which takes a `Vec<i32>`, iterates through it and calculates the sum of all of items.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = get_vector_sum(vec![5, 5, 5, 5, 7]);\n  assert_eq!(result, 27);\n\n  let result = get_vector_sum(vec![5, 5, 5, 5, 7, 100]);\n  assert_eq!(result, 127);\n\n  let result = get_vector_sum(vec![5, 5, 5, 5, 7, 599]);\n  assert_eq!(result, 626);\n\n  true\n}\n`;\n\ntest(\"The `get_vector_sum` function should return the sum of all the items in the provided vector.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "fn get_vector_sum(v: Vec<i32>) -> i32 {\n  let mut sum = 0;\n\n  // The .iter() method is a common and handy way to iterate a collection\n  // like this.\n  for x in v.iter() {\n    sum = sum + x;\n  } \n\n  sum\n}\n\nlet result = get_vector_sum(vec![5, 5, 5, 5, 7]);\nassert_eq!(result, 27);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "cHge$oxVa",
          "title": "Vectors and Mutability",
          "instructions": "Like any variable declaration in Rust, vector definitions are by default immutable. This means their size and contents cannot change during runtime, and you will get a compile error if you try to perform some operation which would change their contents in any way. Like other variables, you can opt out of this default behavior using the `mut` keyword\\. Take a look at the code below and fix it so it compiles.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = vectors_are_immutable_by_default();\n  assert_eq!(result, vec![5, 8, 2, 17, 200, 88]);\n\n  true\n}\n`;\n\ntest(\"The `vectors_are_immutable_by_default` function should compile and return a vector containing the items `[5, 8, 2, 17, 200, 88]`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn vectors_are_immutable_by_default() -> Vec<i32> {\n  let v = vec![5, 8, 2];\n\n  v.push(11);\n  v.push(200);\n  v.push(88);\n\n  v[3] = 17;\n\n  v\n}\n\n\nlet result = vectors_are_immutable_by_default();\nassert_eq!(result, vec![5, 8, 2, 17, 200, 88]);",
          "solutionCode": "fn vectors_are_immutable_by_default() -> Vec<i32> {\n  let mut v = vec![5, 8, 2];\n\n  v.push(11);\n  v.push(200);\n  v.push(88);\n\n  v[3] = 17;\n\n  v\n}\n\n\nlet result = vectors_are_immutable_by_default();\nassert_eq!(result, vec![5, 8, 2, 17, 200, 88]);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "4XpH9$RzGO",
          "title": "Get the Last Item in a Vector",
          "instructions": "Popping the final item from a vector is a common thing to do for list data structures. The Rust `Vec` implements a `pop` method just for this purpose. However, things may not be quite as straightforward as \"popping\" in other languages. Check out the code below and let the compiler guide you.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = get_last_item_in_vector(vec![5, 19, 20, 22]);\n  if let Some(x) = result {\n    assert_eq!(x, 22);\n  } else {\n    panic!(\"Expected to receive a value!\");\n  }\n\n  let result = get_last_item_in_vector(vec![5, 19, 20, 22, 99, 201, 822]);\n  if let Some(x) = result {\n    assert_eq!(x, 822);\n  } else {\n    panic!(\"Expected to receive a value!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `get_last_item_in_vector` function should return an appropriate value representing the final item in in a list.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// What's wrong here? Let the compiler help you.\nfn get_last_item_in_vector(v: Vec<i32>) -> i32 {\n  v.pop()\n}\n\nlet result = get_last_item_in_vector(vec![5, 19, 20, 22]);\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "// What's wrong here? Let the compiler help you.\nfn get_last_item_in_vector(mut v: Vec<i32>) -> Option<i32> {\n  v.pop()\n}\n\nlet result = get_last_item_in_vector(vec![5, 19, 20, 22]);\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "rVF0OUfW3",
          "title": "Pop And Reverse",
          "instructions": "As we saw in the last challenge, popping an item from a vector returns an `Option` of whatever that vector may contain. This makes perfect sense: a vector may _optionally_ be empty and in that case popping the last item returns nothing\\! Rust enforces this fact of reality in the type system, to protect us from popping an item and then performing some action on it, when in fact no item exists.\n\nLet's build on this and use the pop method to pop all the items from a given vector. Just for fun, let's add them to a new vector, and return that from a function `pop_and_reverse`. Note that if you were to use the vector to model a stack, this would be equivalent to popping all the items on the stack.\n\nFor now, continue to type your vector as `Vec<i32>`. You may be thinking... but we could write this function for a vector containing any type—how can we do that? We can do that using _generics_, which we will see in future challenges\\!",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let v = vec![1, 2, 3, 4, 5];\n  let rev = vec![5, 4, 3, 2, 1];\n  let result = pop_and_reverse(v);\n  assert_eq!(result, rev);\n\n  true\n}\n`;\n\ntest(\"The `pop_and_reverse` function should pop all the items from the given vector and return a new vector with the items in reverse order.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write you code here\n\nlet v = vec![1, 2, 3, 4, 5];\nlet rev = vec![5, 4, 3, 2, 1];\nlet result = pop_and_reverse(v);\nassert_eq!(result, rev);",
          "solutionCode": "fn pop_and_reverse(mut v: Vec<i32>) -> Vec<i32> {\n  let mut result = Vec::new();\n  while let Some(x) = v.pop() {\n    result.push(x);\n  }\n\n  result\n}\n\nlet v = vec![1, 2, 3, 4, 5];\nlet rev = vec![5, 4, 3, 2, 1];\nlet result = pop_and_reverse(v);\nassert_eq!(result, rev);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "1VtNcZHIE",
          "title": "A Vector of String Slices",
          "instructions": "Vectors can contain any type. Here we have a vector of string slices. Write a function called `find_str_in_vector` which takes a `&Vec<&str>` \\(a reference to a vector containing references to string slices\\) and a `&str` and returns an `Option` containing the index of that string in the vector, if it exists.\n\n> Note: We are edging around topics such as **references**... as we get closer and closer to the topic of ownership and borrowing: a core subject in Rust. Don't worry we will get there soon\\! For now, it's OK to not fully understand everything.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let strings: Vec<&str> = vec![\n    \"sword\",\n    \"even\",\n    \"good\",\n    \"carbon\",\n    \"battery\",\n    \"bear\",\n    \"concentration\",\n    \"shout\",\n    \"apple\",\n    \"yellow\",\n  ];\n\n  let result = find_str_in_vector(&strings, \"sword\");\n  if let Some(x) = result {\n    assert_eq!(x, 0);\n  } else {\n    panic!(\"Expected 'sword' to be found\");\n  }\n\n  let result = find_str_in_vector(&strings, \"shout\");\n  if let Some(x) = result {\n    assert_eq!(x, 7);\n  } else {\n    panic!(\"Expected 'shout' to be found\");\n  }\n\n  let result = find_str_in_vector(&strings, \"shouting\");\n  if let Some(x) = result {\n    panic!(\"Expected 'shouting' to not be found\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `find_str_in_vector` function should accept a `&Vec<&str>` and a `&str` target and return an `Option` of the index of the target, if it exists.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n\nlet strings: Vec<&str> = vec![\n  \"sword\",\n  \"even\",\n  \"good\",\n  \"carbon\",\n  \"battery\",\n  \"shout\",\n  \"bear\",\n  \"concentration\",\n  \"apple\",\n  \"yellow\",\n];\n\nprintln!(\"Strings: {:?}\", strings);\nlet result = find_str_in_vector(strings, \"good\");\nprintln!(\"Result: {:?}\", result);\n\nlet result = find_str_in_vector(strings, \"blegga\");\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "fn find_str_in_vector(v: &Vec<&str>, string: &str) -> Option<usize> {\n  // We can use this syntax to iterate a vector with the index\n  // for each item\n  for (i, x) in v.iter().enumerate() {\n    if x == &string {\n      return Some(i);\n    }\n  }\n\n  None\n}\n\nlet strings: Vec<&str> = vec![\n  \"sword\",\n  \"even\",\n  \"good\",\n  \"carbon\",\n  \"battery\",\n  \"shout\",\n  \"bear\",\n  \"concentration\",\n  \"apple\",\n  \"yellow\",\n];\n\nprintln!(\"Strings: {:?}\", strings);\nlet result = find_str_in_vector(&strings, \"good\");\nprintln!(\"Result: {:?}\", result);\n\nlet result = find_str_in_vector(&strings, \"blegga\");\nprintln!(\"Result: {:?}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "$@B4lPRdE",
          "title": "Vectors With Different Items",
          "instructions": "Vectors can only contain a single type of data. You might think this is a bit constraining, what if you want to have a vector with different items inside? Well, you can do this: simply create a unique type to represent the different variants which might be contained in the vector. You will then, of course have to match against any items you access or withdraw from the vector, to ensure the code you write is dealing with the correct type at runtime.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let v = vec![\n    ItemType::Integer(10),\n    ItemType::Name(\"Eddie\"),\n    ItemType::Integer(32),\n    ItemType::Integer(58),\n    ItemType::SomeFlag(false),\n    ItemType::Integer(101),\n    ItemType::SomeFlag(true),\n  ];\n\n  let result = return_sum_of_all_int_types_in_vector(v);\n  assert_eq!(result, 201);\n\n  true\n}\n`;\n\ntest(\"The `return_sum_of_all_int_types_in_vector` function should return the same of all the integer containing items in the vector it is given.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "enum ItemType {\n  Number(i32),\n  Float(f64),\n  Name(&'static str),\n  SomeFlag(bool)\n}\n\nfn return_sum_of_all_int_types_in_vector(v: Vec<ItemType>) -> i32 {\n  // Write your code here\n}\n\nlet v = vec![\n  ItemType::Number(10),\n  ItemType::Name(\"Eddie\"),\n  ItemType::Number(32),\n  ItemType::Number(58),\n  ItemType::SomeFlag(false),\n  ItemType::SomeFlag(true),\n];\n\nlet result = return_sum_of_all_int_types_in_vector(v);\nassert_eq!(result, 100);\n",
          "solutionCode": "enum ItemType {\n  Integer(i32),\n  Float(f64),\n  Name(&'static str),\n  SomeFlag(bool)\n}\n\nfn return_sum_of_all_int_types_in_vector(v: Vec<ItemType>) -> i32 {\n  let mut sum: i32 = 0;\n  for x in v.iter() {\n    match x {\n      ItemType::Integer(n) => {\n        sum = sum + n;\n      }\n      _ => (), // Ignore all other types\n    }\n  }\n\n  sum\n}\n\nlet v = vec![\n  ItemType::Integer(10),\n  ItemType::Name(\"Eddie\"),\n  ItemType::Integer(32),\n  ItemType::Integer(58),\n  ItemType::SomeFlag(false),\n  ItemType::SomeFlag(true),\n];\n\nlet result = return_sum_of_all_int_types_in_vector(v);\nassert_eq!(result, 100);\nprintln!(\"Sum is: {}\", result);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "vBPQ77f@I",
          "title": "Hash Maps",
          "instructions": "The Rust `HashMap` is a collection which stores key value pairs, the equivalent of a map/hash table in other programming languages. Unlike the `Vec` collection, which is included by default when writing Rust, we have to import the `HashMap` collection directly with a `use` statement\\. This is one of the first times we are seeing this. This makes the `HashMap` collection from the standard library available for use within that scope. We will see more on modules and the standard library in future challenges.\n\nIn the `create_new_hash_map` below, create and return a new `HashMap`. You can do this just like with a vector, by invoking the `new` associated function.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result: HashMap<String, i32> = create_new_hash_map();\n\n  true\n}\n`;\n\ntest(\"The `create_new_hash_map` function should return a new `HashMap<String, i32>`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "use std::collections::HashMap;\n\nfn create_new_hash_map() -> HashMap<String, i32> {\n  // Write your code here\n}\n\nlet result = create_new_hash_map();\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "use std::collections::HashMap;\n\nfn create_new_hash_map() -> HashMap<String, i32> {\n  HashMap::new()\n}\n\nlet result = create_new_hash_map();\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "hLswsbZFT",
          "title": "Inserting Items in a Hash Map",
          "instructions": "Hash maps store collections of key value pairs and allow you to associate specific data with a specific identifier, or key. Under the hood, the rely on hashing algorithms to associate keys with values. See the [Rust HashMap docs](https://doc.rust-lang.org/std/collections/struct.HashMap.html) for more details on the implementation.\n\nWe can add new items to a hash map using the `insert` method\\. Let's say we have a store with a lot of products, and we want to create a data structure to easily look up the products by their item. Complete the function `map_products_to_hash_map` to do this.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let product_a = Product {\n    id: String::from(\"eb52c260-5b33-4e9c-9282-65a5c8cc91f2\"),\n    price: 1002,\n  };\n\n  let product_b = Product {\n    id: String::from(\"70d04873-c74e-4edf-8197-605e7c30edd3\"),\n    price: 517,\n  };\n\n  let product_c = Product {\n    id: String::from(\"1630bcf5-6f4a-4688-8036-65bed150ae1c\"),\n    price: 3,\n  };\n\n  let products = vec![&product_a, &product_b, &product_c];\n  let result = map_products_to_hash_map(products);\n\n  if let Some(x) = result.get(\"eb52c260-5b33-4e9c-9282-65a5c8cc91f2\") {\n    assert_eq!(x.price, 1002);\n  } else {\n    panic!(\"Expected to find a product in the map but did not find it.\");\n  }\n\n  if let Some(x) = result.get(\"70d04873-c74e-4edf-8197-605e7c30edd3\") {\n    assert_eq!(x.price, 517);\n  } else {\n    panic!(\"Expected to find a product in the map but did not find it.\");\n  }\n\n  if let Some(x) = result.get(\"1630bcf5-6f4a-4688-8036-65bed150ae1c\") {\n    assert_eq!(x.price, 3);\n  } else {\n    panic!(\"Expected to find a product in the map but did not find it.\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `map_products_to_hash_map` function should return a new `HashMap` mapping product `id`s to the associated `Product`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct Product {\n  id: String,\n  price: i32,\n  // Lot's of other product data...\n} \n\n/**\n * NOTE: Our function expects a vector of references to products and should return\n * a hash map with keys pointing to those same references. The references are denoted\n * by the & symbol.\n *\n * Don't worry if this doesn't make sense - we will see more on it shortly.\n */\nfn map_products_to_hash_map(products: Vec<&Product>) -> HashMap<String, &Product> {\n  // Write your code here\n}\n\nlet product_a = Product {\n  id: String::from(\"eb52c260-5b33-4e9c-9282-65a5c8cc91f2\"),\n  price: 52,\n};\n\nlet product_b = Product {\n  id: String::from(\"70d04873-c74e-4edf-8197-605e7c30edd3\"),\n  price: 52,\n};\n\nlet product_c = Product {\n  id: String::from(\"1630bcf5-6f4a-4688-8036-65bed150ae1c\"),\n  price: 52,\n};\n\nlet products = vec![&product_a, &product_b, &product_c];\nlet result = map_products_to_hash_map(products);\nprintln!(\"Result: {:?}\", result);",
          "solutionCode": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct Product {\n  id: String,\n  price: i32,\n  // Lot's of other product data...\n} \n\n/**\n * NOTE: Our function expects a vector of references to products and should return\n * a hash map with keys pointing to those same references. The references are denoted\n * by the & symbol.\n *\n * Don't worry if this doesn't make sense - we will see more on it shortly.\n */\nfn map_products_to_hash_map(products: Vec<&Product>) -> HashMap<String, &Product> {\n  let mut map: HashMap<String, &Product> = HashMap::new();\n\n  for x in products.iter() {\n    let key = x.id.to_string();\n    map.insert(key, x);\n  }\n\n  map\n}\n\nlet product_a = Product {\n  id: String::from(\"eb52c260-5b33-4e9c-9282-65a5c8cc91f2\"),\n  price: 52,\n};\n\nlet product_b = Product {\n  id: String::from(\"70d04873-c74e-4edf-8197-605e7c30edd3\"),\n  price: 52,\n};\n\nlet product_c = Product {\n  id: String::from(\"1630bcf5-6f4a-4688-8036-65bed150ae1c\"),\n  price: 52,\n};\n\nlet products = vec![&product_a, &product_b, &product_c];\nlet result = map_products_to_hash_map(products);\nprintln!(\"Result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "0b3FY6ciT",
          "title": "Getting Items in a Hash Map",
          "instructions": "We can retrieve items from a `HashMap` by their key using the `get` method\\. But what does `get` return? Implement the `lookup_address` function in the editor to return the address of someone in the `address_map`, or return `Address not found.` if they do not exist in the address map.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut address_map: HashMap<String, String> = HashMap::new();\n  address_map.insert(String::from(\"Ryan\"), String::from(\"10 Peach Street\"));\n  address_map.insert(String::from(\"Sam\"), String::from(\"121 Mercury Avenue\"));\n  address_map.insert(String::from(\"Adrian\"), String::from(\"1283 Frederick Blvd.\"));\n  address_map.insert(String::from(\"Jess\"), String::from(\"100 Main Street\"));\n  address_map.insert(String::from(\"Brad\"), String::from(\"5 Circle Drive\"));\n\n  let result = lookup_address(\"Adrian\".to_string(), &address_map);\n  assert_eq!(result, \"1283 Frederick Blvd.\");\n\n  let result = lookup_address(\"Vance\".to_string(), &address_map);\n  assert_eq!(result, \"Address not found.\");\n\n  true\n}\n`;\n\ntest(\"The `lookup_address` function should return the address in the `address_map` of the person, or the `String` `Address not found.` if they are not present.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "use std::collections::HashMap;\n\nlet mut address_map: HashMap<String, String> = HashMap::new();\n\nfn lookup_address(name: String, address_map: &HashMap<String, String>) -> String {\n  // Write your code here\n}\n\naddress_map.insert(String::from(\"Ryan\"), String::from(\"10 Peach Street\"));\naddress_map.insert(String::from(\"Sam\"), String::from(\"121 Mercury Avenue\"));\naddress_map.insert(String::from(\"Sara\"), String::from(\"9 1st Street\"));\naddress_map.insert(String::from(\"Jess\"), String::from(\"100 Main Street\"));\naddress_map.insert(String::from(\"Brad\"), String::from(\"5 Circle Drive\"));\n\nlet result = lookup_address(\"Jess\".to_string(), &address_map);\nprintln!(\"Jess lives on: {}\", result);\n\nlet result = lookup_address(\"Vance\".to_string(), &address_map);\nprintln!(\"Vance lives on: {}\", result);",
          "solutionCode": "use std::collections::HashMap;\n\nlet mut address_map: HashMap<String, String> = HashMap::new();\n\nfn lookup_address(name: String, address_map: &HashMap<String, String>) -> String {\n  if let Some(x) = address_map.get(&name) {\n    return String::from(x);\n  }\n\n  String::from(\"Address not found.\")\n}\n\naddress_map.insert(String::from(\"Ryan\"), String::from(\"10 Peach Street\"));\naddress_map.insert(String::from(\"Sam\"), String::from(\"121 Mercury Avenue\"));\naddress_map.insert(String::from(\"Sara\"), String::from(\"9 1st Street\"));\naddress_map.insert(String::from(\"Jess\"), String::from(\"100 Main Street\"));\naddress_map.insert(String::from(\"Brad\"), String::from(\"5 Circle Drive\"));\n\nlet result = lookup_address(\"Jess\".to_string(), &address_map);\nprintln!(\"Jess lives on: {}\", result);\n\nlet result = lookup_address(\"Vance\".to_string(), &address_map);\nprintln!(\"Vance lives on: {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "eJFOhdjZQ",
          "title": "Iterating Hash Map Entries",
          "instructions": "We can iterate through all of the entries \\(key value pairs\\) in a `HashMap` using a for loop expression. Each loop iteration will receive a tuple of the type `(key, value)`. Complete the function `get_movies_above_score_threshold` to return a new vector containing the names of all the movies with a rating above the `threshold` value\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  fn get_scores() -> HashMap<String, i32>{\n    let mut movie_scores = HashMap::new();\n    movie_scores.insert(String::from(\"The Return of the Jedi\"), 100);\n    movie_scores.insert(String::from(\"Back to the Future\"), 93);\n    movie_scores.insert(String::from(\"The Matrix\"), 95);\n    movie_scores.insert(String::from(\"Gladiator\"), 94);\n    movie_scores.insert(String::from(\"Rush Hour\"), 88);\n    movie_scores\n  }\n\n  let mut movie_scores = get_scores();\n  let result = get_movies_above_score_threshold(movie_scores, 99);\n  assert_eq!(result, vec![\"The Return of the Jedi\"]);\n\n  let mut movie_scores = get_scores();\n  let result = get_movies_above_score_threshold(movie_scores, 90);\n  assert_eq!(result.len(), 4);\n\n  let mut movie_scores = get_scores();\n  let result = get_movies_above_score_threshold(movie_scores, 87);\n  assert_eq!(result.len(), 5);\n\n  let mut movie_scores = get_scores();\n  let result = get_movies_above_score_threshold(movie_scores, 100);\n  assert_eq!(result.len(), 0);\n\n  true\n}\n`;\n\ntest(\"The `get_movies_above_score_threshold` function should return a vector of all the movie names with a rating above the given `threshold`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "use std::collections::HashMap;\n\nlet mut movie_scores = HashMap::new();\n\n// Insert movies and their ratings\nmovie_scores.insert(String::from(\"Star Wars\"), 98);\nmovie_scores.insert(String::from(\"Back to the Future\"), 93);\nmovie_scores.insert(String::from(\"The Matrix\"), 100);\nmovie_scores.insert(String::from(\"Gladiator\"), 94);\nmovie_scores.insert(String::from(\"Rush Hour\"), 88);\n\nfn get_movies_above_score_threshold(movie_scores: HashMap<String, i32>, threshold: i32) -> Vec<String> {\n  // Write your code here\n}\n\nlet result = get_movies_above_score_threshold(movie_scores, 95);\nprintln!(\"Result: {:?}\", result);\n\n",
          "solutionCode": "use std::collections::HashMap;\n\nlet mut movie_scores = HashMap::new();\n\n// Insert movies and their ratings\nmovie_scores.insert(String::from(\"Star Wars\"), 98);\nmovie_scores.insert(String::from(\"Back to the Future\"), 93);\nmovie_scores.insert(String::from(\"The Matrix\"), 100);\nmovie_scores.insert(String::from(\"Gladiator\"), 94);\nmovie_scores.insert(String::from(\"Rush Hour\"), 88);\n\nfn get_movies_above_score_threshold(movie_scores: HashMap<String, i32>, threshold: i32) -> Vec<String> {\n  let mut movies: Vec<String> = Vec::new();\n\n  for (key, value) in &movie_scores {\n    if value > &threshold {\n      movies.push(key.to_string());\n    }\n  }\n\n  movies\n}\n\nlet result = get_movies_above_score_threshold(movie_scores, 95);\nprintln!(\"Result: {:?}\", result);\n\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "udrnFJ8NN",
          "title": "Plane Seats",
          "instructions": "We have seen how to get and set values in a `HashMap` \\- and, also how to update values. If you call `insert` on a key which has already been set, you will simply update it. But what if you want to set a key only if it does not already exist? You would have to write a few lines of code to do this with type safety—but luckily there is a much simpler solution. The `HashMap` implements an `entry` method which returns an `Entry` enum, on which you can call `or_insert` providing a default insertion value. From the Rust book:\n\n> The `or_insert` method on `Entry` is defined to return a mutable reference to the value for the corresponding `Entry` key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value.\n\nWrite a function `seat_in_place` which takes a mutable `SeatMap` and a vector of `PlaneSeats`. For each seat/name \\(key/value\\) pair in the vector, seat that individual in the plane `SeatMap` if the seat is not already taken.\n\nTry to write the logic first without using the `or_insert` method, and then using it.\n\nYour function should return the same `SeatMap` that it modifies.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut plane_seats: SeatMap = HashMap::new();\n  plane_seats.insert(String::from(\"3A\"), String::from(\"Sammy\"));\n  plane_seats.insert(String::from(\"5C\"), String::from(\"Coni\"));\n  plane_seats.insert(String::from(\"10D\"), String::from(\"Brown\"));\n\n  let seat_a: PlaneSeats = (String::from(\"3B\"), String::from(\"Jake\"));\n  let seat_b: PlaneSeats = (String::from(\"4C\"), String::from(\"Choco\"));\n  let seat_c: PlaneSeats = (String::from(\"10D\"), String::from(\"Murphy\"));\n  let seat_d: PlaneSeats = (String::from(\"5C\"), String::from(\"Rachel\"));\n  let seat_e: PlaneSeats = (String::from(\"9A\"), String::from(\"Vance\"));\n  let pairs = vec![seat_a, seat_b, seat_c, seat_d, seat_e];\n  let plane_seats = seat_in_plane(plane_seats, pairs);\n\n  assert_eq!(plane_seats.get(\"4C\").unwrap(), \"Choco\");\n  assert_eq!(plane_seats.get(\"10D\").unwrap(), \"Brown\");\n  assert_eq!(plane_seats.get(\"5C\").unwrap(), \"Coni\");\n  assert_eq!(plane_seats.get(\"9A\").unwrap(), \"Vance\");\n  assert_eq!(plane_seats.get(\"3B\").unwrap(), \"Jake\");\n\n  true\n}\n`;\n\ntest(\"The `seat_in_plane` function should accept a `SeatMap` and `Vec<PlaneSeat>` list of seat/name pairs and insert all the seat/name pairs which do not already exist in the `SeatMap`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "use std::collections::HashMap;\n\ntype PlaneSeats = (String, String);\ntype SeatMap = HashMap<String, String>;\nlet mut plane_seats: SeatMap = HashMap::new();\n\nplane_seats.insert(String::from(\"3A\"), String::from(\"Fred\"));\nplane_seats.insert(String::from(\"5C\"), String::from(\"Sarah\"));\nplane_seats.insert(String::from(\"10D\"), String::from(\"Joe\"));\n\n// Write your code here\n\nprintln!(\"Seats: {:?}\", plane_seats);\nlet seat_a: PlaneSeats = (String::from(\"3B\"), String::from(\"Jake\"));\nlet seat_b: PlaneSeats = (String::from(\"4C\"), String::from(\"Mary\"));\nlet seat_c: PlaneSeats = (String::from(\"10D\"), String::from(\"Murphy\"));\nlet seat_d: PlaneSeats = (String::from(\"5C\"), String::from(\"Rachel\"));\nlet seat_e: PlaneSeats = (String::from(\"9A\"), String::from(\"Vance\"));\nlet pairs = vec![seat_a, seat_b, seat_c, seat_d, seat_e];\nlet plane_seats = seat_in_plane(plane_seats, pairs);\nprintln!(\"Seats: {:?}\", plane_seats);\n",
          "solutionCode": "use std::collections::HashMap;\n\ntype PlaneSeats = (String, String);\ntype SeatMap = HashMap<String, String>;\nlet mut plane_seats: SeatMap = HashMap::new();\n\nplane_seats.insert(String::from(\"3A\"), String::from(\"Fred\"));\nplane_seats.insert(String::from(\"5C\"), String::from(\"Sarah\"));\nplane_seats.insert(String::from(\"10D\"), String::from(\"Joe\"));\n\nfn seat_in_plane(mut seat_map: SeatMap, pairs: Vec<PlaneSeats>) -> SeatMap {\n  for kv in pairs.iter() {\n    let key = String::from(&kv.0);\n    let value = String::from(&kv.1);\n    seat_map.entry(key).or_insert(value);\n  }\n\n  return seat_map;\n}\n\nprintln!(\"Seats: {:?}\", plane_seats);\nlet seat_a: PlaneSeats = (String::from(\"3B\"), String::from(\"Jake\"));\nlet seat_b: PlaneSeats = (String::from(\"4C\"), String::from(\"Mary\"));\nlet seat_c: PlaneSeats = (String::from(\"10D\"), String::from(\"Murphy\"));\nlet seat_d: PlaneSeats = (String::from(\"5C\"), String::from(\"Rachel\"));\nlet seat_e: PlaneSeats = (String::from(\"9A\"), String::from(\"Vance\"));\nlet pairs = vec![seat_a, seat_b, seat_c, seat_d, seat_e];\nlet plane_seats = seat_in_plane(plane_seats, pairs);\nprintln!(\"Seats: {:?}\", plane_seats);\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "tI7KcRQjA",
          "title": "Zipping Iterators into a Hash Map",
          "instructions": "Another way to create a `HashMap` is by zipping two lists into a `collect` method\\. A \"zip\" operation processes two lists of elements, applying some common operation for each \"pair\" of items at the same position in each list. We can take two lists, for instance, and zip them into key/value pairs which are then collected into a `HashMap`.\n\nTake a look at the code to see how this is done, and then create `frutis` and `quantities` vectors matching the defined types. Once the code compiles, you're good\\!",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `fruits` and `quantities` vectors should be defined, with 5 fruits which get collected into the `fruits_map`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "use std::collections::HashMap;\n\ntype FruitVector = Vec<String>;\ntype FruitQuantitiesVector = Vec<i32>;\n\n// Write your code here\n\nlet mut fruits_map: HashMap<String, i32> = fruits\n  .into_iter()\n  .zip(quantities.into_iter())\n  .collect();\n\nprintln!(\"Fruits Map: {:?}\", fruits_map);\nassert_eq!(fruits_map.keys().len(), 5);",
          "solutionCode": "use std::collections::HashMap;\n\ntype FruitVector = Vec<String>;\ntype FruitQuantitiesVector = Vec<i32>;\n\nlet fruits = vec![\n  String::from(\"Apple\"),\n  String::from(\"Banana\"),\n  String::from(\"Grapes\"),\n  String::from(\"Blueberries\"),\n  String::from(\"Watermelon\"),\n];\nlet quantities = vec![10, 50, 5, 100, 3];\n\nlet mut fruits_map: HashMap<String, i32> = fruits\n  .into_iter()\n  .zip(quantities.into_iter())\n  .collect();\n\nprintln!(\"Fruits Map: {:?}\", fruits_map);\nassert_eq!(fruits_map.keys().len(), 5);",
          "content": ""
        },
        {
          "type": "section",
          "id": "PnCi8hB8E",
          "title": "Results and Errors",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Previously we saw the `Option` type which is useful for representing values which may be present or not present. Rust also provides a type for representing values which may be in a state of success or failure, the `Result` type\\."
        },
        {
          "type": "rust",
          "id": "U9nuyenYI",
          "title": "Rust's Result Type",
          "instructions": "The editor below has a function to validate a user's name length, `validate_user_name`. The function should compare a user's name to a fixed max length value and then return an `Ok` or `Err` variant of the `Result` type to represent if the user's name is valid or not.\n\n> The `Result` type is ideal for representing data which may be in a success/OK state or an error/failure state. This is common when interacting with data from the \"outside\" world, i.e. from user input, or from external APIs or libraries.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let valid = validate_user_name(\"Sam\");\n  if let Err(_) = valid {\n    panic!(\"Expected name to be valid!\");\n  }\n\n  let invalid = validate_user_name(\"Samadsfsaf0978asd0f70asd78f09asd7f09as\");\n  if let Ok(_) = invalid {\n    panic!(\"Expected name to be invalid!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `validate_user_name` function should return `Ok` variants for valid names and `Err` variants for names that are too long.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "type ValidationErrorMessage = String;\n\nconst MAX_USER_NAME_LENGTH: usize = 30;\n\nfn validate_user_name(user_last_name: &str) -> Result<(), ValidationErrorMessage> {\n  // Write your code here\n}\n\nlet valid = validate_user_name(\"Sam\");\nprintln!(\"Valid name result: {:?}\", valid);\n\nlet invalid = validate_user_name(\"Wolfeschlegelsteinhausenbergerdorff\");\nprintln!(\"Valid name result: {:?}\", invalid);",
          "solutionCode": "type ValidationErrorMessage = String;\n\nconst MAX_USER_NAME_LENGTH: usize = 30;\n\nfn validate_user_name(user_last_name: &str) -> Result<(), ValidationErrorMessage> {\n  if user_last_name.len() > MAX_USER_NAME_LENGTH {\n    return Err(String::from(\"User name is too long!\"))\n  }\n\n  Ok(())\n}\n\nlet valid = validate_user_name(\"Sam\");\nprintln!(\"Valid name result: {:?}\", valid);\n\nlet invalid = validate_user_name(\"Wolfeschlegelsteinhausenbergerdorff\");\nprintln!(\"Valid name result: {:?}\", invalid);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "tKG8WBsi9",
          "title": "Matching Results",
          "instructions": "We can match against a `Result` just like we can match against other variants. Fundamentally, a [Result](https://doc.rust-lang.org/std/result/enum.Result.html) is just an enum:\n\n```\npub enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\n```\n\nComplete the `match_result` function in the editor below to match the provided `Result` and handle both the ok and error variants. Since both variants are represented by a string slice, return from the function a new `String` representing the given variant of the `Result`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = match_result(Ok(\"OKAY\"));\n  assert_eq!(result, String::from(\"OKAY\"));\n\n  let result = match_result(Err(\"ERROR\"));\n  assert_eq!(result, String::from(\"ERROR\"));\n\n  true\n}\n`;\n\ntest(\"The `match_result` function should return a `String` with the value of which `Result` variant is passed to it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn match_result(result: Result<&str, &str>) -> String {\n  // Write your code here\n}\n\nlet result = match_result(Ok(\"This result is OK!\"));\nassert_eq!(result, String::from(\"This result is OK!\"));\n\nlet result = match_result(Err(\"This result is not OK!\"));\nassert_eq!(result, String::from(\"This result is not OK!\"));",
          "solutionCode": "fn match_result(result: Result<&str, &str>) -> String {\n  return match result {\n    Ok(x) => String::from(x),\n    Err(e) => String::from(e),\n  }\n}\n\nlet result = match_result(Ok(\"This result is OK!\"));\nassert_eq!(result, String::from(\"This result is OK!\"));\n\nlet result = match_result(Err(\"This result is not OK!\"));\nassert_eq!(result, String::from(\"This result is not OK!\"));",
          "content": ""
        },
        {
          "type": "rust",
          "id": "1IMOWj3ED",
          "title": "Results Must Be Used",
          "instructions": "The `Result` enum is annotated with the `#[must_use]` annotation, which instructs the compiler that `Result` values must be dealt with explicitly. The following code compiles, and you don't see any compiler warnings here but if you ran this in a terminal you would see the following message:\n\n```\nwarning: unused `Result` that must be used\n --> src/main.rs:7:1\n  |\n7 | returns_a_result(true);\n  | ^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_must_use)]` on by default\n  = note: this `Result` may be an `Err` variant, which should be handled\n\n```\n\nRust recommends you handle the `Result`, because it might be an `Err` variant\\. This behavior is very important, because it is too easily to otherwise just ignore error variants.\n\nAlthough you can't see the warning message, try to change the code below to handle the return value from `returns_a_result`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `returns_a_result` return value should be handled.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn returns_a_result(should_be_ok: bool) -> Result<(), ()> {\n  return if should_be_ok { Ok(()) } else { Err(()) };\n}\n\n// Handle the Result returned below:\nreturns_a_result(true);",
          "solutionCode": "fn returns_a_result(should_be_ok: bool) -> Result<(), ()> {\n  return if should_be_ok { Ok(()) } else { Err(()) };\n}\n\n// Handle the Result returned below:\nlet result = returns_a_result(true);\n\nif let Err(_) = result {\n  println!(\"Got an error!\");\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "Wa2ybokzPf",
          "title": "Additional Result Methods",
          "instructions": "`Result` types also provide a few helpful methods. See the code below for details.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile with no errors.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "let result: Result<&str, &str> = Ok(\"This Result is OK\");\n\nif result.is_ok() {\n  // 'Unwrapping' a Result or Option enum in Rust returns the\n  // enclosed value, or panics. This is a direct, concise way\n  // to extract a value from one of these types, but more dangerous\n  // because it will halt your program if the type is not what\n  // you expected. Here, we can be sure the Result is OK since\n  // we performed the check on the above line.\n  let value = result.unwrap();\n  println!(\"This result has value: {}\", value);\n}\n\nlet result: Result<&str, &str> = Err(\"This Result is an Err variant!\");\n\nif result.is_ok() {\n  let value = result.unwrap();\n  println!(\"This result has value: {}\", value);\n} else {\n  // We cannot unwrap an Err from a Result. Unwrapping returns\n  // the enclosed Ok variant of a Result or Some value of an Option.\n  // Change this code to extract the enclosed Err and print it out.\n  let value = result.unwrap();\n  println!(\"This error has value: {}\", value);\n}",
          "solutionCode": "let result: Result<&str, &str> = Ok(\"This Result is OK\");\n\nif result.is_ok() {\n  // 'Unwrapping' a Result or Option enum in Rust returns the\n  // enclosed value, or panics. This is a direct, concise way\n  // to extract a value from one of these types, but more dangerous\n  // because it will halt your program if the type is not what\n  // you expected. Here, we can be sure the Result is OK since\n  // we performed the check on the above line.\n  let value = result.unwrap();\n  println!(\"This result has value: {}\", value);\n}\n\nlet result: Result<&str, &str> = Err(\"This Result is an Err variant!\");\n\nif result.is_ok() {\n  let value = result.unwrap();\n  println!(\"This result has value: {}\", value);\n} else {\n  // We cannot unwrap an Err from a Result. Unwrapping returns\n  // the enclosed Ok variant of a Result or Some value of an Option.\n  // Change this code to extract the enclosed Err and print it out.\n  if let Err(err_value) = result {\n    println!(\"This error has value: {}\", err_value);\n  }\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "XXMMDnL1v",
          "title": "Don't Panic, There No Exceptions",
          "instructions": "In Rust, there are no exceptions. In many other programming languages you have a notion of throwing and catching errors, and propagating thrown errors up the function call chain. Such errors will eventually end up as runtime program errors, if never caught and handled.\n\nIn Rust there is no capacity for \"throwing\" errors. Instead, the recommended approach if you have code which may need to represent an error state is to use a `Result`. You can return `Result`s from functions to convey error/failure information back to the user.\n\nHowever, in some cases your program finds itself in an unrecoverable state. It doesn't make sense to encode various `Err` variants to describe this and pass them back to calling code. The program is in a state that you know \"shouldn't exist\" \\(famous last words\\) or that otherwise cannot be recovered from.\n\nIn these cases, you can panic.\n\nRust provides a `panic!` macro for such scenarios. `panic!` will immediately halt your program and exit. In the code below, you can imagine we have a web request and we are looking up the current user. The user should always exist. Update the `handle_request` function to panic if in fact the user turns out to be `None`.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nuse std::panic;\nfn test() -> bool {\n  // Try/catch the panic, ha ha\n  let result = panic::catch_unwind(|| {\n    handle_request(true);\n  });\n\n  if let Ok(_) = result {\n    panic!(\"Handle request should panic if the is no user!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `handle_request` function should panic if the user is a `None` variant.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct User {\n  id: String,\n  username: String,\n  // other data...\n}\n\nfn get_user_from_request(should_return_a_user: bool) -> Option<User> {\n  if should_return_a_user {\n    return Some(User {\n      id: \"as70dfa0f70asdfa\".to_string(),\n      username: \"midnight\".to_string(),\n    });\n  } else {\n    None\n  }\n}\n\nfn handle_request(should_return_a_user: bool) {\n  let user = get_user_from_request(should_return_a_user);\n\n  // If the user is None, panic\n  println!(\"Here is the user: {:?}\", user);\n}\n\nhandle_request(true);",
          "solutionCode": "#[derive(Debug)]\nstruct User {\n  id: String,\n  username: String,\n  // other data...\n}\n\nfn get_user_from_request(should_return_a_user: bool) -> Option<User> {\n  if should_return_a_user {\n    return Some(User {\n      id: \"as70dfa0f70asdfa\".to_string(),\n      username: \"midnight\".to_string(),\n    });\n  } else {\n    None\n  }\n}\n\nfn handle_request(should_return_a_user: bool) {\n  let user = get_user_from_request(should_return_a_user);\n\n  // If the user is None, panic\n  if let None = user {\n    panic!(\"Should always have a user here!\");\n  } else {\n    println!(\"Here is the user: {:?}\", user);\n  }\n}\n\nhandle_request(true);",
          "content": ""
        },
        {
          "type": "section",
          "id": "JAYJEcvrv",
          "title": "Testing",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "The Rust language has built\\-in support for writing and running tests. We will see all about it in this section."
        },
        {
          "type": "rust",
          "id": "R9KzjlYp7",
          "title": "Writing Tests in Rust",
          "instructions": "Support for testing is built into the Rust language. This makes writing, running, and automating tests easy and consistent across between different Rust projects. Take a look at the code in the editor and complete the function so the tests pass.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The tests should pass.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(\n    CODE_STRING,\n    TEST_STRING,\n    true\n  );\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn test_this_function() -> bool {\n  // Should return true...\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn it_works() {\n    let result = test_this_function();\n    assert_eq!(result, true);\n  }\n}",
          "solutionCode": "fn test_this_function() -> bool {\n  true\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn it_works() {\n    let result = test_this_function();\n    assert_eq!(result, true);\n  }\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "NLBxzpu8D",
          "title": "Mark Tests with the Test Attribute",
          "instructions": "You can mark test functions using the `#[test]` attribute\\. We've seen attributes before, such as the `[#derive]` attribute used for deriving traits like `Debug`. To run tests on a Rust project, you use the command `cargo test` which will build a binary of your code which specifically executes any functions marked with the `#[test]` attribute\\.\n\nThe tests are grouped under a `mod tests` block annotated with the `#[cfg(test)]` attribute\\. This [cfg attribute](https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute) takes a configuration predicate which instructs the compiler to only include the associated code based on a particular configuration predicate. In this case, it means to only compile the test code when the test configuration is active. This means the test code is excluded when you build and run your program, or when you compile a release binary.\n\nUse these attributes to define a new test module for the function in the editor below.\n\n> Hint: Use `super::*` in the test module like in the last challenge to make the code in the outer scope available within that test module.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `add_vector_ints` function is tested using `#[cfg(test)]` and `#[test]` attributes.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"#[cfg(test)]\")).toBe(true);\n  expect(CODE_STRING.includes(\"#[test]\")).toBe(true);\n\n  const result = await executeRustChallengeTests(\n    CODE_STRING,\n    TEST_STRING,\n    true\n  );\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "fn add_vector_ints(v: Vec<i32>) -> i32 {\n  v.iter().sum()\n}\n\n// Write your code here",
          "solutionCode": "fn add_vector_ints(v: Vec<i32>) -> i32 {\n  v.iter().sum()\n}\n\n#[cfg(test)]\nmod test {\n  use super::*;\n\n  #[test]\n  fn test_add_vector_ints() {\n    let vector = vec![2, 4, 6];\n    assert_eq!(add_vector_ints(vector), 12);\n\n    let vector = vec![20, 20, 20, 20, 20, 100, 800, 1];\n    assert_eq!(add_vector_ints(vector), 1001);\n\n    let vector = vec![9, 8, 7, 6, 5, 4, 3, 2, 1];\n    assert_eq!(add_vector_ints(vector), 45);\n  }\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "@Y37G7Zen",
          "title": "Using Assertion Macros with Tests",
          "instructions": "Rust provides a few assertion macros which can be used to perform equality checks. We have seen these in the previous challenges in several challenges, but now we will outline them all:\n\n* `assert!` takes a single argument and expects it to evaluate to `true`.\n* `assert_eq!` compares two arguments and expects them to be equivalent.\n* `assert_ne!` compares two arguments and expects them to be non\\-equivalent.\n\n\nWe can also provide additional arguments after the values we want to check, namely a custom message which we will be surfaced if the assertion fails. These messages allow you to interpolate actual values using the `{}` or `{:?}` syntax\\. Complete the test below using the appropriate assertion macro, and try adding some custom messages.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n\n  true\n}\n`;\n\ntest(\"The tests should pass and use all three assertion macros.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(\n    CODE_STRING,\n    TEST_STRING,\n    true\n  );\n  handleAlternateLanguageTestResult(result, console.log);\n  if (result.passed) {\n    expect(CODE_STRING.includes(\"assert!(\")).toBe(true);\n    expect(CODE_STRING.includes(\"assert_eq!(\")).toBe(true);\n    expect(CODE_STRING.includes(\"assert_ne!(\")).toBe(true);\n  }\n});\n",
          "videoUrl": "",
          "starterCode": "fn is_great_than_some_critical_threshold(value: f64) -> bool {\n  // Some arbitrary threshold... imagine more complicated calculations here...\n  const THRESHOLD: f64 = 72.89;\n  return value > THRESHOLD;\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn asset_result_should_be_true() {\n    let test_value = 200.3;\n    let result = is_great_than_some_critical_threshold(test_value);\n    assert!(result, \"Expected {} to be greater than some critical threshold.\", test_value);\n  }\n  \n  // Implement two other tests using assert_eq! and assert_ne! here:\n}\n",
          "solutionCode": "fn is_great_than_some_critical_threshold(value: f64) -> bool {\n  // Some arbitrary threshold... imagine more complicated calculations here...\n  const THRESHOLD: f64 = 72.89;\n  return value > THRESHOLD;\n}\n\n#[cfg(test)]\nmod tests {\n  use super::*;\n\n  #[test]\n  fn asset_result_should_be_true() {\n    let test_value = 200.3;\n    let result = is_great_than_some_critical_threshold(test_value);\n    assert!(result, \"Expected {} to be greater than some critical threshold.\", test_value);\n  }\n\n  #[test]\n  fn assert_eq_result_should_be_true() {\n    let test_value = 200.5;\n    let result = is_great_than_some_critical_threshold(test_value);\n    assert_eq!(result, true, \"Expected {} to be greater than some critical threshold.\", test_value);\n  }\n\n  #[test]\n  fn assert_ne_result_should_be_false() {\n    let test_value = 2.7;\n    let result = is_great_than_some_critical_threshold(test_value);\n    assert_ne!(result, true, \"Expected {} to not be greater than some critical threshold.\", test_value);\n  }\n}",
          "content": ""
        },
        {
          "type": "rust",
          "id": "oAZCGsLiK0",
          "title": "Testing a Function Should Panic",
          "instructions": "Sometimes we expect our code to panic under certain scenarios. Rust provides helpful utilities to test that functions should panic. We can apply the `#[should_panic]` attribute to a test function, optionally add a message. Check out the code in the editor below for an example.\n\nModify the `validate_move_coordinates_for_game_board` function to panic if a move is requested outside of the board dimensions.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `validate_move_coordinates_for_game_board` function should panic if the request `(x, y)` position is beyond the dimensions of the board.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(\n    CODE_STRING,\n    TEST_STRING,\n    true\n  );\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "const BOARD_DIMENSION_X: i32 = 200;\nconst BOARD_DIMENSION_Y: i32 = 100;\n\nfn validate_move_coordinates_for_game_board(x: i32, y: i32) {\n  // Check the request (x, y) coordainates here and panic if\n  // they are out of bounds for the board dimensions\n\n  ()\n}\n\n#[cfg(test)]\nmod test {\n  use super::*;\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn positions_too_large_should_panic() {\n    validate_move_coordinates_for_game_board(700, 800);\n  }\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn y_coordinate_too_large_should_panic() {\n    validate_move_coordinates_for_game_board(5, 1000);\n  }\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn x_coordinate_too_large_should_panic() {\n    validate_move_coordinates_for_game_board(600, 90);\n  }\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn negative_coordinates_should_panic() {\n    validate_move_coordinates_for_game_board(-5, 0);\n  }\n}\n",
          "solutionCode": "const BOARD_DIMENSION_X: i32 = 200;\nconst BOARD_DIMENSION_Y: i32 = 100;\n\nfn validate_move_coordinates_for_game_board(x: i32, y: i32) {\n  if x < 0 || y < 0 {\n    panic!(\"Requested coordinates are off the board!\");\n  }\n\n  if x > BOARD_DIMENSION_X || y > BOARD_DIMENSION_Y {\n    panic!(\"Requested coordinates are off the board!\");\n  }\n\n  ()\n}\n\n#[cfg(test)]\nmod test {\n  use super::*;\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn positions_too_large_should_panic() {\n    validate_move_coordinates_for_game_board(700, 800);\n  }\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn y_coordinate_too_large_should_panic() {\n    validate_move_coordinates_for_game_board(5, 1000);\n  }\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn x_coordinate_too_large_should_panic() {\n    validate_move_coordinates_for_game_board(600, 90);\n  }\n\n  #[test]\n  #[should_panic(expected = \"Requested coordinates are off the board!\")]\n  fn negative_coordinates_should_panic() {\n    validate_move_coordinates_for_game_board(-5, 0);\n  }\n}\n",
          "content": ""
        },
        {
          "type": "rust",
          "id": "oah9ZW$1c",
          "title": "Writing Tests Using the Result Type",
          "instructions": "We can also utilize the `Result` type when testing functions. If you return an `Err` from a test, the test will fail. The test functions in the editor below both to a `Result` type, but currently they both fail. Modify the test code so that both tests pass.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `valid_passwords_are_accepeted` and `invalid_passwords_are_rejected` tests should pass.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(\n    CODE_STRING,\n    TEST_STRING,\n    true\n  );\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Imagine actually a password is looked up in a database here\n// to compare to the user submitted password...\nfn is_password_valid(password: String) -> Result<(), String> {\n  let PASSWORD = \"super-secret-password\";\n\n  if password == PASSWORD {\n    return Ok(());\n  }\n  \n  Err(String::from(\"Wrong password.\"))\n}\n\n#[cfg(test)]\nmod test {\n  use super::*;\n\n  #[test]\n  fn valid_passwords_are_accepeted() -> Result<(), String> {\n    let result = is_password_valid(\"secret-password\".to_string());\n    if let Ok(_) = result {\n      Ok(())\n    } else {\n      Err(String::from(\"Expected password to be valid.\"))\n    }\n  }\n\n  #[test]\n  fn invalid_passwords_are_rejected() -> Result<(), String> {\n    let result = is_password_valid(\"super-secret-password\".to_string());\n    if let Ok(_) = result {\n      Ok(())\n    } else {\n      Err(String::from(\"Expected password to be invalid.\"))\n    }\n  }\n}\n",
          "solutionCode": "// Imagine actually a password is looked up in a database here\n// to compare to the user submitted password...\nfn is_password_valid(password: String) -> Result<(), String> {\n  let PASSWORD = \"super-secret-password\";\n\n  if password == PASSWORD {\n    return Ok(());\n  }\n  \n  Err(String::from(\"Wrong password.\"))\n}\n\n#[cfg(test)]\nmod test {\n  use super::*;\n\n  #[test]\n  fn valid_passwords_are_accepeted() -> Result<(), String> {\n    let result = is_password_valid(\"super-secret-password\".to_string());\n    if let Ok(_) = result {\n      Ok(())\n    } else {\n      Err(String::from(\"Expected password to be valid.\"))\n    }\n  }\n\n  #[test]\n  fn invalid_passwords_are_rejected() -> Result<(), String> {\n    let result = is_password_valid(\"secret-password\".to_string());\n    if let Ok(_) = result {\n      Err(String::from(\"Expected password to be invalid.\"))\n    } else {\n      Ok(())\n    }\n  }\n}\n",
          "content": ""
        },
        {
          "type": "section",
          "id": "usDs33hMCZ",
          "title": "Modules, Crates and Cargo",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "How do modules, libraries, and package management work in Rust?"
        }
      ]
    },
    {
      "id": "GDSzv2jA7",
      "title": "Basic Challenges",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "1@q9EgYpm",
          "title": "Basic Challenges",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "We have now covered many of the basics of the Rust language.\n\nNow, we will have a brief interlude of programming challenges and projects to practice what we've learned before diving into some more advanced topics.\n\nIt's important to get a lot of hands on practice when learning a new language—that's what this section is about.\n\nDon't worry if the challenges feel too easy or hard, just do you best and try to get as much practice writing and thinking in Rust as you can. See you on the other side\\!"
        },
        {
          "type": "rust",
          "id": "SfTt1nKS$",
          "title": "Array Sum",
          "instructions": "You are given an array of `f64` values\\. Write a function `array_sum` to return the sum of all the values in the array.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let input_array: InputArray = [\n    234.982,\n    432.772,\n    91.32,\n    42321231.2,\n    893.223,\n    576.243,\n    24.3,\n    2342.2,\n    422.1,\n    100.02,\n  ];\n\n  let result = array_sum(input_array);\n  assert_eq!(result, 42326348.36000001);\n\n  true\n}\n`;\n\ntest(\"The `array_sum` function should exist and return an `OutputSum` type given an `InputArray`.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "type InputArray = [f64; 2];\ntype OutputSum = f64;\n\n// Write your code here:",
          "solutionCode": "type InputArray = [f64; 10];\ntype OutputSum = f64;\n\n// Write your code here:\nfn array_sum(input_array: InputArray) -> OutputSum {\n  let mut sum: f64 = 0 as f64;\n  for x in input_array.iter() {\n    sum = sum + x;\n  }\n  sum\n}\n\nlet input_array: InputArray = [\n  234.982,\n  432.772,\n  91.32,\n  4.2321231,\n  893.223,\n  576.243,\n  24.3,\n  2342.2,\n  422.1,\n  342.0,\n];\n\nlet result = array_sum(input_array);\nprintln!(\"Result: {}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "aQ6M6ZmiF",
          "title": "Find in a Vector",
          "instructions": "You are given a vector of integers and a target value. Return an option indicating if the target exists in the vector, and if so, how many times it is present.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut vec = Vec::new();\n  for x in 0..1000 {\n    if x % 2 == 0 {\n      vec.push(50);\n    } else {\n      vec.push(x);\n    }\n  }\n\n  let result = find_in_vector(vec, 50);\n  assert_eq!(result.unwrap(), 500);\n\n  let result = find_in_vector(Vec::new(), 500);\n  if let Some(_x) = result {\n    panic!(\"Value should not be present in vector, expected None!\");\n  }\n\n  true\n}\n`;\n\ntest(\"The `find_in_vector` function should exist and return an `Option` representing the number of times the `target` value is found in the given vector, or `None` otherwise.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write Your code here",
          "solutionCode": "fn find_in_vector(v: Vec<i64>, target: i64) -> Option<u32> {\n  let mut found_count: u32 = 0;\n\n  for x in v.iter() {\n    if *x == target {\n      found_count = found_count + 1;\n    }\n  }\n\n  if found_count == 0 {\n    None\n  } else {\n    Some(found_count)\n  }\n}\n\n// Create and populate a new vector\nlet mut vec = Vec::new();\nfor x in 0..1000 {\n  if x % 2 == 0 {\n    vec.push(50);\n  } else {\n    vec.push(x);\n  }\n}\n\nlet result = find_in_vector(vec, 50);\nprintln!(\"Result = {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "lb1erIfLNp",
          "title": "Rectangle Area",
          "instructions": "Create a struct `Rectangle` and implement `new` and `area` methods such that the following code is valid:\n\n```\nlet rect = Rectangle::new(5, 10);\nlet area = rect.area();\nassert_eq!(area, 50);\n\n```\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let rect = Rectangle::new(5, 10);\n  let area = rect.area();\n  assert_eq!(area, 50);\n\n  true\n}\n`;\n\ntest(\"The `Rectangle` struct should exist and implement `new` and `area` methods correctly.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here",
          "solutionCode": "struct Rectangle {\n  width: u32,\n  height: u32,\n}\n\nimpl Rectangle {\n  fn new(width: u32, height: u32) -> Self {\n    Rectangle {\n      width,\n      height,\n    }\n  }\n\n  fn area(&self) -> u32 {\n    self.width * self.height\n  }\n}\n\nlet rect = Rectangle::new(42, 58);\nlet area = rect.area();\nassert_eq!(area, 2436);\nprintln!(\"The rectangle's area is: {}\", area);",
          "content": ""
        }
      ]
    },
    {
      "id": "ACiP6Y2O5e",
      "title": "Mini Projects",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "@n6b3RDWPm",
          "title": "Rust Mini Projects",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "We have now covered a lot of Rust fundamentals\\!\n\nCongratulations you are well on the way to becoming a proficient Rust programmer\\!\n\nIt's time to get our hands dirty writing some Rust code. We've learned enough to write a few more complex programs. This section introduces a few mini projects which will give you a chance to test out your newly acquired Rust chops."
        },
        {
          "type": "rust",
          "id": "j$ugekdN1",
          "title": "Simulate Tic Tac Toe",
          "instructions": "We've provided some code in the editor below. We want to simulate a Tic Tac Toe game and have created a function `simulate_tic_tac_toe` which takes a parameter of the number of games to simulate.\n\nYour job is to create additional code to handle this game simulation. The game simulation can just involve two players, the \"player\" and \"computer\", randomly playing against each other.\n\nOnce all the games are complete, return a `Result` containing a `GameResult` from the `simulate_tic_tac_toe` function\\.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let result = simulate_tic_tac_toe(10);\n  match result {\n    Ok(x) => {\n      let total = x.player_wins + x.computer_wins + x.stalemates;\n      assert_eq!(total, 10);\n      assert_eq!(x.games_played, 10);\n    }\n    Err(_e) => {\n      panic!(\"Function should return an Ok result not return an Err!\");\n    }\n  }\n\n  true\n}\n`;\n\ntest(\"The `simulate_tic_tac_toe` function should return a `GameResult` representing the number of games simulated and the results.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "#[derive(Debug)]\nstruct GameResult {\n  games_played: u32,\n  player_wins: u32,\n  computer_wins: u32,\n  stalemates: u32,\n}\n\n// Change anything except this function signaure ;)\nfn simulate_tic_tac_toe(number_of_games_to_play: u32) -> Result<GameResult, String> {\n  println!(\"Ready to start playing {} games!\", number_of_games_to_play);\n  \n  // Write your code here, or anywhere else\n\n  Err(String::from(\"The game is not implemented yet!\"))\n}\n\nlet result = simulate_tic_tac_toe(3);\nprintln!(\"Game result: {:?}\", result);",
          "solutionCode": "#[derive(Debug)]\nstruct GameResult {\n  games_played: u32,\n  player_wins: u32,\n  computer_wins: u32,\n  stalemates: u32,\n}\n\n// Change anything except this function signaure ;)\nfn simulate_tic_tac_toe(number_of_games_to_play: u32) -> Result<GameResult, String> {\n  println!(\"Ready to start playing {} games!\", number_of_games_to_play);\n  \n  // TODO: Implement solution\n  let result = GameResult {\n    games_played: number_of_games_to_play,\n    player_wins: number_of_games_to_play,\n    computer_wins: 0,\n    stalemates: 0,\n  };\n\n  Ok(result)\n}\n\nlet result = simulate_tic_tac_toe(3);\nprintln!(\"Game result: {:?}\", result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "OqvRFEtR3",
          "title": "Create a Maze",
          "instructions": "Create a maze struct which allows you to initialize a new maze grid with a new method passing in `i32` values for the dimensions of the maze. The maze struct should provide a method `move_player` which accepts a direction to move the player in \\(see the `MoveDirection` enum defined below\\). Finally, the struct should implement `set_position` and `get_position` method which return a `Position` type\\.\n\nThe maze coordinates work as follows:\n\n```\n// Position (i32, i32) -> (x, y) coordinate\n\n[\n    [Cell, Cell, Cell],\n    [Cell, Cell, Cell],\n    [Cell, Cell, Cell],\n]\n\n// In this 'maze', position (0, 0) is the bottom left Cell\n// position (2, 0) is the bottom right cell, and position\n// (2, 1) is the middle of the right column.\n\n```\n\nTry to test out most of the Rust language features you have learned so far: structs, enums, tuples, and implementation blocks\\! Good luck\\!",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut maze = Maze::new(5, 10);\n  maze.set_position((1, 5));\n  let position = maze.get_position();\n  assert_eq!(position.0, 1);\n  assert_eq!(position.1, 5);\n\n  let mut maze = Maze::new(100, 100);\n  maze.set_position((50, 80));\n  let position = maze.get_position();\n  assert_eq!(position.0, 50);\n  assert_eq!(position.1, 80);\n\n  maze.move_player(MoveDirection::Up);\n  maze.move_player(MoveDirection::Up);\n  maze.move_player(MoveDirection::Up);\n  maze.move_player(MoveDirection::Up);\n  maze.move_player(MoveDirection::Up);\n\n  let position = maze.get_position();\n  assert_eq!(position.0, 50);\n  assert_eq!(position.1, 85);\n\n  maze.move_player(MoveDirection::Left);\n  maze.move_player(MoveDirection::Left);\n  maze.move_player(MoveDirection::Left);\n  maze.move_player(MoveDirection::Left);\n  maze.move_player(MoveDirection::Left);\n\n  let position = maze.get_position();\n  assert_eq!(position.0, 45);\n  assert_eq!(position.1, 85);\n\n  true\n}\n`;\n\ntest(\"The `Maze` struct should be defined and implement the methods described in the instructions.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// (x, y) coordinates for a current position\ntype Position = (i32, i32);\n\n// A direction to move in\nenum MoveDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\n// Write your code here",
          "solutionCode": "type Position = (i32, i32);\n\n#[derive(Clone, Copy)]\nenum MoveDirection {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\n#[derive(Debug)]\nenum MazeCell {\n    Wall,\n    Empty,\n    Player,\n}\n\ntype MazeGrid = Vec<Vec<MazeCell>>;\n\n#[derive(Debug)]\nstruct Maze {\n    x_dimension: i32,\n    y_dimension: i32,\n    maze_grid: MazeGrid,\n    current_position: Position,\n}\n\nimpl Maze {\n    fn new(x: i32, y: i32) -> Self {\n        fn create_maze_row(row_size: i32) -> Vec<MazeCell> {\n            let mut row: Vec<MazeCell> = Vec::new();\n            let mut current = 0;\n            while current < row_size {\n                row.push(MazeCell::Empty);\n                current = current + 1;\n            }\n            row\n        }\n\n        let mut maze: MazeGrid = Vec::new();\n        let mut current = 0;\n        while current < y {\n            let row = create_maze_row(x);\n            maze.push(row);\n            current = current + 1;\n        }\n\n        let maze = Maze {\n            x_dimension: x,\n            y_dimension: y,\n            maze_grid: maze,\n            current_position: (0, 0),\n        };\n\n        maze\n    }\n\n    fn print(&self) {\n        println!(\"- Current Grid:\\n\");\n        for row in self.maze_grid.iter() {\n            println!(\"{:?}\", row);\n        }\n        println!(\"\");\n        println!(\"- Current Position: {:?}\", self.get_position());\n        println!(\"\");\n    }\n}\n\nimpl Maze {\n    fn get_position(&self) -> Position {\n        self.current_position\n    }\n\n    fn set_position(&mut self, position: Position) -> Result<(), String> {\n        let (x, y) = position;\n        if x < 0 || y < 0 {\n            return Err(format!(\n                \"Request position out of bounds, rejected move to position: {:?}\",\n                position\n            ));\n        } else if x >= self.x_dimension {\n            return Err(format!(\n                \"Request position out of bounds, rejected move to position: {:?}\",\n                position\n            ));\n        } else if y >= self.y_dimension {\n            return Err(format!(\n                \"Request position out of bounds, rejected move to position: {:?}\",\n                position\n            ));\n        } else {\n            let current_position = self.get_position();\n            // Move player\n            self.current_position = position;\n            let row = &mut self.maze_grid[y as usize];\n            row[x as usize] = MazeCell::Player;\n\n            let previous_x = current_position.0 as usize;\n            let previous_y = current_position.1 as usize;\n            let previous_row = &mut self.maze_grid[previous_y];\n            previous_row[previous_x] = MazeCell::Empty;\n        }\n\n        Ok(())\n    }\n\n    fn move_player(&mut self, move_direction: MoveDirection) -> Result<(), String> {\n        let current_position = self.get_position();\n        let mut x: i32 = current_position.0;\n        let mut y: i32 = current_position.1;\n        match move_direction {\n            MoveDirection::Up => {\n                y = y + 1;\n            }\n            MoveDirection::Down => {\n                y = y - 1;\n            }\n            MoveDirection::Left => {\n                x = x - 1;\n            }\n            MoveDirection::Right => {\n                x = x + 1;\n            }\n        }\n\n        self.set_position((x, y))\n    }\n\n\t\tfn move_to_limit_in_direction(&mut self, direction: MoveDirection) {\n\t\t\twhile let Ok(_) = self.move_player(direction) {\n\t\t\t\t// Move until end is reached\n\t\t\t}\n\t\t}\n}",
          "content": ""
        },
        {
          "type": "project",
          "id": "4EVV8$2gn",
          "title": "Rock Paper Scissors Command Line Game",
          "instructions": "",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Create a command line game using Rust to play Rock Paper Scissors against a computer. The game should have this behavior:\n\n* For a give game round, request a user's move on the command line. User's can enter `Rock`, `Paper`, or `Scissors`. Randomly choose a computer's move in response, and then announce the winner, or stalemate.\n* After a game round, a player can quit or play again.\n* As games progress, the program keeps track of the wins on both sides, and stalemates.\n* Be sure to consider all edge cases and errors, e.g. what if a player enters a wrong move input. Rust is type safe, but input from the outside world \\(e.g. from a user, from a library, from an API\\) may not adhere to the data assumptions you expect \\- validation and error checking is important.\n* For a bonus, the user can enable an \"autoplay\" feature which will just continue to play games until they choose to quit \\(e.g. type `Quit`\\).\n\n\nBuild your project using `cargo` and share your code on GitHub once complete. Good luck\\!\n"
        }
      ]
    },
    {
      "id": "AX04ZC5H8",
      "title": "Ownership and Borrowing",
      "free": false,
      "challenges": []
    },
    {
      "id": "5wbe@14QT",
      "title": "Generics, Traits and Lifetimes",
      "free": false,
      "challenges": []
    },
    {
      "id": "zfbfBa6nP",
      "title": "Macros",
      "free": false,
      "challenges": []
    },
    {
      "id": "HiDVdMr4I",
      "title": "Concurrency",
      "free": false,
      "challenges": []
    },
    {
      "id": "XT73AIuM5",
      "title": "Advanced Topics",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "axPeNlByhG",
          "title": "Advanced Topics",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "This section will cover additional Rust features, such as:\n\n* Functional programming techniques in Rust\n* Object\\-oriented programming techniques in Rust\n* Unsafe code\n* Some advanced features\n\n"
        },
        {
          "type": "rust",
          "id": "PMz$hmkFP",
          "title": "Unsafe Code",
          "instructions": "The Rust compiler, as we have seen in the previous challenges, is very strict when enforcing code correctness and preventing runtime errors. It is possible to opt out of the compiler's strict behavior, but it is of course _unsafe_ to do so.\n\nLet's take a look at the editor below. If you compile the code you will see an error: `use of mutable static is unsafe and requires unsafe function or block`.\n\nGlobal, mutable state can be dangerous in a variety of programming scenarios, but in Rust this is explicit. The compiler does not allow you to have global mutable state with explicitly declaring it is _unsafe_. Nice\\!\n\nTo write unsafe code you have wrap the code in question in an `unsafe {...}` code block. Do this to complete the challenge.",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The code should compile and use an `unsafe` block to allow the mutation of global state (a dangerous thing to do!).\", async () => {\n  const CODE_STRING = __user_code_string__;\n  expect(CODE_STRING.includes(\"unsafe\")).toBe(true);\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "static mut DANGEROUS_GLOBAL_MUTABLE_CONSTANT: u8 = 10;\n\nfn mutating_global_state_is_dangerous() {\n  println!(\"[1] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n  DANGEROUS_GLOBAL_MUTABLE_CONSTANT = 5;\n  println!(\"[2] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n}\n\nmutating_global_state_is_dangerous();",
          "solutionCode": "static mut DANGEROUS_GLOBAL_MUTABLE_CONSTANT: u8 = 10;\n\nfn mutating_global_state_is_dangerous() {\n  unsafe {\n    println!(\"[1] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n    DANGEROUS_GLOBAL_MUTABLE_CONSTANT = 5;\n    println!(\"[2] DANGEROUS_GLOBAL_MUTABLE_CONSTANT is: {}\", DANGEROUS_GLOBAL_MUTABLE_CONSTANT);\n  }\n}\n\nmutating_global_state_is_dangerous();",
          "content": ""
        },
        {
          "type": "rust",
          "id": "P9Ag0kmmB",
          "title": "Type Casting",
          "instructions": "It is possible to cast between primitive types in Rust. No implicit coercion is allowed but you can try to cast to a new type using the `as` keyword, e.g. `my_value as char` will attempt to cast `my_value` \\(whatever it is\\) to `char`. In the editor below, we show how to cast from a floating point type to an integer type. But this of course results in the loss of information. Complete the `cast_float_to_integer` function to cast the given floating point value to an integer and return it.\n\n> Casting is non standard and should be used with caution only if you know what you are doing.\n",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  let mut flt: f64 = 1.231;\n  let mut result = cast_float_to_integer(flt);\n  assert_eq!(result, 1);\n\n  flt = 1982.9123100;\n  result = cast_float_to_integer(flt);\n  assert_eq!(result, 1982);\n\n  flt = 0.218;\n  result = cast_float_to_integer(flt);\n  assert_eq!(result, 0);\n\n  true\n}\n`;\n\ntest(\"The `cast_float_to_integer` function should cast the given floating point number into an `i128` integer and return it.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Type casting can result in the loss of information. Only\n// use it sparingly if you know what you are doing.\nfn cast_float_to_integer(flt: f64) -> i128 {\n  // Write your code here\n}\n\nlet mut flt: f64 = 1.231;\nlet mut result = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 1982.9123100;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 0.218;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);",
          "solutionCode": "// Type casting can result in the loss of information. Only\n// use it sparingly if you know what you are doing.\nfn cast_float_to_integer(flt: f64) -> i128 {\n  flt as i128\n}\n\nlet mut flt: f64 = 1.231;\nlet mut result = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 1982.9123100;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);\n\nflt = 0.218;\nresult = cast_float_to_integer(flt);\nprintln!(\"Casting float {} to integer, result: {}\", flt, result);",
          "content": ""
        },
        {
          "type": "rust",
          "id": "41ECx9cAB",
          "title": "Closures",
          "instructions": "TODO",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "TX6cpQJuy",
          "title": "Smart Pointers",
          "instructions": "TODO",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        },
        {
          "type": "rust",
          "id": "zWcmBRsu0d",
          "title": "Async/Await and Futures",
          "instructions": "TODO",
          "testCode": "// Do not change the following line, it is used in Rust file export generation.\nconst TEST_STRING = `\n// Returns a boolean representing challenge test status.\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": ""
        }
      ]
    },
    {
      "id": "krVVmQd$S",
      "title": "Intermediate Challenges",
      "challenges": [
        {
          "type": "section",
          "id": "32C7HdQle",
          "title": "Practice Challenges",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this next section \\(and final section before the projects\\) we will cover various Rust programming challenges which are intended to give your more experience writing and working with Rust syntax, data structures, and functions."
        },
        {
          "id": "Flaxrbchq",
          "type": "rust",
          "title": "String Sub String",
          "instructions": "Write a function `string_sub_string` which accepts two string inputs and returns `true` if the second is a substring of the first. For instance, `\"plan\"` is a substring of `\"planned\"`, but not a substring of `\"globe\"`.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut result = string_sub_string(\"\", \"\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plannede\");\n      if result != false {\n        return false;\n      }\n\n      result = string_sub_string(\"planned\", \"planned\");\n      if result != true {\n        return false;\n      }\n      \n      result = string_sub_string(\"planned\", \"plan\");\n      if result != true {\n        return false;\n      }\n\n      result = string_sub_string(\"as89df709asfuoiasudfisaodfusadFSAFASFASDf\", \"sfuoiasudfisaodfusadFSAF\");\n      if result != true {\n        return false;\n      }\n      \n      return true;\n    }\n  `;\n\ntest(\"`string_sub_string` should return `true` if the second input argument is a substring of the first.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here\n",
          "solutionCode": "// Determine if a string is a valid substring of another\nfn string_sub_string(a: &str, b: &str) -> bool {\n  // Immediately return true if strings are simply equal, including empty strings\n  if a == b {\n    return true;\n  }\n\n  // Convert both strings to vectors\n  let mut a_vec = Vec::new();\n  let mut b_vec = Vec::new();\n\n  for c in a.chars() {\n    a_vec.push(c);\n  }\n\n  for c in b.chars() {\n    b_vec.push(c);\n  }\n\n  // Ensure the first is longer than the second\n  if b_vec.len() > a_vec.len() {\n    return false;\n  }\n\n  // Iterate through the first string vector until the first character\n  // matches the first character of the second. If it does, try to\n  // iterate forward from there and match all adjacent characters.\n  let mut index = 0;\n  while index < a_vec.len() {\n    let a_value = a_vec[index];\n    let b_value = b_vec[0];\n\n    if a_value == b_value {\n      let mut a_index = index + 1;\n      let mut b_index = 1;\n      let mut valid = true;\n\n      while b_index < b_vec.len() {\n        if a_vec[a_index] == b_vec[b_index] {\n          a_index = a_index + 1;\n          b_index = b_index + 1;\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if valid {\n        return true;\n      }\n    }\n    index = index + 1;\n  }\n\n  // If you reached here and found no valid match, there is none.\n  return false;\n}\n",
          "content": ""
        },
        {
          "id": "y4tgWGLOS",
          "type": "rust",
          "title": "Fill a Vector",
          "instructions": "In Rust you can use a [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html) struct to represent a list of items. Write a function fillVector which takes a single integer input parameter and returns a vector with containing all of the integers up to and including the input parameter.\n\n```\nfill_vector(10) // -> Vec[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n```\n\n**Note: **You can assume the input will not be negative, but it may be zero.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      fn fill_vector_solution(max: i64) -> Vec<i64> {\n        let mut current = 0;\n        let mut v = Vec::new();\n        while current <= max {\n          v.push(current);\n          current = current + 1;\n        }\n        v\n      }\n\n      fn compare_vectors(v1: Vec<i64>, v2: Vec<i64>) -> bool {\n        let mut index = 0;\n        for x in &v1 {\n          let other = &v2[index];\n          if x != other {\n            return false;\n          }\n\n          index = index + 1;\n        }\n        true\n      }\n      \n      fn compare(value: i64) -> bool {\n        let mut result = fill_vector(value);\n        let mut expected = fill_vector_solution(value);\n        if compare_vectors(result.to_owned(), expected.to_owned()) == false {\n          return false;\n        }\n        true\n      }\n      \n      let mut value = 5;\n      let values = vec![0, 1, 6, 12, 15, 26, 88, 900];\n      for v in values {\n        if compare(v) == false {\n          return false;\n        }\n      }\n      true\n    }\n  `;\n\ntest(\"`fill_vector` should accept an integer argument and return a new vector of all of the integers up to and including that integer argument.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Fill up a vector",
          "solutionCode": "// Fill up a vector\nfn fill_vector(max: i64) -> Vec<i64> {\n  let mut current = 0;\n  let mut result = Vec::new();\n  while current <= max {\n    result.push(current);\n    current = current + 1;\n  }\n  return result;\n}\n",
          "content": ""
        },
        {
          "id": "sLQQLy12e",
          "type": "rust",
          "title": "Create a Struct",
          "instructions": "Rust [structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html) provide a way to represent more complex data structures. For this challenge, create a struct to represent a person. The struct should have the following fields: `name`, `age`, `height`, and `siblings`. These should be of type, string, integer, integer, and boolean, respectively.\n\nWrite a function `create_person` which accepts the above values as parameters and returns a new `Person` struct\\.",
          "testCode": "const TEST_STRING = `\n    fn test() -> bool {\n      let mut person = create_person(String::from(\"Sean\"), 31, 82, true);\n      if person.name.eq(\"Sean\") != true {\n        return false\n      }\n      if person.age != 31 {\n        return false;\n      }\n      if person.height != 82 {\n        return false;\n      }\n      if person.siblings != true {\n        return false;\n      }\n\n       person = create_person(String::from(\"Zakaria\"), 717, 929, false);\n      if person.name.eq(\"Zakaria\") != true {\n        return false\n      }\n      if person.age != 717 {\n        return false;\n      }\n      if person.height != 929 {\n        return false;\n      }\n      if person.siblings != false {\n        return false;\n      }\n\n      true\n    }\n  `;\n\ntest(\"`create_person` should accept the arguments `name`, `age`, `height`, and `siblings` and return a new `Person` struct.\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n",
          "videoUrl": "",
          "starterCode": "// Write your code here:",
          "solutionCode": "struct Person {\n  name: String,\n  age: u16,\n  height: u16,\n  siblings: bool,\n}\n\nfn create_person(name: String, age: u16, height: u16, siblings: bool) -> Person {\n  Person {\n    name,\n    age,\n    height,\n    siblings,\n  }\n}\n",
          "content": ""
        }
      ],
      "free": false
    },
    {
      "id": "uZZsKk7083",
      "title": "Final Projects",
      "challenges": [
        {
          "type": "section",
          "id": "tVYCXZbIl",
          "title": "Projects",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this section we will build several projects in Rust to round off your Rust learning experience."
        },
        {
          "type": "project",
          "id": "NCoNBdnxF",
          "title": "Command Line Key Value Store",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "For this project we will build a simple key value store which can be used on the command line.\n\nWrite a Rust program to store key value pairs with the following command line API:\n\n* Set an item: `cargo run set foo bar`.\n* Get an item: `cargo run get foo`.\n* Get all items: `cargo run getAll`.\n* Remove an item: `cargo remove foo`.\n* Remove all items: `cargo removeAll`.\n\n\nYour program will store the cache in memory while it is running. For a bonus, consider adding input validation and testing for your project. For another bonus, consider having your program write the cache to disk to be able to persist cache state between sessions."
        },
        {
          "type": "project",
          "id": "NV9DixvF7",
          "title": "Key Value Web Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Here we will expand on our key value command line utility by writing a Rust server with an API for the same functionality.\n\nBuild a server in Rust which exposes a REST API to allow users to set, get, and remove items in a key value store. Unlike the command line utility, this should support set arbitrary JSON data in the `value` field for cache entries. The API should also support retrieving all existing entries, and remove all existing entries.\n\nBonus points:\n\n* Consider adding validation for requests.\n* Consider how you might add tests for your server.\n* Consider how you might add an authentication layer, or separate expose the functionality to multiple different users \\(e.g. N users consume your API, but they each access separate caches\\).\n* Consider how you might persist the cache data more permanently using a database.\n\n"
        },
        {
          "type": "project",
          "id": "UticrWdb1",
          "title": "Command Line Tic Tac Toe Game",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Let's create a Tic Tac Toe game in Rust. This will be similar to the Tic Tac Toe project in the FullStack TypeScript curriculum, if you completed that previously. Here, however, the game will be totally opened ended for you to design as you see fit. The main requirements are:\n\n* Players can play the computer in Tic Tac Toe.\n* The game will randomly choose who plays first.\n* The computer will choose a random move each round.\n* The game will obey the ordinary rules of Tic Tac Toe, and declare a winner or tie at the end.\n* Once a game completes, the player will have the option to play again.\n* For a given session, the game should get track of overall wins/losses.\n\n\nFor your program, consider edge cases, handling errors, and how you can add tests to verify the game behavior is correct. Good luck\\!\n"
        },
        {
          "type": "project",
          "id": "s2Ph4e5cp",
          "title": "Real Time Chat Server",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Build a web server using Rust which provides a real time chat functionality. For the basic implementation, consider a single chatroom which anyone can join and post messages to. The server forwards messages in real time to all connected clients.\n\nFor client implementations, you may disregard implementing a client \\(if you wish\\), or build a simple UI web client, or build a command line client in Rust which allows you to post a message to the chat server and can also subscribe to the server and print out any new messages as they arrive.\n\nFor more challenges, consider how you might change this to persist messages using a database and allow for more advanced chat features \\(e.g. direct messages between users, replies/threads, reactions, etc.\\). Finally, consider how you might test your project."
        }
      ],
      "free": false
    },
    {
      "id": "aUHE3cOCli",
      "title": "Rust in Production",
      "free": false,
      "challenges": [
        {
          "type": "section",
          "id": "663qF3qvRe",
          "title": "Rust Applications",
          "instructions": "",
          "testCode": "const TEST_STRING = `\nfn test() -> bool {\n  true\n}\n`;\n\ntest(\"The `example` function should...\", async () => {\n  const CODE_STRING = __user_code_string__;\n  const result = await executeRustChallengeTests(CODE_STRING, TEST_STRING);\n  handleAlternateLanguageTestResult(result, console.log);\n});\n\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "What is Rust actually used for in the real world, and what can you do with your Rust skills?"
        }
      ]
    }
  ]
}