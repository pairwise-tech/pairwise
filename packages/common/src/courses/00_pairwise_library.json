{
  "price": 0,
  "free": true,
  "id": "f76shgb2W",
  "title": "Pairwise Library",
  "description": "Free articles and videos on programming topics and getting hired as a software engineer.",
  "modules": [
    {
      "id": "rwD9TvhQ7",
      "title": "All About Pairwise",
      "challenges": [
        {
          "id": "BftPXyqwU",
          "type": "media",
          "title": "What is Pairwise?",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"Write your test assertion here\", () => {\n  expect(true).toBe(true);\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Pairwise is a re\\-imagination of modern education.\n\n### Background\n\nSocieties all around the world follow the same pattern of education: 8 hours of classroom education per day for over 10 years, and then more of the same in college or university. This is probably a great model for learning many subjects, e.g. foreign language or mathematics, but it may not be the best format for learning practical skills like how to program or build computer applications.\n\nAt Pairwise, we think this traditional model is not the most efficient learning model for learning practical technology skills in the modern age.\n\nMoreover, the internet and computer revolution have given individuals new powerful tools which unlock new capabilities. You can now ask Google a question and within seconds find detailed information about the answer. This has never before been possible in human history.\n\nYou can also build and deploy applications and products at global scale using just a simple laptop, at very low cost. This has never before been possible in human history.\n\n### Enter Pairwise\n\nAt Pairwise, we think that there is a big opportunity for re\\-inventing educational resources for teaching modern technology skills. Software skills do not need to be learned from a textbook, or by sitting in a classroom listening to a lecture or slideshow, or by taking tests or exams. We think software skills are best learned through hands\\-on application, and, like, most skills, best learned with the help of a thoughtful mentor.\n\nThe Pairwise platform is meant to be this combination of hands\\-on practice and mentorship. The Pairwise platform is designed to teach concepts through practical application while also providing enough supplementary content support for students to understand the skills they are learning.\n\nOur belief is the process can be fun, engaging, adventurous, and challenging \\- almost like a game\\!\n\n### Information Overload\n\nWhile the internet has made the world's information accessible to everyone in mere seconds, this is a blessing and a curse. The curse is that there is simply _too_ much information.\n\nFor the student learning to code, there is simply too much information out there. There are hundreds of hours of recorded university computer science lectures alone, not to mention other tutorials, guides, and platforms. How does someone navigate all of these limitless content and resources and choose what to learn? Moreover, how does one even decide_ what_ to learn? JavaScript, Python, Ruby, Java, C/C\\+\\+, Go, Rust \\- the list goes on, and those are just the leading programming languages, not to mention specific popular technologies or engineering specialities. To someone interested in learning to code... it's just too much\\!\n\n### The Secret of Pairwise\n\nThis is the other secret of Pairwise: we curate a specific, focused, opinionated curriculum of content which we believe represents the fastest, easiest, and most efficient pathway to **a\\)** learning to code and **b\\)** getting hired as a software developer. This frees the student from the responsibility of deciding what to learn, and lets them focus exclusively on learning. The result is massive productivity gains in the learning process.\n\nInstead of typing _\"Should I learn C\\+\\+ or Java?\"_ into Google, you will start typing _\"How to filter something from a list in TypeScript?\"_. All the time previously devoted to trying to decide _what_ to learn will now be spent on _learning\\._\n\nThis may feel strange... what if we didn't choose the right technologies or languages for you to learn?\\!\n\nConsider how universities work: Once you decide you want to be a doctor, or physicist, or even a software engineer, how much freedom do you have to decide _what_ you will learn along the way? You make the initial choice, but from there the teacher, textbook, and school take over. You start on Chapter 1 whether you like it or not. _They_ curate the content and path for you.\n\nWe are not saying we know what's best for _everyone _to learn. We are saying that it is more productive to spend your time learning rather than asking _what_ you should learn. We have made broad approximations best on industry trends and job market data to select a course which should be the most efficient for the most people. If you're curious, feel free to [read our full rationale](https://www.pairwise.tech/curriculum) for the curriculum selection.\n\nWe believe that by curating this path for the user, it can save them from the endless headaches of having to answer these questions themselves. The can focus on what matters: learning, solving problems, and building apps. If they like the process, then this is the right career for them and they can take it from there to any destination they want\\!\n\n### Only a Foundation\n\nPairwise is intended to train a new generation of software engineers. If we succeed, some of our graduates will go on to do things far beyond what we can do. Pairwise just lays the foundation and teaches people fundamental software engineering skills, and, most importantly gives people a guide for _how to learn_. From there, they can go on to independently master any other technologies they will need in their career."
        },
        {
          "id": "t$oXPf22$",
          "type": "media",
          "title": "The Pairwise Model of Learning",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "# Traditional Education\n\nAt Pairwise, we believe the internet has created a new platform where we can reinvent education. You see, traditional education \\(and most educational resources on the internet\\) follow the same pattern: content is delivered passively to a group of students from an instructor, who typically has a whiteboard or slideshow presentation.\n\n* In early life, we have grade school and high school where students sit in a classroom for ~8 hours a day and mostly listen to a teacher who presents from the front of the room.\n* In college and university, the model is largely the same: now the rooms have expanded and may house ~100 students at a time and the teacher at the front is a professor with a PhD.\n\n\nYes, of course there is more hands\\-on education especially at the university level. Students work in labs, have practical engineering assignments, and may write a thesis to graduate, but, still, largely the vast majority of education time is spent in this \"passive learning with an instructor\" mode. This is a model which stretches far back in history and still pervades modern education.\n# The Pairwise Approach\n\nWhat if this is not the most efficient model for learning? At Pairwise, we believe that learning can be a much more active, guided process _especially_ for more practical skills like software engineering. Real world software engineering requires a healthy understanding of theoretical computer science and _a lot_ of practical coding skills. You just have to build apps that work and scale. Those hands\\-on, practical skills are what's valuable to new startups and businesses in the modern world.\n\nWe believe that the important conceptual material, which is less practical, is better taught in the context of practical examples and applications. Learning the theory of how a call stack works is great, but we think learning this in the context of writing recursive functions and running into stack overflow errors is a more powerful approach. Likewise with time and space complexity: we believe these concepts are more easily conveyed in the context of solving algorithms where time and space usage really makes a difference.\n\nWe also believe that the practical skills of software engineering are best taught through a series of guided tasks, challenges, and projects in a game\\-like structure. People love playing games, why not turn learning into a similar game? In traditional education, the \"checkpoints\" and \"goals\" are marked by stressful tests, examinations, and harsh grading systems.\n\nReflect for a moment on your own life: how much time have you spent in a stressed, anxious mode in advance of some test or exam in school? In your life, do you want to spend this many hours stressed about learning? Does the stress result in more learning? We believe the answers to all questions point to a big weakness in the traditional model of education.\n\nThere should be no stress or anxiety for a student working through the Pairwise curriculum. The focus is on completing practical challenges and projects in your own time, in your own way, at your own pace. No tests, no deadlines, no anxiety. There is no strict evaluation of completeness: at the end you will have a portfolio of impressive projects which can demonstrate you skills to any employer, or, you will know enough to become an employer yourself by kick\\-starting your own app idea from scratch.\n# Experiential, Supported Learning\n\nThe Pairwise curriculum is an application of experiential learning where you _learn by doing._ As you read through our challenges, you will see we try to have very short and simple instructions. This is not always possible, sometimes more explanatory material is required, but overall you should spent more time actively coding when working through Pairwise then you spend reading text or watching videos.\n\nHowever, we have organized and interspersed this experiential learning with supplementary content, explanations, examples, and guided videos, which are intended to serve as a \"build\\-in mentor\" to the student. There should be enough additional content that it's very hard to get totally lost and feel like giving up. At the same time, the challenges should be just challenging enough that the student feels like they are doable and always pushing them a little beyond their current learning threshold.\n# Reimagining Education\n\nThe primary goal of Pairwise is to create the most effective learning platform for students who want to learn to code and become software engineers. We have a strong vision about how this model of experiential, supported learning can create this platform, but over time we will always be looking for additional ways to enhance the learning approach with new features, content, and capabilities. The opportunity we see is that most education still mirrors the traditional teacher/student model, while we want to invest in reimagining how this model can be reinvented in the new economy we find ourselves living in."
        },
        {
          "id": "7j8@a2tVR",
          "type": "media",
          "title": "About the Pairwise Curriculum",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "https://www.youtube.com/embed/9a-KhJ_cxLo",
          "starterCode": "",
          "solutionCode": "",
          "content": "In this post, we will describe how we choose the content and technologies in the Pairwise curriculum. You can view our rationale in detail [here on our landing page](https://www.pairwise.tech/curriculum)."
        }
      ]
    },
    {
      "id": "fjuia91kz",
      "title": "Learning to Code",
      "challenges": [
        {
          "id": "f76s5a8x",
          "type": "media",
          "title": "Intro",
          "instructions": "",
          "testCode": "",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Welcome to the Learning to Code section of the Pairwise Library.\n\nHere you will find a collection of free writing and videos where we discuss a variety of topics around learning to code and becoming a software engineer."
        },
        {
          "id": "JzokCvMM",
          "type": "media",
          "title": "How to learn (anything)",
          "instructions": "",
          "testCode": "// test('message', () => expect(...))",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "Did you know that learning is itself a skill we can all learn and get better at? Let's talk a bit about the meta game of learning: How to learn _efficiently_. \n# Get a high\\-level view of what you're learning\n\nWhat I mean is, before diving in to the details something new \\(like this course\\) get an overview. I'll illustrate with an example: \n\n## To get an overview of this course you could...\n\n* Review the high level rational for the course [on the curriculum page](https://www.pairwise.tech/curriculum/). **\\(2 minutes\\)**\n* Open the navigation menu and skim through the titles. Try to internalize the high level roadmap. **\\(4 minutes\\)**\n   * Don't just read the module title and move on. Pause for at least 10 seconds and think \"Have I heard of this before? Does any of my existing knowledge tie in to this concept?\" \\(The answer may well be \"no\" but just try it out. For example, you've probably heard of databases. You may not know how they work but having heard of something can help you remember information about it later.\n   * You won't know how everything works just yet, but you can think to yourself \"So I'll start with basic programming concepts, then a programming language and eventually servers and databases.\"\n   * Having a clear idea in your head of where you're going will give you a better sense of your own progress and help you fit the different pieces together as you learn them.\n* When you start a module, skim through the navigation to get a sense of what challenges there will be and how many there are. **\\(5\\-10 minutes\\)**\n   * Also, open up the projects section and read through a project. Start at the end like this may be counterintuitive but it will give you a concrete example of _what_ you will learn. The projects are interim goals on your path to becoming a programmer. If a project sounds interesting keep it in mind as you go through challenges and you'll see how some challenges will apply to the project.\n\n\nThe same applies to traditional studies as well. If you just picked up a textbook try reading through the table of contents first, then skip to some problem sets _at the end_ of a few lessons to get a feel for what there is to learn.\n\nPart of what makes learning programming difficult is that ++there's no clear roadmap for how to become a programmer++. We know this because we've gone through the learning process ourselves and all of us had to create our own roadmap. That's why we've created the curriculum the way we did. Pairwise is a full roadmap for becoming a programmer. \n# Prioritize your learning\n\nThere's **A LOT** you could be learning in programming. If you want to see rapid progress you need to learn what's most relevant, first. If there's any time left you can learn more obscure topics later.\n\nFor example, here are some things you might be tempted to learn:\n\n* Multiple programming languages\n   * This is not a good use of time initially. Most programmers can program in more than one language, but we all had our _first_ language\\. Just learn one language at first and things will go much smoother. For this course we've chose TypeScript and we've laid out our reasoning here: [Pairwise Curriculum](https://www.pairwise.tech/curriculum/).\n* Obscure language features\n   * Every language has them, and for good reason—sometimes you need obscure features to get the job done. JavaScript \\(the language TypeScript is built on top of\\) is no exception, but these are features you can learn as you need them. For example, an introductory book on JavaScript will teach you about Bitwise Operators. When you come across this chapter **RUN**. This is not relevant yet and if it becomes relevant later you can learn about it then.\n* All language features\n   * Some people obsess about learning a language _completely _\\(I know because I used to be one such person...\\). This is not helpful. \n   * If you were just starting to learn English you would not benefit much from learning words like \"elucidate\", \"sanguine\", and \"wharf\" \\(if you disagree about this last one, you probably live near a wharf\\). You can be fully fluent in English without knowing every word. Likewise you can be fully fluent in a programming language without knowing every aspect of it. \n      * Confession: This author never learned JavaScript Generators 🙀They were just never needed for my work or personal projects. \n\n# Sleep\n\nThis is might be obvious but it bears repeating. ++When you're learning you need lots of sleep++. Your brain uses sleep in part to assimilate information you learn and synthesize new information. \n\nYou will be amazed how concepts you were barely grasping one day become easily understood and utilized the next day. It doesn't always happen as quickly as one day but it does happen. It's similar to learning a new human language. At first, nothing makes sense. The sounds are foreign, the script is tedious, the culture is incomprehensible. However, day by day sounds, words, actions all become more clear until eventually you're dreaming and conversing in a foreign language.\n\nSo get as much sleep as you can. You will learn more in less time.\n# Repetitions \\(aka practice\\)\n\nYou're going to need a lot. Despite learning as efficiently as you possibly can you will still need to do something more than once to get good at it. In fact you need to do it thousands of times.\n\nTo help convince you, consider...\n\n* **Sports**: How many times has Tiger Woods swung a golf club? How many times has Steph Curry shot a 3\\-pointer?\n* **Work**: How many do future\\-doctors _practice_ before they actually earn the title of doctor? Doctors may be extreme but also consider lawyers, plumbers, physicists, Spanish grammar teachers...\n* **School**: Teachers at all levels recognize the importance of repetitions. Homework is just a mechanism to incentivize repetitions.\n\n\n> To get good at something you need to do it many, many times ++even if you're learning as efficiently as possible++\n\nThis is where the challenges come in. We've created many challenges in part because we want you to attack the same problems again and again from different angles. Even if a challenge seems easy remember that you're completing more repetitions and getting better.\n# Real learning won't feel easy...\n\n... but that doesn't mean it's \"hard.\" When you're really learning you will be stretching your brain just a bit beyond what it already knows. This isn't going to feel easy, but it might feel exciting or fun. It might feel hard too, but even if it does, remember that it it gets easier with time. The better adapted your brain is to the task at hand the easier it will be. \n\nYour brain is literally building new neural connections when you learn—by the end of the course you will have a physically different brain than when you started. This won't happen overnight.\n# In summary\n\n* Start with an overview of whatever you're trying to learn\n* Prioritize your learning so you only spend time on the highest\\-impact concepts\n* Get _lots_ of sleep\n* Practice, practice, and then practice some more\n* Don't get discouraged. Learning isn't easy but it's extremely rewarding\n\n\nAnd if you feel that we left something out, you disagree about a specific point or you just want to leave us a note **please do**. We'd love to hear from you. \n\\(The feedback button is the question mark in the upper\\-right of the page\\)"
        },
        {
          "id": "SaImGhIZv",
          "type": "media",
          "title": "An Opinionated Overview of Programming Languages",
          "instructions": "",
          "testCode": "// Write your tests here:\ntest(\"`variable` should be defined\", () => {\n  expect(variable).toBeDefined();\n});\n",
          "videoUrl": "",
          "starterCode": "",
          "solutionCode": "",
          "content": "This is an overview of some of the programming languages that are in wide use today. Since programming languages are very different there are some very strong opinions about them among programmers. Therefore I'm going to take a two\\-pronged approach in this article to discussing programming languages. Below you will find sections on each of the chosen languages that look like this.\n\nA bunch of very normal looking text discussing the language from an objective perspective:\n\n* What is the language often used for?\n* What are some defining characteristics of the language?\n* What is the language particularly well suited too \\(straying towards subjective here, but not quite there yet\\)?\n\n\n> **Opinion Time**\\!\n> In callout boxes like this I'll give you my subjective take on the language. Take these boxes with a grain of salt. Whether you agree, disagree, or don't care it's all fine. I have some opinions that many other programmers would strongly disagree with and _that's OK_.\n> \n> Every language on this list is used to build real, non\\-trivial software, otherwise we wouldn't be talking about it. These languages are all very popular relative to [the list of **all** programming languages](https://en.wikipedia.org/wiki/List_of_programming_languages). This means these languages are all very useful and have provided a lot of value, so even if I'm not down on some of them \\(looking at you Java...\\) I'm not actually saying they are bad. Let's just say I would much rather program in some of the languages rather than others.\n# Language Comparison\n\nLet's start off with four big web programming languages that you've probably heard of.\n\n## JavaScript\n\nThe lingua franca of the web.\n\nThe big one. JavaScript is the language used in web browsers, which means it's the language that allows web browser to _run applications_ rather than just display text as webpages. This is a huge deal. It wasn't that long ago that all apps had to be installed on computers. JavaScript allows building apps on the web so that you can just type in a URL and start running. For examples of web apps look at:\n\n* Google Docs and Google Sheets\n   * Without JavaScript you could not use spreadsheets or do word processing in a browser—you would have to download and install an app. Many readers probably used to have or still have Microsoft Word and Excel installed. These are powerful apps and useful apps. JavaScript makes it possible to bring that same power to the web.\n* Google Maps\n   * Without JavaScript Google Maps would have to load a new web page every time you change the map. Search would still work fine but you wouldn't be able to zoom in and out or move the map around. In other words it would not be nearly as usable without JavaScript.\n* Youtube, Netflix, Facebook, Airbnb, Twitter\n   * And all of these as well\\! These, and almost any other online platform you use on a daily basis, rely heavily on JavaScript.\n* Pairwise\n   * Yes, I just put us on a list together with some of the most widely used apps in the world but the points stands. Pairwise is an app that lets you write code and have that code automatically evaluated and tested. This would not be possible without JavaScript.\n\n\n### What's it used for?\n\n**Everything**. This is no joke. Over the decade from 2010 to 2020 JavaScript proliferated wildly, some would even say out of control. These days you can use JavaScript for so much more than web apps. Things like:\n\n* [Machine Learning](https://www.tensorflow.org/js)\n* [IoT, Hardware, Robotics](http://johnny-five.io/)\n* [Mobile Apps](https://reactnative.dev/)\n* [Desktop Apps](https://www.electronjs.org/)\n* [Servers](https://nodejs.org/en/)\n\n\nJavaScript has even become a compile target for other languages. Meaning some languages written in other languages eventually end up as JavaScript code in order to run in certain places.\n\n### TypeScript\n\nSpeaking of compiling to JS, now's a good time to introduce the language we at Pairwise prefer: TypeScript. It's JavaScript but with a static typing system added on top. I won't go into it in depth here because we have an entire course on TypeScript and we wrote about it in much more depth here: [The TypeScript Language](/workspace/AvOR6cM4o).\n\n### My thoughts on JavaScript\n\n> As a language, it's OK. I know right? Fairly lackluster praise considering everything I said above. However, despite modern JavaScript being a massive improvement over the JavaScript of the past it still has its warts and that's ok. It's not a perfect language if such a thing can be said to exist \\(Clojure, anyone?\\).\n> \n> ++As a tool, it's phenomenal.++ This is where JavaScript really shines: Its usefulness. You can build for any platform using JS, which means your entire codebase can be JS too. This is no mean feat. Many companies today have a mobile app, a web app and at least one server app. Historically these different platforms might all require different codebases in different languages. Now you can use JS for all of these which makes it easier to build, easier to hire new engineers to continue to build and easier to reuse code across your codebases \\(plural\\).\n> \n> It's also extremely accessible. Since JavaScript is built\\-in to web browser anyone with a computer has access to the language _and a text editor_ since browser allow you to edit JS directly. The importance of this lack of friction cannot be overstated. Other languages require you to at the very least open a terminal \\(an obscure type of application most people know nothing about\\) and often install something to boot \\(using a terminal\\!\\).\n\n## Python\n\nThe reigning king of academia and data science. \n\n### What's it used for?\n\nPython is used for many, many things. It's breadth of application and usefulness as a productivity tool rival even JS. Python has become the tool of choice for many who wouldn't even consider themselves programmers. It's syntax is easy to pick up \\(especially if it's not your first programming language\\) and it's built in library provides rich tools for getting all sorts of things done form writing networking code to building games to running web servers.\n\nThat's a bit vague though. Here are some more concrete common uses of python:\n\n* Machine learning\n* Data analysis\n* Simple scripts/tools\n* Web servers\n   * Python is the language of Flask and Django, to very popular server technologies.\n\n\n### My thoughts on Python\n\n> As a language, it's pretty great. There are some caveats of course, but at a language level things are pretty good. The significance of whitespace means that Python code generally looks uniform, which is a big win when reading someone else's code. Python, in my mind, epitomizes what a high\\-level language should be: You don't have to worry about memory management \\(a defining feature of high\\-level languages\\) but you also don't have to worry about different types of variables like you do in JS \\(let, const, var\\). Class instance methods can easily and transparently be passed another instance. Functions are first\\-class and can be passed around as values.\n> \n> Oh the caveats though. There are three things which in my mind \\(slightly\\) mar Python's track record:\n> \n> \n>    * 2 vs 3...\n>       * Long story short python handled strings in one way in version 2, then changed that way to be much better in version 3 and also changed a bit of very common syntax. The changes were good, but everyone's code broke and consequently the switch in the ecosystem from 2 to 3 is _still in progress_ more than a decade after the release.\n>    * How do I set up my environment? \n>       * This question has more than one answer, which is the problem. There are many ways to set up a python environment and as soon as you start looking in to how you're going to have to learn what a \"virtual environment\" is which is pretty high friction for just running some code.\n>       * You may be thinking \"Just use built\\-in python\" \\(it comes with most computers\\). The problem is, because of the 2 vs 3 issue above there's a lot of code you'll find online that won't work with the preinstalled Python, causing more friction. Caveats aside, Python is still a great language and is nearly as useful as JS. That's the rub though: JS is still more useful, at least unless you have something specific you want to do and know Python is better for it. This this point is debatable but JS is decidedly more accessible than Python and it's more widely used. This was both my impression from working in Silicon Valley and is also [backed up by StackOverflow data](https://insights.stackoverflow.com/survey/2019#technology). \n\n## Ruby\n\nThe friendliest and possibly most productive language around \\(If you consider Ruby and Rails as a package deal\\).\n\n### What's it used for?\n\n**Building server\\-side web applications**. Ruby is a general purpose language, so just like with Python and JavaScript you can build all sorts of things with it, but its most common use case by far is building server\\-side apps. Why is that?\n\n### Rails\n\nRuby has benefitted from having one of the most popular and productive web development frameworks ever created: [Ruby on Rails](https://rubyonrails.org/). It's _really_ good for building web applications with, assuming you don't need any app logic in the browser \\(and you often don't\\).\n\nThe trick is, Ruby on Rails will generate a whole bunch of Ruby code for you, which makes getting an app up and running for the first time extremely quick. An experienced Rails developer could build a Twitter clone in 30 minutes. It wouldn't actually be everything Twitter is but the point stands. You'd be hard pressed to find another framework that can get you up and running that quickly.\n\nConsequently, Ruby is the language of choice for web development agencies—Companies you can pay to build web apps for you.\n\n### My thoughts on Ruby\n\n> As a language, I tend to like it. Not as much as Python, maybe about as much as JS. \n> However, as a tool Ruby's usefulness pales in comparison to JS. If you're just building web apps, or you want to optimize for building _new web apps_ all the time then Ruby \\+ Rails is hands down the best choice in my book. However, if you want to build for other platforms or you want to get a job as a software engineer then there are better choices.\n> \n> It's worth noting that Ruby's usefulness is not limited by the language itself. Ruby can do anything Python can do in theory \\(although not as much as JS\\), however, the ecosystem of tools around Ruby has evolved much less broadly, perhaps due in part to the massive success of Rails.\n\n## PHP\n\nOh the classic\\! The language of the early web and still the language of individual freelancers around the world. The language upon which was built the empires of both Facebook and Wordpress.\n\n> Incidentally, PHP is also the first programming language this author learned. Although it's been years since I've written anything meaningful in it.  \n\nTo say PHP is \"of the early web\" may imply that it is no longer in widespread use, but that is not the intent. PHP is very much alive and still ubiquitous in many parts of the world. \n\n### What's it used for?\n\n**Building server\\-side web applications**. That's right, just like Ruby. In fact, PHP even has an extremely popular web framework called Laravel which serves much the same role as Rails in Ruby land.\n\nUnlike Ruby, PHP is used less for things outside the context of web servers. It can be used as a general purposes programming language but the thrust of PHP development over the years has been very much towards server\\-side web applications.\n\n* Do you remember online forums? Most online forum software is written in PHP. \n* Do you use Facebook? Facebook was initially written in PHP but they later developed their own language called [Hack](https://hacklang.org/), which is both statically typed and _much_ faster than traditional PHP.\n* Do you use Wordpress? Even if you don't have a Wordpress site yourself you've probably used many of them. Wordpress is all over the place because it provides a built\\-in content management system.\n\n\n### My thoughts on PHP\n\n> It's really not for me. I used to quite like PHP \\(it was my first programming language\\) but after I discovered Ruby \\(my second\\) I realized the syntax of PHP as cumbersome and the packaging system nonexistent \\(later on Composer came around, which was pretty cool\\). PHP does have an interesting way of approaching dynamic web pages though, and lots of interesting web software has been built with it. \n# Other Languages in Brief\n\nThere are tons of other programming languages that aren't mentioned here, but here are a few that might spark some interest.\n\n> Disclaimer\\. I don't have much experience with most of these so my views likely differ significantly from someone who's worked with one of these languages for a long time.\n\n* Java \\(not to be confused with JavaScript\\)\n   * A pain to write. Extremely object\\-oriented. Everything must be statically typed _by hand_ \\(Very time consuming and tedious\\).\n   * Cross platform, which is actually really wonderful. Write something once and run it on Mac, Linux, Windows, Android.\n   * The language of Android.\n   * Used by banks, insurance companies, the government, etc. \n* C#\n   * Like Java, but for Microsoft stuff.\n   * The language of the Unity game engine, which makes it also the language of many video games.\n* Objective\\-C\n   * The old language of Apple \\(Mac computers, iPhones and iPads\\).\n   * Odd syntax, lots of square brackets.\n* Swift\n   * The new language of Apple \\(Mac computers, iPhones and iPads\\).\n   * Pretty intuitive syntax, looks a lot like JavaScript. But JavaScript looks a lot like C as do many languages.\n* C\n   * The workhorse systems language. An old, powerful language.\n   * Very easy to break things or write code with unexpected behavior.\n   * The language of operating systems.\n   * The language of many languages. Python and Ruby are both written in C.\n   * Fast\\.\n* C\\+\\+\n   * Like C but with a whole bunch of features added in. \n   * Many games / game engines are written in C\\+\\+.\n   * Many browsers \\(like Chrome\\) are written in C\\+\\+.\n* Rust\n   * A systems language, like C, but with modern syntax and language features like a static type system.\n   * Much of Firefox is written in Rust.\n   * Popular choice for many new blockchain projects.\n* Go\n   * Often compared with Rust, also with static typing but with memory safety and garbage collection.\n   * Easy to learn and get started with.\n   * Built and maintained by Google.\n* Haskell\n   * A functional programming language.\n   * _VERY_ different syntax from the C\\-family languages on the list.\n   * Emphasizes strong typing, functional purity, deliberate management of side effects.\n* Clojure\n   * A functional programming language.\n   * A Lisp, which means one of many flavors of language that use an absurd number of parentheses.\n   * Emphasizes immutable data and simplicity over ease of use.\n\n# Which Language Should I Learn?\n\nUnlike many blogs, I have an answer for you: TypeScript or JavaScript \\(Learning TypeScript will also teach you JavaScript, but not the other way around\\).\n\nLearning TypeScript will also teach you about static typing and using compiled languages, features of many of the languages listed above. You'll have the full background you need to quickly pick up a new language, although you almost certainly won't have to given how broadly useful TypeScript and JavaScript are.  \n\n## Why not X?\n\nIf you have something in mind that you'd like to learn then by all means go for it\\! Harness your motivation, it won't last forever.\n\nMy recommendation of JS/TS is not meant to discourage you from learning something else, but rather to give you a starting point if you're not sure where to start.\n\nIf you do want to learn TypesScript then we have a course for that:\n\n👉[Start learning TypeScript](/workspace/iSF4BNIl) 👈"
        }
      ]
    }
  ]
}